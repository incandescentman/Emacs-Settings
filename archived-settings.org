
** Sounds
#+BEGIN_EXAMPLE emacs-lisp
(unless (and (fboundp 'play-sound-internal)
      (subrp (symbol-function 'play-sound-internal)))
  (require 'play-sound))


;; (add-hook 'org-after-todo-state-change-hook 'my-org-after-todo)
;; (defun my-org-after-todo () (play-sound-file "~/sounds/InkSoundStroke3.mp3"))
#+END_EXAMPLE


** Stop mouse cursor from highlighting lines in org-agenda
#+BEGIN_SRC emacs-lisp
(add-hook 'org-finalize-agenda-hook
(lambda () (remove-text-properties
(point-min) (point-max) '(mouse-face t))))
#+END_SRC


** org capture
Make org-capture open in full window! :-)
#+BEGIN_EXAMPLE emacs-lisp
(add-hook 'org-capture-mode-hook 'delete-other-windows)
(add-hook 'org-capture-mode-hook 'writeroom-mode)
#+END_EXAMPLE



* ido
#+BEGIN_EXAMPLE emacs-lisp
(add-hook 'ido-setup-hook
   (lambda ()
     ;; Go straight home
     (define-key ido-file-completion-map
       (kbd "~")
       (lambda ()
  (interactive)
  (if (looking-back "/")
      (insert "~/")
    (call-interactively 'self-insert-command))))))

(use-package ido
:defer
:config
(setq ido-ignore-directories  '("\\`CVS/" "\\`\\.\\./" "\\`\\./" ".git"))
(setq ido-ignore-files  '("\\`CVS/" "\\`#" "\\`.#" "\\`\\.\\./" "\\`\\./" "tex" "html" ".mm" "Icon*" ".git"))

(ido-mode t)

(setq ido-enable-prefix nil
   ido-enable-flex-matching t
   ido-create-new-buffer 'always
   ido-use-filename-at-point 'guess
   ido-use-virtual-buffers t
   ido-handle-duplicate-virtual-buffers 2
   ido-decorations (quote ("{" "}" " | " " | ..." "[" "]" " [No match]" " [Matched]" " [Not so readable bro]" " [Too big yo]" " [Make it so.]"))
   ido-enable-last-directory-history t
ido-enter-matching-directory nil
   ido-use-faces t
   ido-use-url-at-point t
   ido-max-prospects 10)
;; (ido-everywhere t)

(setq confirm-nonexistent-file-or-buffer nil)
;; (ido-everywhere 1)
(setq ido-enable-last-directory-history t)
(setq ido-confirm-unique-completion t) ;; wait for RET, even for unique?
(setq ido-show-dot-for-dired nil) ;; put . as the first item
(setq ido-use-filename-at-point t) ;; prefer file names near point
(setq ido-use-filename-at-point 'guess)
(setq ido-file-extensions-order '(".org" ".txt" ".md" ".emacs" ".el"))

; Use IDO for both buffer and file completion and ~ido-everywhere~ to ~t~:
(setq ido-max-directory-size 100000)
(ido-mode (quote both))


; Use the current window when visiting files and buffers with IDO:
(setq ido-default-file-method 'selected-window)
(setq ido-default-buffer-method 'selected-window)


; Sort ido filelist by mtime instead of alphabetically. Why would anyone want an alphabetically sorted list? You can save keystrokes if the most recently modified files are at the front:
(add-hook 'ido-make-file-list-hook 'ido-sort-mtime)
(add-hook 'ido-make-dir-list-hook 'ido-sort-mtime)
(defun ido-sort-mtime ()
 (setq ido-temp-list
    (sort ido-temp-list
       (lambda (a b)
        (time-less-p
         (sixth (file-attributes (concat ido-current-directory b)))
         (sixth (file-attributes (concat ido-current-directory a)))))))
 (ido-to-end ;; move . files to end (again)
  (delq nil (mapc
       (lambda (x) (and (char-equal (string-to-char x) ?.) x))
       ido-temp-list))))

; Add superior flex matching to ~ido-mode~:
(flx-ido-mode 1)

; disable IDO faces to see flx highlights:
(setq ido-use-faces nil)

(defun ido-bookmark-jump (bname)
 "*Switch to bookmark interactively using `ido'."
 (interactive (list (ido-completing-read "Bookmark: " (bookmark-all-names) nil t)))
 (bookmark-jump bname))

(setq
 ido-ignore-files (quote ("\\`CVS/" "\\`#" "\\`.#" "\\`\\.\\./" "\\`\\./" "html" "*.mm" "Icon*" "*gz" "*ido.hist" "*archive*" "ics")))

(defun ido-goto-symbol (&optional symbol-list)
 "Refresh imenu and jump to a place in the buffer using Ido."
 (interactive)
 (unless (featurep 'imenu)
  (require 'imenu nil t))
 (cond
  ((not symbol-list)
  (let ((ido-mode ido-mode)
     (ido-enable-flex-matching
      (if (boundp 'ido-enable-flex-matching)
        ido-enable-flex-matching t))
     name-and-pos symbol-names position)
   (unless ido-mode
    (ido-mode 1)
    (setq ido-enable-flex-matching t))
   (while (progn
        (imenu--cleanup)
        (setq imenu--index-alist nil)
        (ido-goto-symbol (imenu--make-index-alist))
        (setq selected-symbol
           (ido-completing-read "Symbol? " symbol-names))
        (string= (car imenu--rescan-item) selected-symbol)))
   (unless (and (boundp 'mark-active) mark-active)
    (push-mark nil t nil))
   (setq position (cdr (assoc selected-symbol name-and-pos)))
   (cond
    ((overlayp position)
    (goto-char (overlay-start position)))
    (t
    (goto-char position)))))
  ((listp symbol-list)
  (dolist (symbol symbol-list)
   (let (name position)
    (cond
     ((and (listp symbol) (imenu--subalist-p symbol))
     (ido-goto-symbol symbol))
     ((listp symbol)
     (setq name (car symbol))
     (setq position (cdr symbol)))
     ((stringp symbol)
     (setq name symbol)
     (setq position
        (get-text-property 1 'org-imenu-marker symbol))))
    (unless (or (null position) (null name)
          (string= (car imenu--rescan-item) name))
     (add-to-list 'symbol-names name)
     (add-to-list 'name-and-pos (cons name position))))))))


)


#+END_EXAMPLE

* Fuzzy matching

** imenu
[[http://metasandwich.com/2013/01/19/emacs-config-youre-doing-it-wrong/][link]]

#+BEGIN_EXAMPLE emacs-lisp
(defun imenu-elisp-sections ()
  (setq imenu-prev-index-position-function nil)
  (add-to-list 'imenu-generic-expression '("Sections" "^;;;; \\(.+\\)$" 1) t))

(add-hook 'emacs-lisp-mode-hook 'imenu-elisp-sections)
;; helm-imenu
#+END_EXAMPLE

Jump to a definition in the current file. (This is awesome.)
#+BEGIN_EXAMPLE emacs-lisp
(global-set-key (kbd "C-x C-i") 'ido-imenu)
(defun try-to-add-imenu ()
  (condition-case nil (imenu-add-to-menubar "I love you.") (error nil)))
(add-hook 'font-lock-mode-hook 'try-to-add-imenu)
#+END_EXAMPLE

** Helm
Make helm-grep search recursively by default. I want helm-grep to search not only inside the current folder, but also inside subfolders.

#+BEGIN_EXAMPLE emacs-lisp
(setq helm-M-x-always-save-history t)
(eval-after-load 'helm-grep
  '(setq helm-grep-default-command helm-grep-default-recurse-command))
#+END_EXAMPLE


** Helm
#+BEGIN_EXAMPLE emacs-lisp
(use-package helm-swoop
:defer)
; (global-set-key (kbd "M-i") (lambda() (interactive) (helm-swoop :$query nil)))

(setq helm-swoop-pre-input-function
      (lambda () nil))
#+END_EXAMPLE

When doing isearch, hand the word over to ~helm-swoop~:
#+BEGIN_SRC emacs-lisp
(define-key isearch-mode-map (kbd "M-i") 'helm-swoop-from-isearch)
#+END_SRC

From ~helm-swoop~ to ~helm-multi-swoop-all~:
#+BEGIN_EXAMPLE emacs-lisp
;; (define-key helm-swoop-map (kbd "M-i"); 'helm-multi-swoop-all-from-helm-swoop)
#+END_EXAMPLE

Save buffer when ~helm-multi-swoop-edit~ completes:
#+BEGIN_EXAMPLE emacs-lisp
;; (setq helm-multi-swoop-edit-save t)
#+END_EXAMPLE

If this value is ~t~, split window inside the current window:
#+BEGIN_EXAMPLE emacs-lisp
;; (setq helm-swoop-split-with-multiple-windows nil)
#+END_EXAMPLE

Split direcion. ~split-window-vertically~ or ~split-window-horizontally~:
#+BEGIN_EXAMPLE emacs-lisp
;; (setq helm-swoop-split-direction 'split-window-vertically)
#+END_EXAMPLE

If ~nil~, you can slightly boost invoke speed in exchange for text color:
#+BEGIN_EXAMPLE emacs-lisp
;; (setq helm-swoop-speed-or-color nil)
#+END_EXAMPLE

#+BEGIN_EXAMPLE emacs-lisp
;; (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; rebihnd tab to do persistent action
;; (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action) ; make TAB works in terminal
;; (define-key helm-map (kbd "C-z")  'helm-select-action) ; list actions using C-z
#+END_EXAMPLE

#+BEGIN_EXAMPLE emacs-lisp
;; (global-set-key (kbd "C-x r l") #'helm-filtered-bookmarks)
;; (global-set-key (kbd "M-y")     #'helm-show-kill-ring)
;; (global-set-key (kbd "M-s /")   #'helm-multi-swoop)

(setq helm-ff-transformer-show-only-basename nil
      helm-adaptive-history-file             "~/emacs/.savefile/helm-history"
      helm-yank-symbol-first                 t
      helm-move-to-line-cycle-in-source      t
      helm-buffers-fuzzy-matching            t
      helm-ff-auto-update-initial-value      t)

(autoload 'helm-descbinds      "helm-descbinds" t)
(autoload 'helm-eshell-history "helm-eshell"    t)
(autoload 'helm-esh-pcomplete  "helm-eshell"    t)

(global-set-key (kbd "M-h a")    #'helm-apropos)
(global-set-key (kbd "M-h i")    #'helm-info-emacs)
(global-set-key (kbd "M-h b")    #'helm-descbinds)

(add-hook 'eshell-mode-hook
          #'(lambda ()
              (define-key eshell-mode-map (kbd "TAB")     #'helm-esh-pcomplete)
              (define-key eshell-mode-map (kbd "C-c C-l") #'helm-eshell-history)))


(global-set-key (kbd "C-x c!")   #'helm-calcul-expression)
(global-set-key (kbd "C-x c:")   #'helm-eval-expression-with-eldoc)
(define-key helm-map (kbd "M-o") #'helm-previous-source)

(global-set-key (kbd "M-s s")   #'helm-again)
#+END_EXAMPLE



** helm projectile
#+BEGIN_EXAMPLE emacs-lisp


(setq ad-redefinition-action 'accept)
(use-package helm-projectile
:defer
:config
(setq helm-projectile-sources-list (cons 'helm-source-projectile-files-list
(remove 'helm-source-projectile-files-list helm-projectile-sources-list)))
)

(helm-projectile-on)

(define-key projectile-mode-map (kbd "C-c p /")
  #'(lambda ()
      (interactive)
      (helm-ag (projectile-project-root))))
#+END_EXAMPLE



* helm search current directory
#+BEGIN_EXAMPLE emacs-lisp
(defun helm-do-grep-current-directory-tree ()
  "Recursively search current directory.
If a parent directory has a `dir-locals-file', use that as the
root instead."
  (interactive)
  (let ((variables-file (dir-locals-find-file
                         (or (buffer-file-name) default-directory))))
    (helm-do-grep-1
     (list
      (cond
       ((stringp variables-file)
        (file-name-directory variables-file))
       ((consp variables-file)
        (nth 0 variables-file))
       (t default-directory)))
     t nil '("*"))))
#+END_EXAMPLE



* org-agenda skip keywords
#+BEGIN_SRC emacs-lisp
;; (setq org-agenda-custom-commands '(org-agenda-skip-function 'org-agenda-skip-regexp-if 'todo '("MISSED" "COMMITTED" "RESULTS")))
#+END_SRC

* org-ellipsis
#+BEGIN_SRC emacs-lisp
;; (setq org-ellipsis " ◦◦◦ ")
;; (set-face-attribute org-ellipsis '(((:background "white" :underline nil))))

;; (setq org-ellipsis "⤵")
;; other interesting characters are ▼, ↴, ⬎, ⤷, and ⋱

(setq org-ellipsis "...")
#+END_SRC



** god mode
#+BEGIN_EXAMPLE emacs-lisp
;; (use-package god-mode)
(defun my-update-cursor ()
  (setq cursor-type (if (or god-local-mode buffer-read-only)
                        'bar
                      'box)))

;; (add-hook 'god-mode-enabled-hook 'my-update-cursor)
;; (add-hook 'god-mode-disabled-hook 'my-update-cursor)


             (use-package god-mode-isearch
             :defer)
(define-key isearch-mode-map (kbd "<escape>") 'god-mode-isearch-activate)
(define-key god-mode-isearch-map (kbd "<escape>") 'god-mode-isearch-disable)
(define-key god-local-mode-map (kbd ".") 'repeat)


#+END_EXAMPLE




** org go speed
; Speed commands are really useful, but I often want to make use of
; them when I'm not at the beginning of a header. This command brings
; you back to the beginning of an item's header, so that you can do
; speed commands.

(defun org-go-speed ()
  "Goes to the beginning of an element's header, so that you can
execute speed commands."
  (interactive)
  (when (equal major-mode 'org-mode)
    (if (org-at-heading-p)
        (org-beginning-of-line)
      (org-up-element))))

; bind-key comes from Use Package
(bind-key "C-c s" 'org-go-speed)

(global-set-key "\M-9" 'backward-sexp)
(global-set-key "\M-0" 'forward-sexp)




* convert from org-mode to Word
#+BEGIN_SRC emacs-lisp
;; This setup is tested on Emacs 24.3 & Emacs 24.4 on Linux/OSX
;; org v7 bundled with Emacs 24.3
(setq org-export-odt-preferred-output-format "doc")
;; org v8 bundled with Emacs 24.4
(setq org-odt-preferred-output-format "doc")
;; BTW, you can assign "pdf" in above variables if you prefer PDF format

;; Only OSX need below setup
(defun my-setup-odt-org-convert-process ()
  (interactive)
  (let ((cmd "/Applications/LibreOffice.app/Contents/MacOS/soffice"))
    (when (and (eq system-type 'darwin) (file-exists-p cmd))
      ;; org v7
      (setq org-export-odt-convert-processes '(("LibreOffice" "/Applications/LibreOffice.app/Contents/MacOS/soffice --headless --convert-to %f%x --outdir %d %i")))
      ;; org v8
      (setq org-odt-convert-processes '(("LibreOffice" "/Applications/LibreOffice.app/Contents/MacOS/soffice --headless --convert-to %f%x --outdir %d %i"))))
    ))
(my-setup-odt-org-convert-process)
#+END_SRC

Source: [[http://blog.binchen.org/posts/how-to-take-screen-shot-for-business-people-efficiently-in-emacs.html][How to take screen shot for business people efficiently in Emacs | Chen's blog]]

2.4 Tips

If you need page break in exported document, insert below snippet into the org file:

#+ODT: <text:p text:style-name="PageBreak"/>



* hydras experiments
#+BEGIN_EXAMPLE emacs-lisp
(defhydra email (global-map "s-]")
 "email"
 ("a" erika-send-email)
 ("i" notmuch "inbox")
 ("n" new-email-from-subtree-no-signature "new-email-from-subtree-no-signature")
 ("s" new-email-from-subtree-with-signature "new-email-from-subtree-with-signature")
)


(defhydra hydra-zoom (global-map "s-[")
 "email"
 ("e" erika-send-mail)
 ("n" notmuch)
)


#+END_EXAMPLE

#+BEGIN_EXAMPLE emacs-lisp


(global-set-key
 (kbd "C-p")
(defhydra hydra-move-previous
   (:body-pre (previous-line))
   "move"
("p" previous-line)
("n" next-line)
("k" my/kill-line-dwim)
   ("f" forward-char)
   ("b" backward-char)
   ("a" beginning-of-line)
   ("e" move-end-of-line)
   ("v" scroll-up-command)
   ;; Converting M-v to V here by analogy.
   ("V" scroll-down-command)
   ("l" recenter-top-bottom)))


(global-set-key
 (kbd "C-n")
(defhydra hydra-move-next
   (:body-pre (next-line))
   "move"
   ("n" next-line)
   ("p" previous-line)
   ("k" my/kill-line-dwim)
   ("f" forward-char)
   ("b" backward-char)
   ("a" beginning-of-line)
   ("e" move-end-of-line)
   ("v" scroll-up-command)
   ;; Converting M-v to V here by analogy.
   ("V" scroll-down-command)
   ("l" recenter-top-bottom)))




(global-set-key
 (kbd "s-n")
(defhydra accountability-move
   (:body-pre (next-line))
   "move"
   ("n" org-next-visible-heading)
   ("p" org-previous-visible-heading)
   ("k" org-cut-subtree)
   ("f" forward-char)
   ("b" backward-char)
   ("d" org-todo)
   ("m" (lambda nil (interactive) (org-todo "MISSED")))
   ("e" move-end-of-line)
   ("v" scroll-up-command)
   ;; Converting M-v to V here by analogy.
   ("V" scroll-down-command)
   ("l" recenter-top-bottom)
))



#+END_EXAMPLE

Projectile hydra [[https://github.com/abo-abo/hydra/wiki/Projectile][Projectile - abo-abo/hydra Wiki]]



* hydra helm
#+BEGIN_SRC emacs-lisp
(defhydra hydra-helm (:hint nil :color pink)
 "
           ╭──────┐
   Navigation   Other  Sources     Mark             Do             Help   │ Helm │
  ╭───────────────────────────────────────────────────────────────────────┴──────╯
 ^_k_^         _K_       _p_   [_m_] mark         [_v_] view         [_H_] helm help
 ^^↑^^         ^↑^       ^↑^   [_t_] toggle all   [_d_] delete       [_s_] source help
    _h_ ←   → _l_     _c_       ^ ^   [_u_] unmark all   [_f_] follow: %(helm-attr 'follow)
 ^^↓^^         ^↓^       ^↓^    ^ ^               [_y_] yank selection
 ^_j_^         _J_       _n_    ^ ^               [_w_] toggle windows
--------------------------------------------------------------------------------
 "
 ("<tab>" helm-keyboard-quit "back" :exit t)
 ("<escape>" nil "quit")
 ("\\" (insert "\\") "\\" :color blue)
 ("h" helm-beginning-of-buffer)
 ("j" helm-next-line)
 ("k" helm-previous-line)
 ("l" helm-end-of-buffer)
 ("g" helm-beginning-of-buffer)
 ("G" helm-end-of-buffer)
 ("n" helm-next-source)
 ("p" helm-previous-source)
 ("K" helm-scroll-other-window-down)
 ("J" helm-scroll-other-window)
 ("c" helm-recenter-top-bottom-other-window)
 ("m" helm-toggle-visible-mark)
 ("t" helm-toggle-all-marks)
 ("u" helm-unmark-all)
 ("H" helm-help)
 ("s" helm-buffer-help)
 ("v" helm-execute-persistent-action)
 ("d" helm-persistent-delete-marked)
 ("y" helm-yank-selection)
 ("w" helm-toggle-resplit-and-swap-windows)
 ("f" helm-follow-mode))
#+END_SRC
[[https://github.com/abo-abo/hydra/wiki/Helm-2][Helm 2 - abo-abo/hydra Wiki]]




* re-builder large
#+BEGIN_SRC emacs-lisp

(defun re-builder-large ()
  "Just like `re-builder', only make the font and window larger."
  (interactive)
  (re-builder)
  (text-scale-increase 5)
  (set-window-text-height (selected-window) 7))

#+END_SRC


* reuse directory buffers
#+BEGIN_EXAMPLE emacs-lisp
(load "/Users/jay/emacs/emacs-settings/dired+.el")
(use-package dired+
:defer
 :init
 (progn
  (spacemacs/set-leader-keys
  "ab" 'diredp-do-bookmark)))

(toggle-diredp-find-file-reuse-dir 1)
(add-hook 'dired-mode-hook
 (lambda ()
  (define-key dired-mode-map (kbd "C-<up>")
    (lambda () (interactive) (find-alternate-file "..")))
  ; was dired-up-directory
 ))
#+END_EXAMPLE


* calc eval region
#+BEGIN_SRC emacs-lisp
(defun calc-eval-region (arg)
  "Evaluate an expression in calc and communicate the result.

If the region is active evaluate that, otherwise search backwards
to the first whitespace character to find the beginning of the
expression. By default, replace the expression with its value. If
called with the universal prefix argument, keep the expression
and insert the result into the buffer after it. If called with a
negative prefix argument, just echo the result in the
minibuffer."
  (interactive "p")
  (let (start end)
(if (use-region-p)
    (setq start (region-beginning) end (region-end))
  (progn
    (setq end (point))
    (setq start (search-backward-regexp "\\s-\\|\n" 0 1))
    (setq start (1+ (if start start 0)))
    (goto-char end)))
(let ((value (calc-eval (buffer-substring-no-properties start end))))
  (pcase arg
    (1 (delete-region start end))
    (4 (insert " = ")))
  (pcase arg
    ((or 1 4) (insert value))
    (-1 (message value))))))
#+END_SRC



* Make Messages Buffer modifiable in Emacs 24.4
Chen Bin

Insert below code into the beginning of ~/.emacs because any part of .emacs may create Messages Buffer instance.

#+BEGIN_SRC emacs-lisp
(when (boundp 'messages-buffer-mode-hook)
 (defun messages-buffer-mode-hook-setup ()
 (read-only-mode -1))
 (add-hook 'messages-buffer-mode-hook 'messages-buffer-mode-hook-setup))
#+END_SRC



** No worries when elpa is down
Chen Bin

I use one liner shell command to clone Emacs Lisp Package Archive (ELPA):

#+BEGIN_EXAMPLE sh
mkdir -p ~/elpaclone && cd ~/elpaclone && curl -L https://elpa.gnu.org/packages/archive-contents | perl -pe 's/(^\(1|\n)//g' | perl -pe 's/\]\)/])\n/g' | perl -pe 's/^ *\(([a-z0-9A-Z-]*).*\[\(([0-9 ]*).*(single|tar).*/\1-\2.\3/g' | perl -pe 's/ /./g' | perl -pe 's/single/el/g' | perl -pe 's/\)//g' | xargs -I {} curl -L -O https://elpa.gnu.org/packages/{} && curl -L -O https://elpa.gnu.org/packages/archive-contents
#+END_EXAMPLE


The http://bit.ly/2brTy2S is contains all the information of packages. I re-organize it content to make sure every line contains one package's information. Then I use curl to download everything.

Usage is simple.

Insert below line at the beginning of ~/.emacs when elpa.gnu.org is down:

#+BEGIN_EXAMPLE emacs-lisp
(setq package-archives '(("elpaclone" . "~/elpaclone")))
#+END_EXAMPLE

This solution also works for MELPA.



* ivy counsel
#+BEGIN_EXAMPLE emacs-lisp
(use-package counsel
:defer
 :bind
 (("M-y" . counsel-yank-pop)
  :map ivy-minibuffer-map
  ("M-y" . ivy-next-line)))
#+END_EXAMPLE

(ivy-mode 1)
(setq ivy-use-virtual-buffers t)
(global-set-key "\C-s" 'swiper)
(global-set-key (kbd "C-c C-r") 'ivy-resume)
(global-set-key (kbd "<f6>") 'ivy-resume)
(global-set-key (kbd "M-x") 'execute-extended-command)
(global-set-key (kbd "C-x C-f") 'counsel-find-file)
(global-set-key (kbd "<f1> f") 'counsel-describe-function)
(global-set-key (kbd "<f1> v") 'counsel-describe-variable)
(global-set-key (kbd "<f1> l") 'counsel-load-library)
(global-set-key (kbd "<f2> i") 'counsel-info-lookup-symbol)
(global-set-key (kbd "<f2> u") 'counsel-unicode-char)
(global-set-key (kbd "C-c g") 'counsel-git)
(global-set-key (kbd "C-c j") 'counsel-git-grep)
(global-set-key (kbd "C-c k") 'counsel-ag)
(global-set-key (kbd "C-x l") 'counsel-locate)
(global-set-key (kbd "C-S-o") 'counsel-rhythmbox)
(define-key read-expression-map (kbd "C-r") 'counsel-expression-history)



* screenflick
#+BEGIN_SRC emacs-lisp
(defun screenflick-mode ()
(interactive)
;; (setq evil-emacs-state-cursor '("red" (hbar . 2))) ; for horizontal cursor
(horizontal-cursor)
(spacemacs/toggle-highlight-current-line-globally-off)
(adobe-garamond-pro)
(toggle-fullscreen)
(writeroom-mode)
)
#+END_SRC


* swiper-mc
#+BEGIN_EXAMPLE emacs-lisp
(defun swiper-mc ()
(interactive)
(unless (require 'multiple-cursors nil t)
(error "multiple-cursors isn't installed")) (let ((cands (nreverse ivy--old-cands)))
(unless (string= ivy-text "") (ivy-set-action
(lambda (_) (let (cand)
(while (setq cand (pop cands)) (swiper--action cand)
(when cands
               (mc/create-fake-cursor-at-point))))
         (mc/maybe-multiple-cursors-mode)))
(setq ivy-exit 'done) (exit-minibuffer))))
#+END_EXAMPLE



* message-mode
#+BEGIN_SRC emacs-lisp
(defun message-mode-next-field ()
  (interactive)
  (next-line)
  (end-of-line))

(setq message-tab-body-function (quote message-mode-next-field))
#+END_SRC


* tramp
#+BEGIN_SRC emacs-lisp
(setq tramp-default-method "ssh")
#+END_SRC




** Org-transclusion enhancements
These enhancements aim to streamline the process of working with transclusions in Org documents, making it more intuitive and efficient.

** Enhanced Functionality
1. *Toggle Transclusion*:

- *Function*: ~tr-toggle-transclusion~
- *Description*: Toggle transclusion on or off with a single keystroke. If the point is on a line starting with ~#+transclude:~, it expands it. If the point is on a transclusion, it collapses it.
- *Usage*: Use this function to quickly toggle transclusions without having to think about whether you're expanding or collapsing transclusion states.

2. *Alias Definitions*:

- *Aliases*:
- ~tr-expand~ for ~org-transclusion-add~
- ~tr-collapse~ for ~org-transclusion-remove~
- ~tr-make-link~ for ~org-transclusion-make-from-link~
- ~tr-expand-or-collapse~ for ~org-transclusion-add-or-remove~
- *Description*: Shorter and more intuitive command names are provided as aliases to the existing transclusion commands, simplifying recall.

3. *Insert Transclusion Links*:

- *Function*: ~tr-insert-transclusion~
- *Description*: Inserts transclusion links by integrating with ~org-roam-node-insert~. Automatically prepends ~#+transclude:~ to the links.


#+begin_src emacs-lisp
(load "/Users/jay/Dropbox/github/org-transclusion-power-pack/org-transclusion-power-pack.el")
#+end_src

both of these functions work. the first was generated by ChatGPT 4.0, the second by Claude 3 Opus.

this also works:
(defun claude-org-transclusion-add-or-remove ()
 "Add or remove a transclusion depending on the point.
If the point is on an org-transclusion link, add the transclusion using `org-transclusion-add'.
If the point is on an existing transclusion, remove it using `org-transclusion-remove'."
 (interactive)
 (cond
 ;; Check if the point is on an org-transclusion link
 ((let ((element (org-element-at-point)))
  (when (and (eq (org-element-type element) 'keyword)
     (string= (org-element-property :key element) "TRANSCLUDE"))
  (org-transclusion-add)
  t)))
 ;; Check if the point is on an existing transclusion
 ((org-transclusion-within-transclusion-p)
 (org-transclusion-remove))
 ;; If neither condition is met, display a message
 (t
 (message "Not on an org-transclusion link or transclusion"))))



* English language natural language syntax highlighting
[[https://github.com/istib/wordsmith-mode?tab=readme-ov-file][istib/wordsmith-mode: prose syntax analysis in emacs]]

dependencies: [[https://github.com/stephencelis/syn][stephencelis/syn: Syntax control for the command line]]

#+begin_EXAMPLE emacs-lisp
(use-package wordsmith-mode
  :ensure t
:config
;; Customize faces for wordsmith-mode
 (set-face-attribute 'wordsmith-verb-face nil :inherit 'font-lock-keyword-face)
 (set-face-attribute 'wordsmith-noun-face nil :inherit 'font-lock-constant-face))


;; Define a function to highlight verbs by default
(defun wordsmith-enable-verbs ()
  "Enable wordsmith-mode and highlight verbs."
  (wordsmith-mode 1)
  (wordsmith-highlight-verbs)
  ;; Add a buffer-local hook to reapply highlighting after changes
  (add-hook 'after-change-functions 'wordsmith-highlight-verbs-after-change nil t))

(defun wordsmith-highlight-verbs-after-change (beg end len)
  "Reapply verb highlighting after buffer changes."
  (when wordsmith-mode
    (save-excursion
      ;; Reapply highlighting to the entire buffer
      (wordsmith-highlight-verbs))))

;; Add a hook to enable wordsmith-mode and highlight verbs in org-mode buffers

;; (add-hook 'org-mode-hook 'wordsmith-enable-verbs)
#+END_EXAMPLE



* switch speaker names
#+begin_src emacs-lisp
(defvar speaker-name-1 nil
 "First speaker's name for the switch-speaker-names function.")

(defvar speaker-name-2 nil
 "Second speaker's name for the switch-speaker-names function.")

(defun switch-speaker-names ()
 "Switch between two speaker names in the current line.

On the first invocation in a session, prompts for two speaker names
and stores them for future use. When called, it checks the current
line for either name and replaces it with the other."
 (interactive)
 ;; Prompt for names if they haven't been set yet
 (when (or (not speaker-name-1) (not speaker-name-2))
  (setq speaker-name-1 (read-string "Enter the first speaker's name: "))
  (setq speaker-name-2 (read-string "Enter the second speaker's name: ")))
 ;; Work within the confines of the current line
 (save-excursion
  (let ((line-start (line-beginning-position))
     (line-end (line-end-position)))
   (goto-char line-start)
   (cond
    ((search-forward speaker-name-1 line-end t)
    (replace-match speaker-name-2))
    ((progn
     (goto-char line-start)
     (search-forward speaker-name-2 line-end t))
    (replace-match speaker-name-1))
    (t
    (message "Neither speaker name found in the current line."))))))

(defun switch-speaker-names-in-region (start end)
 "Switch between two speaker names within the selected region.

On the first invocation in a session, prompts for two speaker names
and stores them for future use. When called, it replaces all occurrences
of each speaker's name with the other within the selected region."

 (interactive "r")
 ;; Prompt for names if they haven't been set yet
 (when (or (not speaker-name-1) (not speaker-name-2))
  (setq speaker-name-1 (read-string "Enter the first speaker's name: "))
  (setq speaker-name-2 (read-string "Enter the second speaker's name: ")))
 (let ((temp-placeholder "~~TEMP-SPEAKER-NAME-PLACEHOLDER~~"))
  (save-excursion
   (save-restriction
    (narrow-to-region start end)
    ;; Replace speaker-name-1 with temp-placeholder
    (goto-char (point-min))
    (while (search-forward speaker-name-1 nil t)
     (replace-match temp-placeholder))
    ;; Replace speaker-name-2 with speaker-name-1
    (goto-char (point-min))
    (while (search-forward speaker-name-2 nil t)
     (replace-match speaker-name-1))
    ;; Replace temp-placeholder with speaker-name-2
    (goto-char (point-min))
    (while (search-forward temp-placeholder nil t)
     (replace-match speaker-name-2))))))
#+end_src



* cleanup
#+begin_src emacs-lisp
(defun four-delete-lines-starting-with-four-asterisks ()
 "Delete all lines in the buffer that start with '** '."
 (interactive)
 (goto-char (point-min))
 (while (re-search-forward "^\\*\\*\\*\\*\\* " nil t)
 (delete-region (line-beginning-position) (1+ (line-end-position)))))
#+end_src

#+begin_src emacs-lisp
(defun replace-double-asterisks ()
 "Replace any alphabetical character or closing parenthesis followed by '* ' with the same character followed by '* '."
 (interactive)
 (save-excursion
  (goto-char (point-min))
  (while (re-search-forward "\\([a-zA-Z)]\\)\\*\\* " nil t)
   (replace-match "\\1* "))))
#+end_src


* openwith
#+begin_example emacs-lisp
;; Ensure the package is installed
(unless (package-installed-p 'openwith)
 (package-refresh-contents)
 (package-install 'openwith))

(require 'openwith)

;; Define the file associations
(setq openwith-associations
   (list
    (list (openwith-make-extension-regexp '("docx")) "open" '("-a" "Microsoft Word" file))
    (list (openwith-make-extension-regexp '("pdf")) "open" '("-a" "Preview" file))
    ;; Add more associations as needed
    ))

;; Enable openwith mode
(openwith-mode 1)

;; Avoid conflicts with email attachments
(add-to-list 'mm-inhibit-file-name-handlers 'openwith-file-handler)
#+end_example

