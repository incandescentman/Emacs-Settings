
** Sounds
#+BEGIN_EXAMPLE emacs-lisp
(unless (and (fboundp 'play-sound-internal)
      (subrp (symbol-function 'play-sound-internal)))
  (require 'play-sound))


;; (add-hook 'org-after-todo-state-change-hook 'my-org-after-todo)
;; (defun my-org-after-todo () (play-sound-file "~/sounds/InkSoundStroke3.mp3"))
#+END_EXAMPLE


** Stop mouse cursor from highlighting lines in org-agenda
#+BEGIN_SRC emacs-lisp
(add-hook 'org-finalize-agenda-hook
(lambda () (remove-text-properties
(point-min) (point-max) '(mouse-face t))))
#+END_SRC


** org capture
Make org-capture open in full window! :-)
#+BEGIN_EXAMPLE emacs-lisp
(add-hook 'org-capture-mode-hook 'delete-other-windows)
(add-hook 'org-capture-mode-hook 'writeroom-mode)
#+END_EXAMPLE



* ido
#+BEGIN_EXAMPLE emacs-lisp
(add-hook 'ido-setup-hook
   (lambda ()
     ;; Go straight home
     (define-key ido-file-completion-map
       (kbd "~")
       (lambda ()
  (interactive)
  (if (looking-back "/")
      (insert "~/")
    (call-interactively 'self-insert-command))))))

(use-package ido
:defer
:config
(setq ido-ignore-directories  '("\\`CVS/" "\\`\\.\\./" "\\`\\./" ".git"))
(setq ido-ignore-files  '("\\`CVS/" "\\`#" "\\`.#" "\\`\\.\\./" "\\`\\./" "tex" "html" ".mm" "Icon*" ".git"))

(ido-mode t)

(setq ido-enable-prefix nil
   ido-enable-flex-matching t
   ido-create-new-buffer 'always
   ido-use-filename-at-point 'guess
   ido-use-virtual-buffers t
   ido-handle-duplicate-virtual-buffers 2
   ido-decorations (quote ("{" "}" " | " " | ..." "[" "]" " [No match]" " [Matched]" " [Not so readable bro]" " [Too big yo]" " [Make it so.]"))
   ido-enable-last-directory-history t
ido-enter-matching-directory nil
   ido-use-faces t
   ido-use-url-at-point t
   ido-max-prospects 10)
;; (ido-everywhere t)

(setq confirm-nonexistent-file-or-buffer nil)
;; (ido-everywhere 1)
(setq ido-enable-last-directory-history t)
(setq ido-confirm-unique-completion t) ;; wait for RET, even for unique?
(setq ido-show-dot-for-dired nil) ;; put . as the first item
(setq ido-use-filename-at-point t) ;; prefer file names near point
(setq ido-use-filename-at-point 'guess)
(setq ido-file-extensions-order '(".org" ".txt" ".md" ".emacs" ".el"))

; Use IDO for both buffer and file completion and ~ido-everywhere~ to ~t~:
(setq ido-max-directory-size 100000)
(ido-mode (quote both))


; Use the current window when visiting files and buffers with IDO:
(setq ido-default-file-method 'selected-window)
(setq ido-default-buffer-method 'selected-window)


; Sort ido filelist by mtime instead of alphabetically. Why would anyone want an alphabetically sorted list? You can save keystrokes if the most recently modified files are at the front:
(add-hook 'ido-make-file-list-hook 'ido-sort-mtime)
(add-hook 'ido-make-dir-list-hook 'ido-sort-mtime)
(defun ido-sort-mtime ()
 (setq ido-temp-list
    (sort ido-temp-list
       (lambda (a b)
        (time-less-p
         (sixth (file-attributes (concat ido-current-directory b)))
         (sixth (file-attributes (concat ido-current-directory a)))))))
 (ido-to-end ;; move . files to end (again)
  (delq nil (mapc
       (lambda (x) (and (char-equal (string-to-char x) ?.) x))
       ido-temp-list))))

; Add superior flex matching to ~ido-mode~:
(flx-ido-mode 1)

; disable IDO faces to see flx highlights:
(setq ido-use-faces nil)

(defun ido-bookmark-jump (bname)
 "*Switch to bookmark interactively using `ido'."
 (interactive (list (ido-completing-read "Bookmark: " (bookmark-all-names) nil t)))
 (bookmark-jump bname))

(setq
 ido-ignore-files (quote ("\\`CVS/" "\\`#" "\\`.#" "\\`\\.\\./" "\\`\\./" "html" "*.mm" "Icon*" "*gz" "*ido.hist" "*archive*" "ics")))

(defun ido-goto-symbol (&optional symbol-list)
 "Refresh imenu and jump to a place in the buffer using Ido."
 (interactive)
 (unless (featurep 'imenu)
  (require 'imenu nil t))
 (cond
  ((not symbol-list)
  (let ((ido-mode ido-mode)
     (ido-enable-flex-matching
      (if (boundp 'ido-enable-flex-matching)
        ido-enable-flex-matching t))
     name-and-pos symbol-names position)
   (unless ido-mode
    (ido-mode 1)
    (setq ido-enable-flex-matching t))
   (while (progn
        (imenu--cleanup)
        (setq imenu--index-alist nil)
        (ido-goto-symbol (imenu--make-index-alist))
        (setq selected-symbol
           (ido-completing-read "Symbol? " symbol-names))
        (string= (car imenu--rescan-item) selected-symbol)))
   (unless (and (boundp 'mark-active) mark-active)
    (push-mark nil t nil))
   (setq position (cdr (assoc selected-symbol name-and-pos)))
   (cond
    ((overlayp position)
    (goto-char (overlay-start position)))
    (t
    (goto-char position)))))
  ((listp symbol-list)
  (dolist (symbol symbol-list)
   (let (name position)
    (cond
     ((and (listp symbol) (imenu--subalist-p symbol))
     (ido-goto-symbol symbol))
     ((listp symbol)
     (setq name (car symbol))
     (setq position (cdr symbol)))
     ((stringp symbol)
     (setq name symbol)
     (setq position
        (get-text-property 1 'org-imenu-marker symbol))))
    (unless (or (null position) (null name)
          (string= (car imenu--rescan-item) name))
     (add-to-list 'symbol-names name)
     (add-to-list 'name-and-pos (cons name position))))))))


)


#+END_EXAMPLE

* Fuzzy matching

** imenu
[[http://metasandwich.com/2013/01/19/emacs-config-youre-doing-it-wrong/][link]]

#+BEGIN_EXAMPLE emacs-lisp
(defun imenu-elisp-sections ()
  (setq imenu-prev-index-position-function nil)
  (add-to-list 'imenu-generic-expression '("Sections" "^;;;; \\(.+\\)$" 1) t))

(add-hook 'emacs-lisp-mode-hook 'imenu-elisp-sections)
;; helm-imenu
#+END_EXAMPLE

Jump to a definition in the current file. (This is awesome.)
#+BEGIN_EXAMPLE emacs-lisp
(global-set-key (kbd "C-x C-i") 'ido-imenu)
(defun try-to-add-imenu ()
  (condition-case nil (imenu-add-to-menubar "I love you.") (error nil)))
(add-hook 'font-lock-mode-hook 'try-to-add-imenu)
#+END_EXAMPLE

** Helm
Make helm-grep search recursively by default. I want helm-grep to search not only inside the current folder, but also inside subfolders.

#+BEGIN_EXAMPLE emacs-lisp
(setq helm-M-x-always-save-history t)
(eval-after-load 'helm-grep
  '(setq helm-grep-default-command helm-grep-default-recurse-command))
#+END_EXAMPLE


** Helm
#+BEGIN_EXAMPLE emacs-lisp
(use-package helm-swoop
:defer)
; (global-set-key (kbd "M-i") (lambda() (interactive) (helm-swoop :$query nil)))

(setq helm-swoop-pre-input-function
      (lambda () nil))
#+END_EXAMPLE

When doing isearch, hand the word over to ~helm-swoop~:
#+BEGIN_SRC emacs-lisp
(define-key isearch-mode-map (kbd "M-i") 'helm-swoop-from-isearch)
#+END_SRC

From ~helm-swoop~ to ~helm-multi-swoop-all~:
#+BEGIN_EXAMPLE emacs-lisp
;; (define-key helm-swoop-map (kbd "M-i"); 'helm-multi-swoop-all-from-helm-swoop)
#+END_EXAMPLE

Save buffer when ~helm-multi-swoop-edit~ completes:
#+BEGIN_EXAMPLE emacs-lisp
;; (setq helm-multi-swoop-edit-save t)
#+END_EXAMPLE

If this value is ~t~, split window inside the current window:
#+BEGIN_EXAMPLE emacs-lisp
;; (setq helm-swoop-split-with-multiple-windows nil)
#+END_EXAMPLE

Split direcion. ~split-window-vertically~ or ~split-window-horizontally~:
#+BEGIN_EXAMPLE emacs-lisp
;; (setq helm-swoop-split-direction 'split-window-vertically)
#+END_EXAMPLE

If ~nil~, you can slightly boost invoke speed in exchange for text color:
#+BEGIN_EXAMPLE emacs-lisp
;; (setq helm-swoop-speed-or-color nil)
#+END_EXAMPLE

#+BEGIN_EXAMPLE emacs-lisp
;; (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; rebihnd tab to do persistent action
;; (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action) ; make TAB works in terminal
;; (define-key helm-map (kbd "C-z")  'helm-select-action) ; list actions using C-z
#+END_EXAMPLE

#+BEGIN_EXAMPLE emacs-lisp
;; (global-set-key (kbd "C-x r l") #'helm-filtered-bookmarks)
;; (global-set-key (kbd "M-y")     #'helm-show-kill-ring)
;; (global-set-key (kbd "M-s /")   #'helm-multi-swoop)

(setq helm-ff-transformer-show-only-basename nil
      helm-adaptive-history-file             "~/emacs/.savefile/helm-history"
      helm-yank-symbol-first                 t
      helm-move-to-line-cycle-in-source      t
      helm-buffers-fuzzy-matching            t
      helm-ff-auto-update-initial-value      t)

(autoload 'helm-descbinds      "helm-descbinds" t)
(autoload 'helm-eshell-history "helm-eshell"    t)
(autoload 'helm-esh-pcomplete  "helm-eshell"    t)

(global-set-key (kbd "M-h a")    #'helm-apropos)
(global-set-key (kbd "M-h i")    #'helm-info-emacs)
(global-set-key (kbd "M-h b")    #'helm-descbinds)

(add-hook 'eshell-mode-hook
          #'(lambda ()
              (define-key eshell-mode-map (kbd "TAB")     #'helm-esh-pcomplete)
              (define-key eshell-mode-map (kbd "C-c C-l") #'helm-eshell-history)))


(global-set-key (kbd "C-x c!")   #'helm-calcul-expression)
(global-set-key (kbd "C-x c:")   #'helm-eval-expression-with-eldoc)
(define-key helm-map (kbd "M-o") #'helm-previous-source)

(global-set-key (kbd "M-s s")   #'helm-again)
#+END_EXAMPLE



** helm projectile
#+BEGIN_EXAMPLE emacs-lisp


(setq ad-redefinition-action 'accept)
(use-package helm-projectile
:defer
:config
(setq helm-projectile-sources-list (cons 'helm-source-projectile-files-list
(remove 'helm-source-projectile-files-list helm-projectile-sources-list)))
)

(helm-projectile-on)

(define-key projectile-mode-map (kbd "C-c p /")
  #'(lambda ()
      (interactive)
      (helm-ag (projectile-project-root))))
#+END_EXAMPLE



* helm search current directory
#+BEGIN_EXAMPLE emacs-lisp
(defun helm-do-grep-current-directory-tree ()
  "Recursively search current directory.
If a parent directory has a `dir-locals-file', use that as the
root instead."
  (interactive)
  (let ((variables-file (dir-locals-find-file
                         (or (buffer-file-name) default-directory))))
    (helm-do-grep-1
     (list
      (cond
       ((stringp variables-file)
        (file-name-directory variables-file))
       ((consp variables-file)
        (nth 0 variables-file))
       (t default-directory)))
     t nil '("*"))))
#+END_EXAMPLE



* org-agenda skip keywords
#+BEGIN_SRC emacs-lisp
;; (setq org-agenda-custom-commands '(org-agenda-skip-function 'org-agenda-skip-regexp-if 'todo '("MISSED" "COMMITTED" "RESULTS")))
#+END_SRC

* org-ellipsis
#+BEGIN_SRC emacs-lisp
;; (setq org-ellipsis " ◦◦◦ ")
;; (set-face-attribute org-ellipsis '(((:background "white" :underline nil))))

;; (setq org-ellipsis "⤵")
;; other interesting characters are ▼, ↴, ⬎, ⤷, and ⋱

(setq org-ellipsis "...")
#+END_SRC



** god mode
#+BEGIN_EXAMPLE emacs-lisp
;; (use-package god-mode)
(defun my-update-cursor ()
  (setq cursor-type (if (or god-local-mode buffer-read-only)
                        'bar
                      'box)))

;; (add-hook 'god-mode-enabled-hook 'my-update-cursor)
;; (add-hook 'god-mode-disabled-hook 'my-update-cursor)


             (use-package god-mode-isearch
             :defer)
(define-key isearch-mode-map (kbd "<escape>") 'god-mode-isearch-activate)
(define-key god-mode-isearch-map (kbd "<escape>") 'god-mode-isearch-disable)
(define-key god-local-mode-map (kbd ".") 'repeat)


#+END_EXAMPLE




** org go speed
; Speed commands are really useful, but I often want to make use of
; them when I'm not at the beginning of a header. This command brings
; you back to the beginning of an item's header, so that you can do
; speed commands.

(defun org-go-speed ()
  "Goes to the beginning of an element's header, so that you can
execute speed commands."
  (interactive)
  (when (equal major-mode 'org-mode)
    (if (org-at-heading-p)
        (org-beginning-of-line)
      (org-up-element))))

; bind-key comes from Use Package
(bind-key "C-c s" 'org-go-speed)

(global-set-key "\M-9" 'backward-sexp)
(global-set-key "\M-0" 'forward-sexp)




* convert from org-mode to Word
#+BEGIN_SRC emacs-lisp
;; This setup is tested on Emacs 24.3 & Emacs 24.4 on Linux/OSX
;; org v7 bundled with Emacs 24.3
(setq org-export-odt-preferred-output-format "doc")
;; org v8 bundled with Emacs 24.4
(setq org-odt-preferred-output-format "doc")
;; BTW, you can assign "pdf" in above variables if you prefer PDF format

;; Only OSX need below setup
(defun my-setup-odt-org-convert-process ()
  (interactive)
  (let ((cmd "/Applications/LibreOffice.app/Contents/MacOS/soffice"))
    (when (and (eq system-type 'darwin) (file-exists-p cmd))
      ;; org v7
      (setq org-export-odt-convert-processes '(("LibreOffice" "/Applications/LibreOffice.app/Contents/MacOS/soffice --headless --convert-to %f%x --outdir %d %i")))
      ;; org v8
      (setq org-odt-convert-processes '(("LibreOffice" "/Applications/LibreOffice.app/Contents/MacOS/soffice --headless --convert-to %f%x --outdir %d %i"))))
    ))
(my-setup-odt-org-convert-process)
#+END_SRC

Source: [[http://blog.binchen.org/posts/how-to-take-screen-shot-for-business-people-efficiently-in-emacs.html][How to take screen shot for business people efficiently in Emacs | Chen's blog]]

2.4 Tips

If you need page break in exported document, insert below snippet into the org file:

#+ODT: <text:p text:style-name="PageBreak"/>



* hydras experiments
#+BEGIN_EXAMPLE emacs-lisp
(defhydra email (global-map "s-]")
 "email"
 ("a" erika-send-email)
 ("i" notmuch "inbox")
 ("n" new-email-from-subtree-no-signature "new-email-from-subtree-no-signature")
 ("s" new-email-from-subtree-with-signature "new-email-from-subtree-with-signature")
)


(defhydra hydra-zoom (global-map "s-[")
 "email"
 ("e" erika-send-mail)
 ("n" notmuch)
)


#+END_EXAMPLE

#+BEGIN_EXAMPLE emacs-lisp


(global-set-key
 (kbd "C-p")
(defhydra hydra-move-previous
   (:body-pre (previous-line))
   "move"
("p" previous-line)
("n" next-line)
("k" my/kill-line-dwim)
   ("f" forward-char)
   ("b" backward-char)
   ("a" beginning-of-line)
   ("e" move-end-of-line)
   ("v" scroll-up-command)
   ;; Converting M-v to V here by analogy.
   ("V" scroll-down-command)
   ("l" recenter-top-bottom)))


(global-set-key
 (kbd "C-n")
(defhydra hydra-move-next
   (:body-pre (next-line))
   "move"
   ("n" next-line)
   ("p" previous-line)
   ("k" my/kill-line-dwim)
   ("f" forward-char)
   ("b" backward-char)
   ("a" beginning-of-line)
   ("e" move-end-of-line)
   ("v" scroll-up-command)
   ;; Converting M-v to V here by analogy.
   ("V" scroll-down-command)
   ("l" recenter-top-bottom)))




(global-set-key
 (kbd "s-n")
(defhydra accountability-move
   (:body-pre (next-line))
   "move"
   ("n" org-next-visible-heading)
   ("p" org-previous-visible-heading)
   ("k" org-cut-subtree)
   ("f" forward-char)
   ("b" backward-char)
   ("d" org-todo)
   ("m" (lambda nil (interactive) (org-todo "MISSED")))
   ("e" move-end-of-line)
   ("v" scroll-up-command)
   ;; Converting M-v to V here by analogy.
   ("V" scroll-down-command)
   ("l" recenter-top-bottom)
))



#+END_EXAMPLE

Projectile hydra [[https://github.com/abo-abo/hydra/wiki/Projectile][Projectile - abo-abo/hydra Wiki]]



* hydra helm
#+BEGIN_SRC emacs-lisp
(defhydra hydra-helm (:hint nil :color pink)
 "
           ╭──────┐
   Navigation   Other  Sources     Mark             Do             Help   │ Helm │
  ╭───────────────────────────────────────────────────────────────────────┴──────╯
 ^_k_^         _K_       _p_   [_m_] mark         [_v_] view         [_H_] helm help
 ^^↑^^         ^↑^       ^↑^   [_t_] toggle all   [_d_] delete       [_s_] source help
    _h_ ←   → _l_     _c_       ^ ^   [_u_] unmark all   [_f_] follow: %(helm-attr 'follow)
 ^^↓^^         ^↓^       ^↓^    ^ ^               [_y_] yank selection
 ^_j_^         _J_       _n_    ^ ^               [_w_] toggle windows
--------------------------------------------------------------------------------
 "
 ("<tab>" helm-keyboard-quit "back" :exit t)
 ("<escape>" nil "quit")
 ("\\" (insert "\\") "\\" :color blue)
 ("h" helm-beginning-of-buffer)
 ("j" helm-next-line)
 ("k" helm-previous-line)
 ("l" helm-end-of-buffer)
 ("g" helm-beginning-of-buffer)
 ("G" helm-end-of-buffer)
 ("n" helm-next-source)
 ("p" helm-previous-source)
 ("K" helm-scroll-other-window-down)
 ("J" helm-scroll-other-window)
 ("c" helm-recenter-top-bottom-other-window)
 ("m" helm-toggle-visible-mark)
 ("t" helm-toggle-all-marks)
 ("u" helm-unmark-all)
 ("H" helm-help)
 ("s" helm-buffer-help)
 ("v" helm-execute-persistent-action)
 ("d" helm-persistent-delete-marked)
 ("y" helm-yank-selection)
 ("w" helm-toggle-resplit-and-swap-windows)
 ("f" helm-follow-mode))
#+END_SRC
[[https://github.com/abo-abo/hydra/wiki/Helm-2][Helm 2 - abo-abo/hydra Wiki]]




* re-builder large
#+BEGIN_SRC emacs-lisp

(defun re-builder-large ()
  "Just like `re-builder', only make the font and window larger."
  (interactive)
  (re-builder)
  (text-scale-increase 5)
  (set-window-text-height (selected-window) 7))

#+END_SRC


* reuse directory buffers
#+BEGIN_EXAMPLE emacs-lisp
(load "/Users/jay/emacs/emacs-settings/dired+.el")
(use-package dired+
:defer
 :init
 (progn
  (spacemacs/set-leader-keys
  "ab" 'diredp-do-bookmark)))

(toggle-diredp-find-file-reuse-dir 1)
(add-hook 'dired-mode-hook
 (lambda ()
  (define-key dired-mode-map (kbd "C-<up>")
    (lambda () (interactive) (find-alternate-file "..")))
  ; was dired-up-directory
 ))
#+END_EXAMPLE


* calc eval region
#+BEGIN_SRC emacs-lisp
(defun calc-eval-region (arg)
  "Evaluate an expression in calc and communicate the result.

If the region is active evaluate that, otherwise search backwards
to the first whitespace character to find the beginning of the
expression. By default, replace the expression with its value. If
called with the universal prefix argument, keep the expression
and insert the result into the buffer after it. If called with a
negative prefix argument, just echo the result in the
minibuffer."
  (interactive "p")
  (let (start end)
(if (use-region-p)
    (setq start (region-beginning) end (region-end))
  (progn
    (setq end (point))
    (setq start (search-backward-regexp "\\s-\\|\n" 0 1))
    (setq start (1+ (if start start 0)))
    (goto-char end)))
(let ((value (calc-eval (buffer-substring-no-properties start end))))
  (pcase arg
    (1 (delete-region start end))
    (4 (insert " = ")))
  (pcase arg
    ((or 1 4) (insert value))
    (-1 (message value))))))
#+END_SRC



* Make Messages Buffer modifiable in Emacs 24.4
Chen Bin

Insert below code into the beginning of ~/.emacs because any part of .emacs may create Messages Buffer instance.

#+BEGIN_SRC emacs-lisp
(when (boundp 'messages-buffer-mode-hook)
 (defun messages-buffer-mode-hook-setup ()
 (read-only-mode -1))
 (add-hook 'messages-buffer-mode-hook 'messages-buffer-mode-hook-setup))
#+END_SRC
