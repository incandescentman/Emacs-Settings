# Local Variables:
# enable-local-eval: t
# eval: (org-config-files-local-mode 1)
# End:

;; -*- lexical-binding: t -*-
;;;   Current time:      (current-time-string)
;;;   Last command:      last-command
;;; (abbrev-mode)
;; (user-full-name)



* Intro / About:ARCHIVE:
#+OPTIONS: f:t

#+TITLE:Jay Dixit's Emacs setup - May 22, 2015.

- System: Mac OSX Sierra version 13.1
- Emacs version: Emacs 28.2 (Carbon Version)
- Spacemacs version 0.999.0
- org-mode version 9.6.1
- Use case: I use this file with GNU Emacs for OSX, using Spacemacs.
- If it matters, the build of GNU Emacs that I use is Mitsuharu Yamamoto's Emacs Mac Port, available here:
- =brew tap railwaycat/emacsmacport=
- [[https://github.com/railwaycat/homebrew-emacsmacport][railwaycat/homebrew-emacsmacport: Emacs mac port formulae for the Homebrew package manager]]
- [[https://bitbucket.org/mituharu/emacs-mac/overview][mituharu / emacs-mac - Bitbucket]]

* Package & Load Paths
** Load the proper repositories (package archives)
#+BEGIN_SRC emacs-lisp
;; Set package archives
(setq package-archives
   '(("gnu" . "https://elpa.gnu.org/packages/")
    ("melpa" . "https://melpa.org/packages/")
    ("nongnu" . "https://elpa.nongnu.org/nongnu/")
    ("tromey" . "https://tromey.com/elpa/")))
(package-initialize)
#+END_SRC

** use-package verbosity
#+begin_src emacs-lisp
(setq use-package-verbose nil) ;; Set to t for debugging
#+end_src

** use-package blocks
#+BEGIN_SRC emacs-lisp
(use-package ox-LaTeX
:defer
  )
(use-package ox-html
  :defer)
#+END_SRC

* General Emacs Settings
** Basic variables
*** Setting variables
I should probably eventually break these out of custom-set-variables and organize them according to their function.
#+BEGIN_SRC emacs-lisp
;; -*- lexical-binding: t -*-

;; General Settings
(setq user-full-name "Jay Dixit"
      abbrev-all-caps nil
      blink-cursor-mode nil
      calendar-latitude 40.7
      case-fold-search t
      ccm-recenter-at-end-of-file t
      clean-buffer-list-delay-general 1
      column-number-mode nil
      debug-on-error t
      display-time-mode t
      grep-highlight-matches 'always
      initial-major-mode 'org-mode
      make-backup-files t
      reb-re-syntax 'string
      standard-indent 3
      tooltip-mode nil
      completion-ignored-extensions '(".o" "~" ".bin" ".lbin" ".so" ".a" ".ln"
                                      ".blg" ".bbl" ".elc" ".lof" ".glo" ".idx"
                                      ".lot" ".svn/" ".hg/" ".git/" ".bzr/" "CVS/"
                                      "_darcs/" "_MTN/" ".fmt" ".tfm" ".class"
                                      ".fas" ".lib" ".mem" ".x86f" ".sparcf" ".fasl"
                                      ".ufsl" ".fsl" ".dxl" ".pfsl" ".dfsl" ".p64fsl"
                                      ".d64fsl" ".dx64fsl" ".lo" ".la" ".gmo" ".mo"
                                      ".toc" ".aux" ".cp" ".fn" ".ky" ".pg" ".tp"
                                      ".vr" ".cps" ".fns" ".kys" ".pgs" ".tps"
                                      ".vrs" ".pyc" ".pyo" ".tex" ".mm" "Icon"
                                      ".html" ".zip"))


;; CUA Mode Settings
(setq cua-highlight-region-shift-only t
      cua-mode nil)

;; Deft Settings
(setq deft-directory "~/Dropbox/writing/notationaldata/")


;; Edit Server Settings
(setq edit-server-default-major-mode 'org-mode
      edit-server-new-frame t)

;; Eshell Settings
(setq eshell-load-hook '((lambda () (abbrev-mode -1))))

;; Ido Settings
(setq ido-use-faces t
      ido-use-url-at-point t)

;; Org-Mode Settings
(setq org-M-RET-may-split-line '((item . t))
      org-activate-links '(bracket plain radio tag date footnote)
      org-archive-location "archive/%s_archive::"
      org-ascii-headline-spacing '(1 . 1)
      org-ascii-table-use-ascii-art t
      org-catch-invisible-edits 'smart
      org-ctrl-k-protect-subtree t
      org-custom-properties '(">")
      org-default-notes-file "~/Dropbox/writing/notationaldata/notes.txt"
      org-display-custom-times nil
      org-drawers '("PROPERTIES" "CLOCK" "LOGBOOK" "RESULTS" "SOURCE")
      org-edit-src-content-indentation 4
      org-ellipsis 'org-warning
      org-enforce-todo-checkbox-dependencies t
      org-enforce-todo-dependencies t
      org-extend-today-until 8
      org-fontify-done-headline t
      org-fontify-emphasized-text t
      org-footnote-define-inline t
      org-footnote-section "Footnotes"
      org-footnote-tag-for-non-org-mode-files "Footnotes:"
      org-hide-block-startup nil
      org-hide-emphasis-markers t
      org-html-container-element "div"
      org-html-head-include-scripts nil
      org-html-html5-fancy t
      org-html-postamble nil
      org-html-text-markup-alist '((bold . "<strong>%s</strong>")
                                   (code . "<code>%s</code>")
                                   (italic . "<em>%s</em>")
                                   (strike-through . "<del>%s</del>")
                                   (underline . "<span class=\"underline\">%s</span>")
                                   (verbatim . "<code>%s</code>"))
      org-indent-mode-turns-off-org-adapt-indentation nil
      org-indent-mode-turns-on-hiding-stars nil
      org-insert-mode-line-in-empty-file t
      org-log-done nil
      org-mac-link-skim-highlight-selection-p t
      org-n-level-faces 9
      org-odd-levels-only nil
      org-provide-checkbox-statistics t
      org-replace-disputed-keys nil
      org-special-ctrl-a/e t
      org-src-preserve-indentation t
      org-startup-align-all-tables t
      org-startup-indented t
      org-use-speed-commands t
      org-yank-adjusted-subtrees t
      org2blog/wp-confirm-post nil
      org2blog/wp-default-categories '("inspiration" "personal growth" "miscellany")
      org2blog/wp-keep-new-lines t
      org2blog/wp-show-post-in-browser t
      org2blog/wp-use-tags-as-categories t)

;; OSX Browse Settings
(setq browse-url-browser-function 'browse-url-default-macosx-browser)
(setq osx-browse-prefer-background nil
      osx-browse-prefer-browser "com.google.Chrome"
      osx-browse-prefer-new-window t)

;; Smex Settings
(setq smex-prompt-string "I love you. ")

;; Org Export Settings
(setq org-export-latex-image-default-option "width=20.5cm"
      org-export-time-stamp-file nil
      org-export-with-clocks t
      org-html-head-include-default-style nil
      org-html-toplevel-hlevel 2
      org-indent-indentation-per-level 2
      org-list-allow-alphabetical t
      org-priority-faces nil)

;; Safe Local Variable Values
(setq safe-local-variable-values '((org-export-allow-bind-keywords . t)))

;; Uncomment if needed
;; (setq org-agenda-jump-prefer-future t)
;; (setq org-agenda-skip-scheduled-if-done t)
;; (setq org-agenda-timegrid-use-ampm t)
;; (setq tramp-default-method "ssh")
;; (setq visual-line-mode nil t)
;; (setq org-list-indent-offset 3)
#+END_SRC


** Startup, UI, and appearance


** Appearance
#+begin_src emacs-lisp


(defun adjust-font-size-for-all-frames (&optional frame)
 (interactive)
 (dolist (monitor (display-monitor-attributes-list))
 (dolist (frame (cdr (assoc 'frames monitor)))
  (if (> (frame-pixel-width frame) 2540)
(set-face-attribute 'default frame :font "Monaco" :height 230)
;; (restore-to-two-thirds-size-and-position)

  (set-face-attribute 'default frame :font "Monaco" :height 200)))))

;; The function is also invoked automatically when a new frame is created or when invoked manually.

(add-hook 'after-make-frame-functions 'adjust-font-size-for-all-frames)
(add-hook 'server-after-make-frame-hook 'adjust-font-size-for-all-frames)

;; Additionally, the function is bound to the keyboard shortcut C-x C-\,
;; so it can be quickly invoked without entering M-x.
;; Uncomment the following line to enable this shortcut.
;; (global-set-key (kbd "C-x C-\\") 'adjust-font-size-for-all-frames)

#+end_src

** fontify item checklists
[[https://fuco1.github.io/2017-05-25-Fontify-done-checkbox-items-in-org-mode.html?utm_source=Sacha+Chua+-+Living+an+Awesome+Life&utm_campaign=4942bceb80-RSS_EMAIL_CAMPAIGN&utm_medium=email&utm_term=0_e4be269acf-4942bceb80-97219941][Fontify done checkbox items in org-mode]]

#+BEGIN_SRC emacs-lisp
(font-lock-add-keywords
 'org-mode
 `(("^[ \t]*\\(?:[-+*]\\|[0-9]+[).]\\)[ \t]+\\(\\(?:\\[@\\(?:start:\\)?[0-9]+\\][ \t]*\\)?\\[\\(?:X\\|\\([0-9]+\\)/\\2\\)\\][^\n]*\n\\)" 1 'org-headline-done prepend))
 'append)
#+END_SRC

** Minor modes

* Org-Specific Config
** Basic org settings
** org setup
** Some favorite ~org~ settings:
#+BEGIN_SRC emacs-lisp
  ; (setq org-use-property-inheritance t)
  (setq org-ctrl-k-protect-subtree t)
  (setq org-fontify-quote-and-verse-blocks t)
  ;; blank lines before new headings
  (setq org-blank-before-new-entry
        '((heading . always)
         (plain-list-item . nil)))
  (setq org-return-follows-link t)

  ;; leave an empty line between folded subtrees
  (setq org-cycle-separator-lines 1)

  (setq org-support-shift-select (quote always))

#+END_SRC

** org capture
** org agenda

** org-export
#+BEGIN_SRC emacs-lisp
(setq org-export-with-smart-quotes t)
(setq org-export-exclude-tags (quote ("noexport" "extra")))

;; (setq org-html-head "<link rel='stylesheet' type='text/css' href='/Users/jay/Dropbox/github/incandescentman.github.io/css/neo.css'>")
(setq org-export-time-stamp-file nil)
(setq org-export-with-clocks t)
(setq org-export-with-drawers t)
(setq org-export-with-section-numbers nil)
(setq org-export-with-timestamps (quote active))
(setq org-export-with-toc nil)

 (setq org-export-date-timestamp-format "%Y%m%d %I:%M%p")
 (setq org-export-date-timestamp-format "%B %d, %Y")

 (setq org-export-html-inline-image-extensions (quote ("png" "jpeg" "jpg" "gif" "svg" "tif" "gif")))

;; (setq org-latex-inline-image-rules (quote (("file" . "\\.\\(pdf\\|jpeg\\|gif\\|jpg\\|png\\|ps\\|eps\\|tikz\\|pgf\\|svg\\)\\'"))))

(setq org-latex-default-class "elegant")

(setq org-latex-inline-image-rules '(("file" . "\\.\\(pdf\\|jpeg\\|jpg\\|png\\|ps\\|eps\\|tikz\\|pgf\\|svg\\|gif\\)\\'")))


;; (setq org-export-html-style-include-default t)
 (setq org-export-latex-date-format "%d %B %Y.")
 (setq org-export-latex-emphasis-alist (quote (("*" "\\textit{%s}" nil) ("/" "\\textit{%s}" nil) ("_" "\\underline{%s}" nil) ("+" "\\st{%s}" nil) ("=" "\\verb" t) ("~" "\\verb" t))))
;; (setq org-export-latex-emphasis-alist (quote (("*" "\\emph{%s}" nil) ("/" "\\textit{%s}" nil) ("_" "\\underline{%s}" nil) ("+" "\\st{%s}" nil) ("=" "\\verb" t) ("~" "\\verb" t))))
;; (setq org-export-latex-verbatim-wrap (quote ("\\begin{quote}" . "\\end{quote}")))
 (setq org-export-with-clocks t)
 (setq org-export-with-drawers t)
 (setq org-export-with-section-numbers nil)
(setq org-export-with-planning nil)
(setq org-export-allow-bind-keywords t)
;; (setq org-export-blocks-witheld (quote (hidden)) t)
(setq org-export-date-timestamp-format "%Y%m%d %I:%M%p")
(setq org-export-latex-emphasis-alist (quote    (("*" "\\emph{%s}" nil)
     ("/" "\\textit{%s}" nil)
     ("_" "\\underline{%s}" nil)
     ("+" "\\st{%s}" nil)
     ("=" "\\verb" t)
     ("~" "\\verb" t))))

(setq org-html-footnotes-section
   "<div id=\"footnotes\">
<h2 class=\"footnotes\">%s </h2>
<div id=\"footnote\">
%s
</div>
</div>")

(setq org-latex-text-markup-alist (quote    ((bold . "\\textbf{%s}")
     (code . verb)
     (italic . "\\textit{%s}")
     (strike-through . "\\sout{%s}")
     (underline . "\\uline{%s}")
     ;; (verbatim . protectedtext)
     )))

(setq org-latex-toc-command "\\tableofcontents
\\newpage
")

(setq safe-local-variable-values (quote    ((eval when
    (fboundp
     (quote rainbow-mode))
    (rainbow-mode 1)))))

(setq org-html-footnotes-section "<div id=\"footnotes\">
<h2 class=\"footnotes\">%s </h2>
<div id=\"footnote\">
%s
</div>
</div>")

(setq org-html-head-include-default-style nil)
(setq org-html-head-include-scripts nil)
(setq org-html-html5-fancy t)
(setq org-html-doctype "html5")
(setq org-html-metadata-timestamp-format "%m-%d %a %H:%M")
(setq org-html-postamble nil)
(setq org-html-text-markup-alist
   (quote
    ((bold . "<strong>%s</strong>")
     (code . "<code>%s</code>")
     (italic . "<em>%s</em>")
     (strike-through . "<del>%s</del>")
     (underline . "<span class=\"underline\">%s</span>")
     (verbatim . "<code>%s</code>"))))
(setq org-html-toplevel-hlevel 2)


#+END_SRC



*** org-html-export-to-html-and-open
I don't think there's a direct function for this, but you could achieve what you want using `org-export-to-file`, the last argument of which is a "post-processing" step:

 (org-export-to-file BACKEND FILE &optional ASYNC SUBTREEP VISIBLE-ONLY BODY-ONLY EXT-PLIST POST-PROCESS)

The post-processing step is handed the path to your new file; you could use something as straight-forward as `find-file`:

#+BEGIN_SRC emacs-lisp
  (defun org-html-export-to-html-and-open
   (&optional async subtreep visible-only body-only ext-plist)
   (interactive)
(let* ((outfile (org-export-output-file-name ".html" subtreep)))
    (org-export-to-file 'html outfile async subtreep visible-only body-only ext-plist #'find-file)))
#+END_SRC

*** Change section numbering depending on what export format I use
Turn this on if I'm creating documents that I want to export to both HTML and LaTeX. For now I'm turning it off.

Note: disable this when trying to export to org-html-themes!

#+BEGIN_EXAMPLE emacs-lisp
(defun my-org-export-change-options (plist backend)
  (cond
   ((equal backend 'html)
    (plist-put plist :with-toc nil)
    (plist-put plist :section-numbers nil))
   ((equal backend 'latex)
(plist-put plist :with-toc t) ; yes TOC in LaTeX
;; (plist-put plist :with-toc nil); no TOC in latex
    (plist-put plist :section-numbers t)))
  plist)
(add-to-list 'org-export-filter-options-functions 'my-org-export-change-options)
#+END_EXAMPLE

#+begin_EXAMPLE emacs-lisp
(defun my-org-export-change-options (backend)
  (cond
   ((equal backend 'html)
    (setq org-html-with-toc nil)
    (setq org-html-section-numbers nil))
   ((equal backend 'latex)
    (setq org-latex-with-toc nil)
    (setq org-latex-section-numbers t)))
  nil)

(add-to-list 'org-export-before-processing-hook 'my-org-export-change-options)
#+END_EXAMPLE

#+begin_src emacs-lisp
(defun my-org-export-change-options (plist backend)
 (cond
  ((equal backend 'html)
  (plist-put plist :with-toc nil)
  (plist-put plist :section-numbers nil))
  ((equal backend 'latex)
  (plist-put plist :with-toc nil)
  (plist-put plist :section-numbers t)))
 plist)

;; (add-to-list 'org-export-filter-options-functions 'my-org-export-change-options)

#+end_src

*** export with drawers
#+BEGIN_SRC emacs-lisp
(setq org-export-with-drawers t)
(defun jbd-org-export-format-drawer (name content)
  "Export drawers to drawer HTML class."
  (setq content (org-remove-indentation content))
  (format "@<div class=\"drawer\">%s@</div>\n" content))
(setq org-export-format-drawer-function 'jbd-org-export-format-drawer)

#+END_SRC

*** Omit headlines tagged with :ignore: --- but do still export the text in that section
This is so I can do structure headlines, for myself, that aren't part of the actual article text.

Pretty cool actually. Leaving it in.

#+BEGIN_SRC emacs-lisp
(use-package ox-extra
)
(ox-extras-activate '(ignore-headlines))
#+END_SRC

Works!

*** correct org-mode export
#+BEGIN_SRC emacs-lisp
(defun org-repair-export-blocks ()
 "Repair export blocks and INCLUDE keywords in current buffer."
 (interactive)
 (when (eq major-mode 'org-mode)
  (let ((case-fold-search t)
     (back-end-re (regexp-opt
            '("HTML" "ASCII" "LATEX" "ODT" "MARKDOWN" "MD" "ORG"
             "MAN" "BEAMER" "TEXINFO" "GROFF" "KOMA-LETTER")
            t)))
   (org-with-wide-buffer
    (goto-char (point-min))
    (let ((block-re (concat "^[ \t]*#\\+BEGIN_" back-end-re)))
     (save-excursion
      (while (re-search-forward block-re nil t)
       (let ((element (save-match-data (org-element-at-point))))
        (when (eq (org-element-type element) 'special-block)
         (save-excursion
          (goto-char (org-element-property :end element))
          (save-match-data (search-backward "_"))
          (forward-char)
          (insert "EXPORT")
          (delete-region (point) (line-end-position)))
         (replace-match "EXPORT \\1" nil nil nil 1))))))
    (let ((include-re
       (format "^[ \t]*#\\+INCLUDE: .*?%s[ \t]*$" back-end-re)))
     (while (re-search-forward include-re nil t)
      (let ((element (save-match-data (org-element-at-point))))
       (when (and (eq (org-element-type element) 'keyword)
            (string= (org-element-property :key element) "INCLUDE"))
        (replace-match "EXPORT \\1" nil nil nil 1)))))))))
#+END_SRC

** Flyspell skip source blocks
** Archiving / hooking

* Writing Environment
** Spellcheck / flyspell
** Visual line, auto-fill
** Typographic replacements
** Misc

* Utility Functions
** my/with-advice
** HTML to Org conversions
** copy/cut region to other window
** advanced replacements
** searching
** etc.



* About

* Packages
** lexical binding
#+begin_SRC emacs-lisp
(setq lexical-binding t)
#+end_SRC

** Load some of my packages:
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/emacs/emacs-settings/")
#+END_SRC

** Control use-package verbosity

** some org packages



* The Writing Environment

* Spellcheck / flyspell
** flyspell setup
#+BEGIN_SRC emacs-lisp
;; -*- lexical-binding: t; -*-

(use-package flyspell
  :ensure nil  ;; flyspell is built into Emacs, not an external package
  ;; We don't do :defer t here because :hook already defers loading
  :hook
  ((text-mode . flyspell-mode)
   (org-mode  . flyspell-mode))
  :bind (:map flyspell-mode-map
              ;; Example unbinding of C-.
              ("C-." . nil))
  :config
  ;; 1) Put all your variable settings here with `setq` instead of quoting.
  (setq flyspell-abbrev-p t
        flyspell-use-global-abbrev-table-p t
        flyspell-mark-duplications-exceptions
        '( (nil "that" "had" "really" "very" "much")
           ("\\`francais" "nous" "vous")))
  ;; 2) Configure ispell / Hunspell
  (setq-default ispell-program-name (executable-find "hunspell")
                ispell-dictionary   "en_US-large"
                ispell-personal-dictionary "/Users/jay/Library/Spelling/personal.dic"
                ispell-really-hunspell t)
  (setenv "DICPATH" (concat (getenv "HOME") "/Library/Spelling"))
  (setenv "DICTIONARY" "en_US")

  ;; 3) If you want to skip Org source blocks, define a small helper function
  (defun my-org-setup-flyspell ()
    ;; Ensure we skip code blocks for this buffer
    (when (derived-mode-p 'org-mode)
      (make-local-variable 'ispell-skip-region-alist)
      (add-to-list 'ispell-skip-region-alist
                   '("^#\\+begin_src" . "^#\\+end_src"))))
  (add-hook 'org-mode-hook #'my-org-setup-flyspell)

  ;; 4) If you sometimes need to fix the contractions, do so:
  (defun my/fix-ispell-contraction ()
    "Fix contractions (e.g. shouldn't)."
    (add-to-list 'ispell-dictionary-alist
                 '("en_US" "[[:alpha:]]" "[^[:alpha:]]" "[']"
                   nil ("-d" "en_US") nil utf-8)))
  (my/fix-ispell-contraction))

;; 5) A helper for adding words to your personal dictionary:
(defun add-word-to-personal-dictionary ()
  (interactive)
  (let ((current-location (point))
        (word (flyspell-get-word)))
    (when (consp word)
      (flyspell-do-correct 'save nil
                           (car word)
                           current-location
                           (cadr word)
                           (caddr word)
                           current-location))))

#+END_SRC

* UI / customization of appearance and editing environment
** mouse
*** Stop accidentally highlighting org-mode links all the time:
#+BEGIN_SRC emacs-lisp
(setq mouse-highlight nil)
(setq-local cursor-in-non-selected-windows nil)

#+END_SRC

** disable TAB to indent
#+BEGIN_SRC emacs-lisp
(setq org-cycle-emulate-tab nil)
#+END_SRC

** Windows
:PROPERTIES:
:ID:       B02E7409-F743-4FCB-A1D7-E0F3B65BBD67
:END:
*** Split windows vertically, i.e. using a vertical line to split
Source: [[http://stackoverflow.com/questions/2081577/setting-emacs-split-to-horizontal][Setting Emacs Split to Horizontal - Stack Overflow]]

#+BEGIN_SRC emacs-lisp
;; (setq org-indirect-buffer-display 'current-window)
(setq split-height-threshold nil)
(setq split-width-threshold 0)

(setq split-width-threshold 80) ; Increase this value as needed
(setq split-height-threshold 20) ; Increase this value as needed



(setq split-width-threshold 0)  ; Always split vertically
(setq split-height-threshold nil) ; Prevent horizontal splits
(setq window-min-width 20)    ; Set a minimum width
(setq window-min-height 5)    ; Set a minimum height

#+END_SRC




** quitting emacs
*** Ask before exiting Emacs
#+BEGIN_SRC emacs-lisp
(setq confirm-kill-emacs 'yes-or-no-p)
#+END_SRC

*** System alarms
In some cases, you'd like to reduce the number of warnings or eliminate warnings in certain conditions. The following turns off the alarm bell when you hit C-g in the minibuffer or during an isearch:

#+BEGIN_SRC emacs-lisp

(setq ring-bell-function
      (lambda ()
	(unless (memq this-command
		      '(isearch-abort abort-recursive-edit exit-minibuffer keyboard-quit))
	  (ding))))
#+END_SRC

Also, change the alert sound. Instead of beeping or flashing, Emacs could play a cool sound file, whenever an error occurs:
#+BEGIN_SRC emacs-lisp
;; (setq ring-bell-function (lambda () (play-sound-file "~/sounds/InkSoundStroke3.mp3")))

;; turn off alarms completely
(setq ring-bell-function 'ignore)
#+END_SRC


*** Use visual line mode whenever possible
#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook #'visual-line-mode)
(add-hook 'org-mode-hook  #'visual-line-mode)
#+END_SRC

*** Autofill mode
is this still necessary?

#+BEGIN_SRC emacs-lisp
(auto-fill-mode -1) ; turn off fill mode, which adds random line breaks in my text files:
(add-hook 'text-mode-hook  #'(lambda () (auto-fill-mode -1)))
(add-hook 'markdown-mode-hook  #'(lambda () (auto-fill-mode -1)))
(add-hook 'message-mode-hook  #'(lambda () (auto-fill-mode -1)))
#+END_SRC

*** Disable double spacing between sentences
#+BEGIN_SRC emacs-lisp
(setq-default sentence-end-double-space nil)
#+END_SRC

*** Make typing override text selection
#+BEGIN_SRC emacs-lisp
(delete-selection-mode 1)
#+END_SRC

*** Buffer-save-without-query
#+BEGIN_SRC emacs-lisp
(setq buffer-save-without-query nil)
#+END_SRC

*** Search in Spotlight
#+BEGIN_SRC emacs-lisp
(setq locate-command "mdfind")
#+END_SRC

*** Automatically open files in their correct modes
#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-lisp-mode-hook (lambda () (abbrev-mode -1)))
(add-hook 'css-mode-hook (lambda () (abbrev-mode -1)))
(add-hook 'html-mode-hook (lambda () (abbrev-mode -1)))
(add-hook 'html-helper-mode-hook (lambda () (abbrev-mode -1)))
(add-hook 'eshell-mode-hook (lambda () (abbrev-mode -1)))
(add-hook 'shell-mode-hook (lambda () (abbrev-mode -1)))
(add-hook 'shell-script-mode-hook (lambda () (abbrev-mode -1)))
(add-hook 'term-mode-hook (lambda () (abbrev-mode -1)))
#+END_SRC

*** Typography
**** TODO Replace smart quotes with straight quotes
If `**` is at the beginning of the line and followed by a space, the function should skips the replacement

If the `**` is not at the beginning of a line followed by a space, the function should replaces it with a single `*`.

#+BEGIN_SRC emacs-lisp

(setq smart-quote-regexp-replacements
      '(
        ("\\(\\w\\)- " . "\\1")
        ("\\(\\w\\)\\(  [-—] \\|—\\)" . "\\1---")))


(defun replace-smart-quotes-regexp (beg end)
  "Replace 'smart quotes' in buffer or region with ascii quotes."
  (interactive "r")
  (mapcar
   (lambda (r)
     (save-excursion
       (replace-regexp (car r) (cdr r) nil beg (min end (point-max)))))
   smart-quote-regexp-replacements))

(defun replace-non-heading-double-asterisks (beg end)
  "Replace '*' with '*' unless '*' is at the beginning of a line followed by a space."
  (interactive "r")
  (save-excursion
    (goto-char beg)
    (while (re-search-forward "\\*\\*" end t)
      (if (and (= (line-beginning-position) (- (point) 2))
               (looking-at " "))
          (forward-char 2) ; Skip this occurrence
        (replace-match "*" t t)))))


(defgroup smart-quotes nil
  "Customization group for smart quote replacements."
  :group 'convenience)

(defcustom smart-quotes-replacement-pairs
  '(("“" . "\"")
    ("”" . "\"")
    ("‘" . "'")
    ("’" . "'")
    ("‚" . "'")
    ("‛" . "'")
    ("„" . "\"")
    ("‟" . "\"")
    ("‹" . "'")
    ("›" . "'")
    ("«" . "\"")
    ("»" . "\"")
    ("–" . "-")
    ("" . "")
    ("" . "")
    ("—" . "---")
    ("…" . "...")
    ("• " . "- ")
    ("•" . "-")
    ("·" . "-")
    ("‧" . "-")
    ("⁃" . "-")
    ("‐" . "-")
    ("‑" . "-")
    ("‒" . "-")
    ("‾" . "-")
    (" " . " ")       ; Non-breaking space
    (" " . " ")       ; Narrow no-break space
    ("\u200B" . "")   ; Zero-width space
    ("\u200C" . "")   ; Zero-width non-joiner
    ("\u200D" . "")   ; Zero-width joiner
    ("\t" . " ")      ; Tab character replaced with a space
    (":**" . ":*")
    ("#####" . "*****")
    ("####" . "****")
    ("###" . "***")
    ("##" . "**")
    ("- \\*\\* TODO" . "*** TODO")
    ("okay" . "OK")
    ("  SCHEDULED" . " SCHEDULED")
    ("  DEADLINE" . " DEADLINE"))
  "Alist of replacement pairs for `replace-smart-quotes` function."
  :type '(alist :key-type string :value-type string)
  :group 'smart-quotes)

(require 'cl-lib)  ; Ensure cl-lib is loaded for cl-every


(defun replace-smart-quotes (beg end)
  "Replace smart quotes and format text appropriately in the specified region.

The replacements are defined in the `smart-quotes-replacement-pairs` variable."
  (interactive "r")
  ;; Ensure beg <= end
  (when (> beg end)
    (let ((temp beg))
      (setq beg end)
      (setq end temp)))
  ;; Error checking for smart-quotes-replacement-pairs
  (unless (and (boundp 'smart-quotes-replacement-pairs)
               (listp smart-quotes-replacement-pairs)
               (cl-every (lambda (pair)
                           (and (consp pair)
                                (stringp (car pair))
                                (stringp (cdr pair))))
                         smart-quotes-replacement-pairs))
    (error "Invalid `smart-quotes-replacement-pairs` format; must be a list of string pairs"))
  ;; Convert end into a marker that adjusts with buffer changes
  (let ((end-marker (copy-marker end)))
    (save-excursion
      ;; Replace '*' with '*' unless '*' is at the beginning of a line followed by a space
      (goto-char beg)
      (while (re-search-forward "\\*\\*" end-marker t)
        (if (and (= (line-beginning-position) (- (point) 2))
                 (looking-at " "))
            (forward-char 1) ; Skip this occurrence
          (replace-match "*" t t)))
      ;; Remove lines that contain only '---' (possibly with surrounding spaces)
      (goto-char beg)
      (while (re-search-forward "^\\s-*---\\s-*$" end-marker t)
        (replace-match "" t t))
      ;; Remove space before "-" at the beginning of lines
      (goto-char beg)
      (while (re-search-forward "^\\(\\s-*\\) -" end-marker t)
        (replace-match "\\1-" nil nil))
      ;; Perform replacements using the external `smart-quotes-replacement-pairs`
      (dolist (pair smart-quotes-replacement-pairs)
        (goto-char beg)
        (while (re-search-forward (regexp-quote (car pair)) end-marker t)
          (replace-match (cdr pair) t t))))))


#+END_SRC

**** Paste and replace quotes
Haven't used this next one:
#+BEGIN_SRC emacs-lisp
(defun paste-and-replace-quotes ()
  "Yank (paste) and replace smart quotes from the source with ascii quotes."
  (interactive)
  (clipboard-yank)
  (replace-smart-quotes (mark) (point)))
#+END_SRC

*** Indentation
Automatically indenting yanked text if in programming-modes:
#+BEGIN_SRC emacs-lisp
(defvar yank-indent-modes
  '(LaTeX-mode TeX-mode)
  "Modes in which to indent regions that are yanked (or yank-popped).
Only modes that don't derive from `prog-mode' should be listed here.")

(defvar yank-indent-blacklisted-modes
  '(python-mode slim-mode haml-mode)
  "Modes for which auto-indenting is suppressed.")

(defvar yank-advised-indent-threshold 1000
  "Threshold (# chars) over which indentation does not automatically occur.")

(defun yank-advised-indent-function (beg end)
  "Do indentation, as long as the region isn't too large."
  (if (<= (- end beg) yank-advised-indent-threshold)
      (indent-region beg end nil)))
#+END_SRC

*** Miscellaneous
;; (setq vc-handled-backends ())
;; (remove-hook 'find-file-hooks 'vc-find-file-hook)
(setq vc-handled-backends nil)

*** Color themes
#+BEGIN_SRC emacs-lisp
(add-to-list 'custom-theme-load-path "~/emacs/emacs-settings/sublime-themes-jay/")
#+END_SRC

* My custom functions/settings
** Buffers
*** Buffer-stack
I use buffer-stack to navigate between buffers using ⌘-left and ⌘-right:
#+BEGIN_SRC emacs-lisp
;;(use-package buffer-stack
;; defer)
#+END_SRC

GNU Emacs:
#+BEGIN_SRC emacs-lisp
(global-set-key [(s-right)] 'buffer-stack-down)
(global-set-key [(s-left)] 'buffer-stack-up)
#+END_SRC

Aquamacs:
#+BEGIN_SRC emacs-lisp
(global-set-key [(A-right)] 'buffer-stack-down)
(global-set-key [(A-left)] 'buffer-stack-up)
#+END_SRC

*** Uniqify buffers
#+BEGIN_SRC emacs-lisp
;; meaningful names for buffers with the same name
;; from prelude
;; http://bit.ly/1Woabxz
(use-package uniquify
:defer
:init
(setq uniquify-buffer-name-style 'forward)
(setq uniquify-separator "/")
(setq uniquify-after-kill-buffer-p t) ; rename after killing uniquified
(setq uniquify-ignore-buffers-re "^\\*") ; don't muck with special buffers

:config

; Uniqify new buffers
(defvar new-buffer-count 0)

;; open new buffers without prompting me for a filename global counter to ensure every new buffer will be unique:

(defun new-buffer ()
 (interactive)
 (setq new-buffer-count (+ new-buffer-count 1))
 (switch-to-buffer (concat "buffer" (int-to-string new-buffer-count)))
 (org-mode))


(defun new-lisp-buffer ()
 (interactive)
 (setq new-buffer-count (+ new-buffer-count 1))
 (switch-to-buffer (concat "buffer" (int-to-string new-buffer-count)))
 (emacs-lisp-mode))


)
#+END_SRC

*** new scratch buffer
#+BEGIN_EXAMPLE emacs-lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; multiple scratch buffers                                               ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; uses package "scratch"
(autoload 'scratch "scratch" nil t)
(global-set-key (kbd "s-T") 'scratch)

#+END_EXAMPLE

*** Create new buffer as org-mode subtree in current file
#+BEGIN_SRC emacs-lisp
(defun org-new-scratch-buffer ()
  (interactive)
  (insert "* oh hi there! " (format-time-string "%F %l:%M%P\n\n"))
;; (org-tree-to-indirect-buffer 'current-window)
(org-narrow-to-subtree)

  )
#+END_SRC

*** Disable autocorrect in minibuffer
#+BEGIN_SRC emacs-lisp
(defun conditionally-disable-abbrev ()
  ""
  (if (string-match "smex-" (format "%s" this-command))
      (abbrev-mode -1)))

(add-hook 'minibuffer-setup-hook 'conditionally-disable-abbrev)
(add-hook 'minibuffer-exit-hook (lambda () (abbrev-mode 1)))
(add-hook 'minibuffer-setup-hook (lambda ()
                                   (abbrev-mode -1)))
#+END_SRC

*** Ignore case when reading buffer and file names
#+BEGIN_SRC emacs-lisp
(setq
read-buffer-completion-ignore-case t
read-file-name-completion-ignore-case t)
#+END_SRC

** Reveal in finder
#+BEGIN_SRC emacs-lisp
(use-package reveal-in-finder
  :bind)
#+END_SRC

** cycle-hyphenation-or-toggle-item
#+BEGIN_SRC emacs-lisp
(defun cycle-hyphenation-or-toggle-item ()
  (interactive)
  (if (region-active-p)
      (call-interactively 'org-toggle-item)
    (cycle-hyphenation)))

#+END_SRC

* org-mode

** org custom functions
*** archiving
#+BEGIN_SRC emacs-lisp

(defadvice org-archive-subtree (around my-org-archive-subtree activate)
  (let ((org-archive-location
	 (if (save-excursion (org-back-to-heading)
			     (> (org-outline-level) 1))
	     (concat (car (split-string org-archive-location "::"))
		     "::* "
		     (car (org-get-outline-path)))
	   org-archive-location)))
    ad-do-it))
#+END_SRC

*** org-mode speed commands
#+BEGIN_SRC emacs-lisp
(setq org-use-speed-commands t)
(setq org-speed-commands-user (quote (
; ("k" . org-kill-note-or-show-branches)
                                      ("q" . bh/show-org-agenda)
                                      ("h" . org-agenda-schedule)
                                      ("d" . org-deadline)
                                      ("w" . org-refile)
                                      ("y" . org-archive-subtree-default-with-confirmation)
                                      ("a" . org-archive-subtree)
                                      ("s" . org-schedule)
                                      ("x" . org-mark-subtree)
                                      ("z" . org-add-note)
                                      ("m" . (lambda nil (interactive) (org-todo "MISSED")))

                                      ("A" . org-archive-subtree-default-with-confirmation)
                                      ("N" . org-forward-heading-same-level)
                                      ("P" . org-backward-heading-same-level)
                                      ("J" . org-clock-goto)
                                      ("Z" . ignore))))
#+END_SRC

** latex images
#+BEGIN_SRC emacs-lisp

  (setq org-latex-image-default-width "370pt");; new value just for book export
;; (setq org-latex-image-default-width "180pt") good value, works for QIAGEN for exampl
(setq   org-export-allow-bind-keywords t)
#+END_SRC

** Highlight latex text in org mode
Ben Maughan
Here is a tiny tweak for org-mode. So that inline latex like $y=mx+c$ will appear in a different colour in an org-mode file to help it stand out.

#+BEGIN_SRC emacs-lisp
(setq org-highlight-latex-and-related '(latex))
#+END_SRC

** org-mode key bindings:
#+BEGIN_SRC emacs-lisp
(define-key global-map "\C-cc" 'org-capture)
(global-set-key "\C-cc" 'org-capture)
(global-set-key "\C-cl" 'org-store-link)
(global-set-key "\C-ca" 'org-agenda)
#+END_SRC

** org agenda
*** agenda display settings
#+BEGIN_SRC emacs-lisp
(setq org-agenda-prefix-format
   (quote
    ((agenda . " %?-12t% s")
     (timeline . "  % s")
     (todo . " %i %-12:c")
     (tags . " %i %-12:c")
     (search . " %i %-12:c"))))

;; (setq org-agenda-prefix-format "%t %s")
#+END_SRC

** org settings
#+BEGIN_SRC emacs-lisp
;; (add-hook 'after-init-hook 'org-agenda-list)
(use-package org-inlinetask
  :defer)
;; Overwrite the current window with the agenda
;; (setq org-agenda-window-setup 'current-window)

;; Delete IDs When Cloning
(setq org-clone-delete-id t)

;; start org in folded mode
(setq org-startup-folded nil)

;; allow alphabetical list entries, i.e. "a. this b. that c. another"
(setq org-alphabetical-lists t)

;; fast TODO selection
(setq org-use-fast-todo-selection t)

;; more org settings
(setq org-treat-S-cursor-todo-selection-as-state-change nil)

(setq org-src-fontify-natively t)

;; (add-to-list 'load-path (expand-file-name "~/git/org-mode/lisp"))
#+END_SRC

** org todo keywords
#+BEGIN_SRC emacs-lisp
(setq org-todo-keywords
   '((sequence "TODO" "STARTED" "|" "DONE")
    ;; (sequence "|" "SKIPPING")
(sequence "MISSED" "|" "DONE")
(sequence "MISSED ❌" "|" "DONE")
(sequence "STARTED" "|" "DONE ✅")
(sequence "STARTED 🏁" "|" "DONE ✅")
(sequence "Example:" "|")
    (sequence "NEED TO INVOICE" "INVOICED" "|" "PAID")
    (sequence "|" "CANCELED")
    ;; (sequence "EXPOSURE ACTIVITY" "|")
    ;; (sequence "MSG" "MESSAGE" "|" "CALLED")
    ;; (sequence "COMMITTED" "RESULTS" "|")
    ;; (sequence "WAITING" "DAILIES" "WEEKLIES" "MONTHLIES" "QUARTERLIES" "YEARLIES" "GOALS" "SOMEDAY" "|")
    ;; (sequence "QUESTION" "|" "ANSWERED")
    ;; (sequence "QUESTIONS" "|" "ANSWERS")
(sequence "Original:" "|" "Revised:")
    ;; (sequence "STRATEGY" "|")
    ;; (sequence "TIP" "|")
(sequence "REWARD" "|" "REWARDED")
    ;; (sequence "NOTES" "RESEARCH" "POINT" "NARRATIVE" "ANECDOTE" "WRITING" "|")
    ;; (sequence "PART" "HED" "HEDTK" "|")
    ;; (sequence "IF" "THEN" "|")
    ;; (sequence "COWRITE" "|" "DONE")
(sequence "TO PROCESS" "|" "PROCESSED")
;; (sequence "GOAL" "PLAN" "NOTE" "|" "DONE")
    ))

;; Set todo keyword colors
(setq org-todo-keyword-faces
 '(
   ("PROCESSED" :foreground "LavenderBlush" :background "darkgrey" :weight bold)
   ("NEXT" :background "medium sea green" :foreground "white" :weight bold)
  ("ACTION" :foreground "medium sea green" :weight bold)
  ("WAITING" :background "yellow" :foreground "purple" :weight bold)
  ("EVENT" :background "gray25" :foreground "white" :weight bold)
  ("PROJECT" :background "firebrick" :foreground "white" :weight bold)
  ("STARTED" :background "dodger blue" :foreground "white" :weight bold)
  ("DONE" :background "white" :foreground "black" :weight bold)))

#+END_SRC

**  hl-todo
#+begin_src emacs-lisp
(use-package hl-todo
:defer
; ensure t
:hook (org-mode . hl-todo-mode)
 :config
 (global-hl-todo-mode)
 (setq hl-todo-include-modes '(org-mode))
 (setq hl-todo-keyword-faces
    '(("HOLD" . "#d0bf8f")
     ("TODO" . "#cc9393")
     ("NEXT" . "#dca3a3")
     ("THEM" . "#dc8cc3")
     ("REJECTED" . "Red")
     ("TK" . "Red")
     ("tktk" . "Red")
     ("xyz" . "Red")
     ("tk" . "Red")
     ("tktks" . "Red")
     ("Q" . "Red")
     ("QUESTION" . "Red")
     ("GOAL" . "DarkGreen")
     ("PROG" . "#7cb8bb")
     ("OKAY" . "#7cb8bb")
     ("DONT" . "#5f7f5f")
     ("FAIL" . "#8c5353")
     ("DONE" . "#afd8af")
     ("ADMITTED" . "DarkGreen")
     ("NOTE" . "#d0bf8f")
     ("STARTED" . "#d0bf8f")
     ("HACK" . "#d0bf8f")
     ("FIXME" . "#cc9393")
     ("MAYBE" . "#cc9393")
     ("ACTION" . "#cc9393")
     ("PROJECT" . "#cc9393")
     ("XXX" . "#cc9393")
     ("XXXX" . "#cc9393")
     ("\\?\\?\\?" . "#cc9393"))))
#+end_SRC

** org priorities
Make it so that the command =org-priority-up= goes straight to #A
#+BEGIN_SRC emacs-lisp
(setq org-priority-start-cycle-with-default nil)
#+END_SRC

** Protect org headings from accidental demotion
Don't delete headings unless I specifically say so. So i.e. when I hit delete, don't delete stars, only content.
#+BEGIN_SRC emacs-lisp
(defun new-org-delete-backward-char (N)
  (interactive "p")
  (cond ((region-active-p)
         (delete-region
          (region-beginning)
          (region-end)))
        ((looking-back "^\\*+[ ]*") ;; one or more stars
         (previous-line)
         (end-of-line))

;; this is to "don't delete the hyphen markers for plain-text lists"
;; I didn't like it so I turned it off
; (
; (looking-back "^[ ]*- ")
; (previous-line)
; (end-of-line))
(t
(org-delete-backward-char N)
)))

#+END_SRC

** Org-mode hooks and other org settings
#+BEGIN_SRC emacs-lisp
'(initial-major-mode (quote org-mode))
'(org-replace-disputed-keys t)
'(org-use-extra-keys nil)
'(org-adapt-indentation nil)
'(org-edit-src-content-indentation 4)
'(org-ellipsis (quote org-warning))
'(org-enforce-todo-checkbox-dependencies t)
'(org-enforce-todo-dependencies t)
'(org-html-postamble nil)
'(org-fontify-emphasized-text t)
'(org-src-preserve-indentation t)
'(org-startup-align-all-tables t)
'(org-startup-folded showeverything)
'(org-startup-indented nil)

'(org-indent-mode-turns-off-org-adapt-indentation nil)
'(org-indent-mode-turns-on-hiding-stars nil)
'(org-insert-mode-line-in-empty-file t)
'(org-list-indent-offset 3)
'(org-log-done (quote time))
'(org-n-level-faces 9)
'(org-odd-levels-only nil)
'(org-indent-mode 1)
'(org-priority-faces nil)
'(org-provide-checkbox-statistics t)

(defvar my-org-directory "~/Dropbox/writing/notationaldata/")
(defvar my-org-default-notes-file (concat my-org-directory "notes.txt"))

(setq org-directory my-org-directory)
(setq org-default-notes-file my-org-default-notes-file)

#+END_SRC

** Org refile settings
*** Exclude ~DONE~ state tasks from refile targets:
#+BEGIN_EXAMPLE emacs-lisp
(defun bh/verify-refile-target ()
  "Exclude todo keywords with a done state from refile targets"
  (not (member (nth 2 (org-heading-components)) org-done-keywords)))
(setq org-refile-target-verify-function 'bh/verify-refile-target)
#+END_EXAMPLE

** org-capture setup
#+BEGIN_EXAMPLE emacs-lisp
(setq org-capture-templates
      (quote
       (

        ("L" "Later" checkitem (file+headline "fearless.org" "Later") "\n\n [ ] %?\n\n" :prepend t :kill-buffer t)

        ("n" "note" entry (file org-default-notes-file)
	       "* %? :NOTE:\n%U\n%a\n  %i" :prepend t :kill-buffer t :clock-in t :clock-resume t)

        ("b" "book" entry (file "~/Dropbox/writing/book/book-capture.txt")
	       "\n\n\n\n* %U\n\n%?\n\n\n" :prepend t :kill-buffer t)

	      ("v" "visualness and visual actions" entry (file "visual-actions.txt")
	       "\n\n\n\n*  %? %i\n \n" :prepend t :kill-buffer t)

        ("i" "article ideas" entry (file "article-ideas.txt")
	       "\n\n\n\n* %? %i\n \n" :prepend t :kill-buffer t)

        ("e" "expression" entry (file "expression.txt")
	       "\n\n* %U\n  %i\n %?\n" :prepend t :kill-buffer t)

        ("W" "Wise Mind" entry (file "wisemind.txt")
	       "\n\n* wm%?\n" :prepend t :kill-buffer t)

	      ("h" "historical interest" entry (file "historical-lifestream.txt")
	       "\n\n* %U\n  %i\n %?\n" :prepend t :kill-buffer t)

	      ("P" "pages" entry (file "~/Dropbox/writing/notationaldata/pages.txt")
	       "\n\n\n\n* %U\n\n%?\n\n\n" :prepend t :kill-buffer t)

	      ("s" "storytelling and writing" entry (file "/Users/jay/Dropbox/writing/writing-teacher/writing-teacher-stuff/teaching-writing-and-storytelling.txt")
	       "\n\n\n\n* %U\n\n%?" :prepend t :kill-buffer t)

	      ("F" "Funny" entry (file "~/Dropbox/writing/notationaldata/funny.txt")
	       "\n\n\n\n* %U\n\n%?\n" :prepend t :kill-buffer t)

        ("M" "Memorize" entry
         (file+headline (concat org-directory "org-drill-jays-decks.org")
                        "Vocabulary")
         "* Word :drill:\n%^ \n** Answer \n%^")

("f" "Fitness")
("fw" "Weight" table-line
  (id "7c721aac-eafa-4a42-9354-fbc151402510")
  "| | %U | %^{Weight} | %^{Comment}" :immediate-finish t)

        )))
#+END_EXAMPLE

This is working correctly:

** org custom functions
*** update parent cookie
I think this is to make parent ~DONE~ states automatically update:
#+BEGIN_SRC emacs-lisp
(defun myorg-update-parent-cookie ()
  (when (equal major-mode 'org-mode)
    (save-excursion
      (ignore-errors
	(org-back-to-heading)
	(org-update-parent-todo-statistics)))))

(defadvice org-kill-line (after fix-cookies activate)
  (myorg-update-parent-cookie))

(defadvice kill-whole-line (after fix-cookies activate)
  (myorg-update-parent-cookie))
#+END_SRC

*** checkbox-list-complete
Mark heading done when all checkboxes are checked. See [[http://thread.gmane.org/gmane.emacs.orgmode/42715][here]]. An item consists of a list with checkboxes. When all of the checkboxes are checked, the item should be considered complete and its ~TODO~ state should be automatically changed to ~DONE~. The code below does that. This version is slightly enhanced over the one in the mailing list (see [[http://thread.gmane.org/gmane.emacs.orgmode/42715/focus=42721][here]]) to reset the state back to TODO if a checkbox is unchecked. Note that the code requires that a checkbox statistics cookie (the [/] or [%] thingie in the headline - see the Checkboxes section in the manual) be present in order for it to work. Note also that it is too dumb to figure out whether the item has a ~TODO~ state in the first place: if there is a statistics cookie, a ~TODO~ / ~DONE~ state will be added willy-nilly any time that the statistics cookie is changed.

#+BEGIN_SRC emacs-lisp
(eval-after-load 'org-list
  '(add-hook 'org-checkbox-statistics-hook (function ndk/checkbox-list-complete)))

(defun ndk/checkbox-list-complete ()
  (save-excursion
    (org-back-to-heading t)
    (let ((beg (point)) end)
      (end-of-line)
      (setq end (point))
      (goto-char beg)
      (if (re-search-forward "\\[\\([0-9]*%\\)\\]\\|\\[\\([0-9]*\\)/\\([0-9]*\\)\\]" end t)
          (if (match-end 1)
              (if (equal (match-string 1) "100%")
                  ;; all done - do the state change
                  (org-todo 'done)
                (org-todo 'todo))
            (if (and (> (match-end 2) (match-beginning 2))
                     (equal (match-string 2) (match-string 3)))
                (org-todo 'done)
              (org-todo 'todo)))))))
#+END_SRC

*** org align tables
#+BEGIN_SRC emacs-lisp
(defun my-align-all-tables ()
  (interactive)
  (org-table-map-tables 'org-table-align 'quietly))
#+END_SRC

*** org extract link
#+BEGIN_SRC emacs-lisp
(defun my-org-extract-link ()
  "Extract the link location at point and put it on the killring."
  (interactive)
  (when (org-in-regexp org-bracket-link-regexp 1)
    (kill-new (org-link-unescape (org-match-string-no-properties 1)))))
#+END_SRC

*** org insert link
Insert link with HTML title as default description. When using `org-insert-link' (`C-c C-l') it might be useful to extract contents from HTML <title> tag and use it as a default link description. Here is a way to accomplish this:

#+BEGIN_SRC emacs-lisp
;; (use-package mm-url) ; to include mm-url-decode-entities-string

;; (defun org-insert-link ()
;;   "Insert org link where default description is set to html title."
;;   (interactive)
;;   (let* ((url (read-string "URL: "))
;;          (title (get-html-title-from-url url)))
;;     (org-insert-link nil url title)))

(defun get-html-title-from-url (url)
  "Return content in <title> tag."
  (let (x1 x2 (download-buffer (url-retrieve-synchronously url)))
    (save-excursion
      (set-buffer download-buffer)
      (beginning-of-buffer)
      (setq x1 (search-forward "<title>"))
      (search-forward "</title>")
      (setq x2 (search-backward "<"))
      (mm-url-decode-entities-string (buffer-substring-no-properties x1 x2)))))
#+END_SRC

*** org insert subtask
#+BEGIN_SRC emacs-lisp
(defun my-org-insert-sub-task ()
  (interactive)
  (let ((parent-deadline (org-get-deadline-time nil)))
    (org-goto-sibling)
    (org-insert-todo-subheading t)
    (when parent-deadline
      (org-deadline nil parent-deadline))))
#+END_SRC

*** reschedule agenda items to today with a single command
#+BEGIN_SRC emacs-lisp
(defun org-agenda-reschedule-to-today ()
  (interactive)
  (cl-flet ((org-read-date (&rest rest) (current-time)))
	   (call-interactively 'org-agenda-schedule)))
#+END_SRC

*** org archive done
Source: [[http://stackoverflow.com/questions/6997387/how-to-archive-all-the-done-tasks-using-a-single-command][link]]
#+BEGIN_SRC emacs-lisp
(defun my-org-archive-done-tasks ()
  (interactive)
  (org-map-entries 'org-archive-subtree "/DONE" 'file))
#+END_SRC

** org-levels
#+BEGIN_SRC emacs-lisp
 (defun org-show-level-1 ()
  (interactive)
 (org-content 1))

 (defun org-show-level-2 ()
  (interactive)
 (org-content 2))

 (defun org-show-level-3 ()
  (interactive)
 (org-content 3))

 (defun org-show-level-4 ()
  (interactive)
 (org-content 4))

 (defun org-show-level-5 ()
  (interactive)
 (org-content 5))

 (defun org-show-level-6 ()
  (interactive)
 (org-content 6))

 (defun org-show-level-7 ()
  (interactive)
 (org-content 7))

 (defun org-show-level-8 ()
  (interactive)
 (org-content 8))

 (define-key key-minor-mode-map (kbd "C-s-1") 'org-show-level-1)

 (define-key key-minor-mode-map (kbd "C-s-2") 'org-show-level-2)

 (define-key key-minor-mode-map (kbd "C-s-3") 'org-show-level-3)

 (define-key key-minor-mode-map (kbd "C-s-4") 'org-show-level-4)

 (define-key key-minor-mode-map (kbd "C-s-5") 'org-show-level-5)

 (define-key key-minor-mode-map (kbd "C-s-6") 'org-show-level-6)

 (define-key key-minor-mode-map (kbd "C-s-7") 'org-show-level-7)

 (define-key key-minor-mode-map (kbd "C-s-8") 'org-show-level-8)

(define-key key-minor-mode-map (kbd "C-s-0") 'show-all)
(define-key key-minor-mode-map (kbd "C-s-a") 'show-all)


#+END_SRC


** org-mode inline tasks
#+BEGIN_SRC emacs-lisp
(define-key key-minor-mode-map (kbd "<M-s-return>") 'org-inlinetask-insert-task)
#+END_SRC

** no autorevert
#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode -1)
#+END_SRC

** globally enable palimpsest-mode
#+BEGIN_SRC emacs-lisp
(add-hook 'find-file-hook (lambda () (palimpsest-mode 1)))
#+END_SRC

* org-mode other packages
** org-pomodoro
#+BEGIN_SRC emacs-lisp
;; (setq org-pomodoro-format "Pomodoro: %s")
;; (setq org-pomodoro-killed-sound "~/sounds/autodestructsequencearmed_ep.mp3")
(setq org-pomodoro-length 25)
(setq org-pomodoro-short-break-length 0.5)
(setq org-pomodoro-long-break-length 30)
(setq org-pomodoro-long-break-sound "/Users/jay/Dropbox/audio/sounds/InkSoundStroke3.mp3")
 (setq org-pomodoro-play-ticking-sounds nil)
;; (setq org-pomodoro-short-break-format "Short Break: %s")
(setq org-pomodoro-short-break-sound "/Users/jay/Dropbox/audio/sounds/Metal_Gong-Dianakc-109711828.mp3")

;; (setq org-pomodoro-finished-sound "/Users/jay/Dropbox/audio/sounds/InkSoundStroke3.mp3")

(setq org-pomodoro-finished-sound "/Users/jay/Dropbox/audio/sounds/Horse-Gallop.mp3")

;; (setq org-pomodoro-ticking-sound "~/Music/iTunes/iTunes Media/Music/Unknown Artist/Unknown Album/com.taptanium.thunderstorm.DreamQuest_preview.m4a")


(defun pomodoro-start ()
  (interactive)
(org-todo 'done)
(previous-line)
(condition-case nil
(org-pomodoro)
 (error nil))
)


(add-hook 'org-pomodoro-finished-hook #'(lambda ()

(do-applescript (format "
ignoring application responses
	tell application \"System Events\"
keystroke \"B\" using {command down, shift down, option down, control down} -- start Pomodoro One
key code {118}
end tell
end ignoring


set now to current date
set nowTime to (hours of now) & \":\" & (minutes of now)
set pomodoroStart to (current date) - 25 * minutes
set pStartTime to (hours of pomodoroStart) & \":\" & (minutes of pomodoroStart)
set achieved to text returned of (display dialog \"What did you achieve in this Pomodoro?\" default answer \"\")
set entry_text to \"# Bookwriting:\" & pStartTime & \" - \" & time string of now & \"

\" & achieved & \"

#pomodoro \"

"))
))

#+END_SRC



From this site ([[https://gist.github.com/judismith/3315418][AppleScript to create Day One entry for hours logged in TaskPaper - Based on the AppleScript from Brett Terpstra to log TaskPaper completed tasks to Day One. This script does both]])

do shell script "echo " & (quoted form of archivedTasks) & "|tr -d \"\\t\"|/usr/local/bin/dayone new"


** org-mac-link
#+BEGIN_SRC emacs-lisp
(use-package org-mac-link
:defer
  )
#+END_SRC


* Browsing
** Make URLs in comments/strings clickable
#+BEGIN_SRC emacs-lisp
(add-hook 'find-file-hooks 'goto-address-prog-mode)
#+END_SRC

** Set the default browser
#+BEGIN_SRC emacs-lisp
(setq browse-url-browser-function 'browse-url-default-macosx-browser)
#+END_SRC

** Edit with Emacs
To enable Edit with Emacs in Chrome:
#+BEGIN_SRC emacs-lisp
;; (use-package edit-server)
;; (edit-server-start)
#+END_SRC

* Miscellaneous/unsorted settings
#+BEGIN_SRC emacs-lisp
'(cua-enable-cua-keys (quote shift))
'(cua-highlight-region-shift-only t)
'(cua-mode nil nil (cua-base))
'(send-mail-function (quote sendmail-send-it))
'(shift-select-mode nil)
'(transient-mark-mode t)


'(message-send-mail-function (quote message-send-mail-with-sendmail))
'(mail-send-mail-function (quote message-send-mail-with-sendmail))
'(setq mail-user-agent 'message-user-agent)
'(global-set-key [(A-W)]  'buffer-stack-bury-and-kill)
'(ns-right-command-modifier (quote meta))
'(ns-tool-bar-display-mode (quote both) t)
'(ns-tool-bar-size-mode nil t)
;; '(standard-indent 3)
'(ns-function-modifier (quote meta))
(transient-mark-mode t)
(tooltip-mode -1)
(setq ns-function-modifier 'hyper)
;; open files in an existing frame instead of a new frame
(setq ns-pop-up-frames nil)
#+END_SRC

** Open everything in its right mode; use ~org-mode~ whenever possible
#+BEGIN_SRC emacs-lisp

(setq auto-mode-alist (cons '("\\.txt" . org-mode) auto-mode-alist))
(setq auto-mode-alist (cons '("\\.calca" . org-mode) auto-mode-alist))
(setq auto-mode-alist (cons '("\\.tmode" . text-mode) auto-mode-alist))
(setq auto-mode-alist (cons '("\\.msg" . message-mode) auto-mode-alist))
(add-to-list 'auto-mode-alist '("\\.org\\'" . org-mode))
;; (add-to-list 'auto-mode-alist '("\\.abbrev_defs\\'" . org-mode))
(add-to-list 'auto-mode-alist '("README$" . org-mode))
(add-to-list 'auto-mode-alist '("shared-functions$" . emacs-lisp-mode))
(add-to-list 'auto-mode-alist '("gnu-emacs-startup$" . emacs-lisp-mode))
(add-to-list 'auto-mode-alist '("\\.css$" . css-mode))
(add-to-list 'auto-mode-alist '("\\.rb$" . ruby-mode))
(add-to-list 'auto-mode-alist '("Rakefile$" . ruby-mode))
(add-to-list 'auto-mode-alist '("\\.js\\(on\\)?$" . js2-mode))
(add-to-list 'auto-mode-alist '("\\.xml$" . nxml-mode))
(add-to-list 'auto-mode-alist '("\\.fountain$" . fountain-mode))
(add-to-list 'auto-mode-alist '("COMMIT_EDITMSG$" . diff-mode))

(add-to-list 'auto-mode-alist '("\\.\\(org\\|org_archive\\|txt\\|txt_archive\\)$" . org-mode))

(setq auto-mode-alist (cons '("\\.md" . org-mode) auto-mode-alist))
(setq auto-mode-alist (cons '("\\.abbrev_defs" . emacs-lisp-mode) auto-mode-alist))
(setq auto-mode-alist (cons '("\\.html" . web-mode) auto-mode-alist))
#+END_SRC

** Enable highlighting of text similar to standard word processors
#+BEGIN_SRC emacs-lisp
'(org-support-shift-select (quote always))
#+END_SRC

** Define my default directory:
#+BEGIN_SRC emacs-lisp
(setq default-directory "~/Dropbox/writing/" )
#+END_SRC

* Backups
Sources: [[http://stackoverflow.com/questions/151945/how-do-i-control-how-emacs-makes-backup-files][How do I control how Emacs makes backup files? - Stack Overflow]]

** Make backups:
#+BEGIN_SRC emacs-lisp
;; Default and per-save backups go here:
(setq backup-directory-alist '(("" . "~/emacs/backup/per-save")))

(setq make-backup-files t        ; backup of a file the first time it is saved.
   backup-by-copying t        ; don't clobber symlinks
   version-control t         ; version numbers for backup files
   delete-old-versions t       ; delete excess backup files silently
   delete-by-moving-to-trash t
   kept-old-versions 6        ; oldest versions to keep when a new numbered backup is made (default: 2)
   kept-new-versions 9        ; newest versions to keep when a new numbered backup is made (default: 2)
   auto-save-default t        ; auto-save every buffer that visits a file
   auto-save-timeout 20       ; number of seconds idle time before auto-save (default: 30)
   auto-save-interval 200      ; number of keystrokes between auto-saves (default: 300)
vc-make-backup-files t ; Make backups of files, even when they're in version control
   )
#+END_SRC

** backing up on every save and backing up versioned files.
#+BEGIN_SRC emacs-lisp

(defun force-backup-of-buffer ()
 ;; Make a special "per session" backup at the first save of each
 ;; emacs session.
 (when (not buffer-backed-up)
  ;; Override the default parameters for per-session backups.
  (let ((backup-directory-alist '(("" . "~/.emacs.d/backup/per-session")))
     (kept-new-versions 3))
   (backup-buffer)))
 ;; Make a "per save" backup on each save. The first save results in
 ;; both a per-session and a per-save backup, to keep the numbering
 ;; of per-save backups consistent.
 (let ((buffer-backed-up nil))
  (backup-buffer)))

(add-hook 'before-save-hook 'force-backup-of-buffer)

#+END_SRC

* ~eshell~
#+BEGIN_SRC emacs-lisp
(setenv "PATH" (shell-command-to-string "source ~/.profile; echo -n $PATH"))
;; (use-package eshell-autojump)
#+END_SRC

* ~ibuffer~
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-b") 'ibuffer)
(autoload 'ibuffer "ibuffer" "List buffers." t)
#+END_SRC

Defines ~ibuffer-do-replace-string~:
#+BEGIN_SRC emacs-lisp
(define-ibuffer-op replace-string (from-str to-str)
  "Perform a `replace-string' in marked buffers."
  (:interactive
   (let* ((from-str (read-from-minibuffer "Replace string: "))
          (to-str (read-from-minibuffer (concat "Replace " from-str
                                                " with: "))))
     (list from-str to-str))
   :opstring "replaced in"
   :complex t
   :modifier-p :maybe)
  (save-window-excursion
    (switch-to-buffer buf)
    (save-excursion
      (goto-char (point-min))
      (let ((case-fold-search ibuffer-case-fold-search))
        (while (search-forward from-str nil t)
          (replace-match to-str nil t))))
    t))
#+END_SRC

* savefile
** file current locations
#+BEGIN_SRC emacs-lisp
(setq ido-save-directory-list-file "~/emacs/.savefile/ido.hist")
(setq projectile-known-projects-file "~/emacs/.savefile/projectile-bookmarks.eld")
#+END_SRC

** recentf
#+BEGIN_SRC emacs-lisp
(use-package recentf
:defer
:config
(setq recentf-save-file "/Users/jay/emacs/recentf/recentf")
(setq recentf-max-menu-items 100)
(setq recentf-max-saved-items 100)
(run-with-idle-timer 60 t 'recentf-save-list) ; save recentf automatically so recent files are stored even in the case of abnormal exit
)
#+END_SRC

* Ignore / Exclude Uninteresting Things
** buffer-stack untrack / ignore uninteresting buffers
#+BEGIN_SRC emacs-lisp
(setq buffer-stack-show-position nil)

(setq buffer-stack-untracked (quote ("KILL" "*Compile-Log*" "*Compile-Log-Show*" "*Group*" "*Completions*" "*Messages*" "*Help*" "*Archive*" "*Agenda*" "*fontification*" "*Warnings*" "Calendar" "*Tree:*" "*spacemacs*" "*scratch*" "*Backtrace*" "todo" "TODO" "*org-roam*")))
;; the above I don't think works or at least I don't know how to add to it


;; The below definitely works.
(defun buffer-stack-filter-regexp (buffer)
  "Non-nil if buffer is in buffer-stack-tracked."
  (not (or (string-match "April\\|Help\\|helpful\\|minibuf\\|echo\\|conversion\\|converting\\|agenda\\|server\\|Messages\\|tex\\|Output\\|autoload\\|Customize\\|address\\|clock\\|Backtrace\\|Completions\\|grep\\|Calendar\\|archive\\|Compile-Log\\|tramp\\|helm\\|Alerts\\|Minibuf\\|Agenda\\|Echo\\|gnugol\\|RNC\\|ediff\\|widget\\|melpa\\|git\\|hydra\\|which\\|fontification\\|Helm\\|popwin\\|Custom\\|Warnings\\|tags\\|hours\\|gnugol\\|guide-key\\|scratch\\|vc\\|Compile\\|mm\\|nntpd\\|spacemacs\\|Gnorb\\|quelpa\\|eldoc\\|tar\\|wordnik\\|escape\\|trace\\|debug\\|emacs\\|Re-Builder\\|Ilist\\|orgmode\\|todo\\|loaddefs\\|gnu\\|elpa\\|version\\|alert\\|counsel\\|consult\\|*info*\\|*affe*\\|pixel\\|org-roam\\|jka\\|123244\\|ediff\\|Org parse" (buffer-name buffer))
     (member buffer buffer-stack-untracked))))
(setq buffer-stack-filter 'buffer-stack-filter-regexp)

#+END_SRC

** recentf-exclude
- [[id:8AB9478C-67B4-4DA5-9329-71DE9C03F595][Escape special characters]]
- Use ~*~ for wildcard? Doesn't seem to be necessary

Make it so that recentf does not record the following uninteresting file types:
#+BEGIN_SRC emacs-lisp
(add-to-list 'recentf-exclude "*Org tags*")
(add-to-list 'recentf-exclude "*emacs-settings*")
(add-to-list 'recentf-exclude "*sent mail*")
(add-to-list 'recentf-exclude "/var/")
(add-to-list 'recentf-exclude "cache")
(add-to-list 'recentf-exclude "Applications")
(add-to-list 'recentf-exclude "Before")
(add-to-list 'recentf-exclude "Calendar")
(add-to-list 'recentf-exclude "LaTeX")
(add-to-list 'recentf-exclude "Shared")
(add-to-list 'recentf-exclude "System")
(add-to-list 'recentf-exclude "\\.Icon")
(add-to-list 'recentf-exclude "\\.avi")
(add-to-list 'recentf-exclude "\\.bmk")
(add-to-list 'recentf-exclude "\\.bmp")
(add-to-list 'recentf-exclude "\\.doc")
(add-to-list 'recentf-exclude "\\.docx")
(add-to-list 'recentf-exclude "\\.emacs.d")
(add-to-list 'recentf-exclude "\\.flv")
(add-to-list 'recentf-exclude "\\.gif")
(add-to-list 'recentf-exclude "\\.git")
(add-to-list 'recentf-exclude "\\.gz")
(add-to-list 'recentf-exclude "\\.html")
(add-to-list 'recentf-exclude "\\.ics")
(add-to-list 'recentf-exclude "\\.jabber")
(add-to-list 'recentf-exclude "\\.jpeg")
(add-to-list 'recentf-exclude "\\.jpg")
(add-to-list 'recentf-exclude "\\.mkv")
(add-to-list 'recentf-exclude "\\.mov")
(add-to-list 'recentf-exclude "\\.mp4")
(add-to-list 'recentf-exclude "\\.mpeg")
(add-to-list 'recentf-exclude "\\.mpg")
(add-to-list 'recentf-exclude "\\.odg")
(add-to-list 'recentf-exclude "\\.odp")
(add-to-list 'recentf-exclude "\\.ods")
(add-to-list 'recentf-exclude "\\.odt")
(add-to-list 'recentf-exclude "\\.ogg")
(add-to-list 'recentf-exclude "\\.ogm")
(add-to-list 'recentf-exclude "\\.pdf")
(add-to-list 'recentf-exclude "\\.png")
(add-to-list 'recentf-exclude "\\.ppt")
(add-to-list 'recentf-exclude "\\.tex")
(add-to-list 'recentf-exclude "\\.tif")
(add-to-list 'recentf-exclude "\\.wav")
(add-to-list 'recentf-exclude "\\.wmv")
(add-to-list 'recentf-exclude "\\.xls")
(add-to-list 'recentf-exclude "\\.xlsx")
(add-to-list 'recentf-exclude "agenda")
(add-to-list 'recentf-exclude "archive")
(add-to-list 'recentf-exclude "bookmark")
(add-to-list 'recentf-exclude "bookmarks")
(add-to-list 'recentf-exclude "cache")
(add-to-list 'recentf-exclude "contacts")
(add-to-list 'recentf-exclude "elpa")
(add-to-list 'recentf-exclude "gnugol")
(add-to-list 'recentf-exclude "helm")
; (add-to-list 'recentf-exclude "ido")
(add-to-list 'recentf-exclude "ido.hist")
(add-to-list 'recentf-exclude "ido.last")
(add-to-list 'recentf-exclude "koma")
(add-to-list 'recentf-exclude "message")
(add-to-list 'recentf-exclude "mu2")
(add-to-list 'recentf-exclude "org-clock-save.el")
(add-to-list 'recentf-exclude "paths")
(add-to-list 'recentf-exclude "persp-auto")
(add-to-list 'recentf-exclude "recent-addresses")
(add-to-list 'recentf-exclude "recentf")
(add-to-list 'recentf-exclude "roam/notes")
(add-to-list 'recentf-exclude "rollback-info")
; (add-to-list 'recentf-exclude "scp")
(add-to-list 'recentf-exclude "shared")
(add-to-list 'recentf-exclude "ssh:")
;; (add-to-list 'recentf-exclude "-hours")
;; (add-to-list 'recentf-exclude "todo")

#+END_SRC

** grep-ignore
#+BEGIN_SRC emacs-lisp
(setq grep-find-ignored-directories
   '("SCCS" "RCS" "CVS" "MCVS" ".svn" ".git" ".hg" ".bzr" "_MTN" "_darcs" "{arch}" "devonthink"))

(setq grep-find-ignored-files
   '(".#*" "*.o" "*~" "*.bin" "*.lbin" "*.so" "*.a" "*.ln" "*.blg" "*.bbl" "*.elc" "*.lof" "*.glo" "*.idx" "*.lot"
    "*.fmt" "*.tfm" "*.class" "*.fas" "*.lib" "*.mem" "*.x86f" "*.sparcf" "*.fasl" "*.ufsl" "*.fsl" "*.dxl" "*.pfsl"
    "*.dfsl" "*.p64fsl" "*.d64fsl" "*.dx64fsl" "*.lo" "*.la" "*.gmo" "*.mo" "*.toc" "*.aux" "*.cp" "*.fn" "*.ky" "*.pg"
    "*.tp" "*.vr" "*.cps" "*.fns" "*.kys" "*.pgs" "*.tps" "*.vrs" "*.pyc" "*.pyo" "*.pdf" "*.tex" "*.html" "*.mm" "*.js"
    "*.doc" "*.pdf" "*.docx" "*.xls" "*.jpg" "*.png" "*.xlsx" "*devonthink*" "*.gif" "#*"))

#+END_SRC

** dired-omit
#+BEGIN_SRC emacs-lisp
(setq dired-omit-files "^\\.[^.]\\|\\.tex$\\|Icon*"

dired-omit-extensions
  (quote
  (".o" "~" ".bin" ".lbin" ".so" ".a" ".ln" ".blg" ".bbl" ".elc" ".lof" ".glo" ".idx" ".lot" ".svn/" ".hg/" ".git/" ".bzr/" "CVS/" "_darcs/" "_MTN/" ".fmt" ".tfm" ".class" ".fas" ".lib" ".mem" ".x86f" ".sparcf" ".dfsl" ".pfsl" ".d64fsl" ".p64fsl" ".lx64fsl" ".lx32fsl" ".dx64fsl" ".dx32fsl" ".fx64fsl" ".fx32fsl" ".sx64fsl" ".sx32fsl" ".wx64fsl" ".wx32fsl" ".fasl" ".ufsl" ".fsl" ".dxl" ".lo" ".la" ".gmo" ".mo" ".toc" ".aux" ".cp" ".fn" ".ky" ".pg" ".tp" ".vr" ".cps" ".fns" ".kys" ".pgs" ".tps" ".vrs" ".pyc" ".pyo" ".idx" ".lof" ".lot" ".glo" ".blg" ".bbl" ".cp" ".cps" ".fn" ".fns" ".ky" ".kys" ".pg" ".pgs" ".tp" ".tps" ".vr" ".vrs" ".html" ".tex" ".git" ".skim" "docx" "mp4" "pptx" "jpeg"))
)


;; (setq dired-omit-files "^\\.[^.]\\|\\.pdf$\\|\\.tex$\\|\\.DS_Store$\\|\\.doc$\\|\\.docx$\\|\\.ini$\\|\\.rtf$\\|\\Icon*\\|\\*.html")

#+END_SRC


* Word count
#+begin_src emacs-lisp
(use-package wc-mode

:config
(add-hook 'org-mode-hook 'wc-mode)

(defun word-count (arg)
(interactive "r")
(count-words arg)
 )

(setq wc-modeline-format "[Words: %tw")

(defun count-characters ()
(interactive)
(setq wc-modeline-format "[Words: %tw, Chars: %tc]")
 )
  )

#+end_src

* web research functions
** Sourcing / Citing / Attributing
*** Copy link from Chrome
#+BEGIN_SRC emacs-lisp
(defun org-mac-link-chrome-insert-frontmost-url-with-quotes ()
  "with quotes"
  (interactive)
  (insert "\"")
  (org-mac-link-chrome-insert-frontmost-url)
  (insert ",\"")
  )
#+END_SRC

** Paste notes with attribution
#+BEGIN_SRC emacs-lisp
(defun web-research ()
  (interactive)
  (insert "#+BEGIN_QUOTE\n")
  (let ((p (point)))
    (insert "\n#+END_QUOTE\nSource: ")
    (org-mac-link-chrome-insert-frontmost-url)
    (goto-char p))
  (pasteboard-paste)
  (next-line)
  (next-line)
  (next-line)
    (insert "\n"))
#+END_SRC

** Paste notes with attribution in quotes
#+BEGIN_SRC emacs-lisp
(defun web-research-quotes ()
  (interactive)
  (insert "\"")
    (org-mac-link-chrome-insert-frontmost-url)
       (insert "\,\" "))
#+END_SRC

** html2org
Aliasing this instead now that I'm putting in on Github
#+begin_src emacs-lisp
(defalias 'html2org-clipboard 'chatgpt2org)
#+end_src

Paste HTML using proper org-mode format
Source: [[http://emacs.stackexchange.com/questions/12121/org-mode-parsing-rich-html-directly-when-pasting][source]]
#+BEGIN_EXAMPLE emacs-lisp
(defun html2org-clipboard ()
 "Convert clipboard contents from HTML to Org, remove base64-encoded images, and then paste (yank)."
 (interactive)
(let* ((cmd "osascript -e 'the clipboard as \"HTML\"' | perl -ne 'print chr foreach unpack(\"C*\",pack(\"H*\",substr($_,11,-3)))' | pandoc -f html -t json | pandoc -f json -t org")
    (org-content (shell-command-to-string cmd)))
  (setq org-content (replace-regexp-in-string "\\[\\[data:image[^]]*\\]\\]" "" org-content :fixedcase :literal))

 (setq org-content (replace-regexp-in-string "^\\[\\[https://chat.openai.com.*$" "" org-content))
 (setq org-content (replace-regexp-in-string "^\\[\\[https://lh3.googleusercontent.*$" "" org-content))
 (setq org-content (replace-regexp-in-string "\\n\\n\\n\\n\\n\\n\\n" "\\n\\n" org-content))
 (setq org-content (replace-regexp-in-string "\\n\\n\\n\\n" "\\n\\n" org-content))
(setq org-content (replace-regexp-in-string "^<<.*\n" "" org-content))
(setq org-content (replace-regexp-in-string "￼" "" org-content))
 (setq org-content (replace-regexp-in-string " " " " org-content))
 (setq org-content (replace-regexp-in-string "\\\\\\\\" "" org-content))
(setq org-content (replace-regexp-in-string ":PROPERTIES:\n\\(.*\n\\)*?:END:" "" org-content))
(setq org-content (replace-regexp-in-string ":PROPERTIES:\\([^\000]*?\\):END:" "" org-content)) ;; somehow leaves stray square brackets in the output

;; Fix the bug
(setq org-content (replace-regexp-in-string "\\(#\\+begin_example\\)\n\\s-*\\([a-zA-Z]*\\)Copy code" "\\1 \\2\n" org-content))

;; Add two line breaks before #+begin for both src and example, and one line break before #+end, and remove leading spaces
  (setq org-content (replace-regexp-in-string "\\(\n\\)?\\s-+\\(#\\+begin_\\(src\\|example\\)\\)" "\n\n\\2" org-content))
  (setq org-content (replace-regexp-in-string "\\(\n\\)?\\s-+\\(#\\+end_\\(src\\|example\\)\\)" "\n\\2" org-content))

;; Add the following line to replace "=" enclosed text with "~" enclosed text
 (setq org-content (replace-regexp-in-string "\\(\\W\\|=\\|^\\)=\\([^=]*\\)=\\(\\W\\|=\\|$\\)" "\\1~\\2~\\3" org-content))

(kill-new org-content)
 (yank)))

#+END_EXAMPLE

** html2org and unfill new version
#+begin_EXAMPLE emacs-lisp
(defun html2org-clipboard-and-unfill-paragraph ()
 "Convert clipboard contents from HTML to Org, remove base64-encoded images, unfill paragraph and then paste (yank)."
 (interactive)
 (html2org-clipboard)
 (let* ((org-content (car kill-ring))) ;; get the most recent item in the kill ring, which is the result of html2org-clipboard

 ;; Unfill paragraph
  (with-temp-buffer
  (insert org-content)
  (goto-char (point-min))
  (while (not (eobp))
   (unfill-paragraph)
   (forward-paragraph))
  (setq org-content (buffer-string)))

  (kill-new org-content)
  (yank)))

#+END_EXAMPLE

** html2org and unfill paragraph. Old version. works
Paste HTML using proper org-mode format
Source: [[http://emacs.stackexchange.com/questions/12121/org-mode-parsing-rich-html-directly-when-pasting][source]]
#+BEGIN_EXAMPLE emacs-lisp
(defun html2org-clipboard-and-unfill-paragraph ()
 "Convert clipboard contents from HTML to Org, remove base64-encoded images, and then paste (yank)."
 (interactive)
(let* ((cmd "osascript -e 'the clipboard as \"HTML\"' | perl -ne 'print chr foreach unpack(\"C*\",pack(\"H*\",substr($_,11,-3)))' | pandoc -f html -t json | pandoc -f json -t org")
    (org-content (shell-command-to-string cmd)))
  (setq org-content (replace-regexp-in-string "\\[\\[data:image[^]]*\\]\\]" "" org-content :fixedcase :literal))

 (setq org-content (replace-regexp-in-string "^\\[\\[https://chat.openai.com.*$" "" org-content))
 (setq org-content (replace-regexp-in-string "^\\[\\[https://lh3.googleusercontent.*$" "" org-content))
 (setq org-content (replace-regexp-in-string "\\n\\n\\n\\n\\n\\n\\n" "\\n\\n" org-content))
 (setq org-content (replace-regexp-in-string "\\n\\n\\n\\n" "\\n\\n" org-content))
(setq org-content (replace-regexp-in-string "^<<.*\n" "" org-content))
(setq org-content (replace-regexp-in-string "￼" "" org-content))
 (setq org-content (replace-regexp-in-string " " " " org-content))
 (setq org-content (replace-regexp-in-string "\\\\\\\\" "" org-content))
(setq org-content (replace-regexp-in-string ":PROPERTIES:\n\\(.*\n\\)*?:END:" "" org-content))
(setq org-content (replace-regexp-in-string ":PROPERTIES:\\([^\000]*?\\):END:" "" org-content)) ;; somehow leaves stray square brackets in the output

;; Add the following line to replace "=" enclosed text with "~" enclosed text
 (setq org-content (replace-regexp-in-string "\\(\\W\\|=\\|^\\)=\\([^=]*\\)=\\(\\W\\|=\\|$\\)" "\\1~\\2~\\3" org-content))


;; Unfill paragraph
  (with-temp-buffer
   (insert org-content)
   (goto-char (point-min))
   (while (not (eobp))
    (unfill-paragraph)
    (forward-paragraph))
   (setq org-content (buffer-string)))

  (kill-new org-content)
  (yank)))

#+END_EXAMPLE

** html2text-clipboard
#+begin_src emacs-lisp
(defun html2text-clipboard ()
 "Convert clipboard contents from HTML to plain text and paste."
 (interactive)
 (setq cmd "osascript -e 'the clipboard as \"HTML\"' | perl -ne 'print chr foreach unpack(\"C*\",pack(\"H*\",substr($_,11,-3)))' | pandoc -f html -t json | pandoc -f json -t plain")
 (kill-new (shell-command-to-string cmd))
 (yank))

#+end_src


* My custom functions for working with dates and times
#+BEGIN_SRC emacs-lisp
(defun jd-org-current-time ()
  "foo"
  (interactive)
(insert (format-time-string "[%H:%M]"))
  )


(defun jd-org-today ()
  "insert a new heading with today's date"
  (interactive)
(smart-org-meta-return-dwim)
  (org-insert-time-stamp (current-time))
(insert "\n")
)


(defun jd-org-approach ()
 "insert a new heading with today's date"
 (interactive)
(insert "\n** ")
 (org-insert-time-stamp (current-time))
(insert "\n")
(insert "*** TODO morning pages\n")
(insert "*** TODO meditate\n")
(insert "*** TODO work on book\n")
(insert "**** TODO pomodoro #1\n")
(insert "**** TODO pomodoro #2\n")
(insert "*** TODO an approach\n")
)


(defun jd-org-today-and-accountability ()
  "insert a new heading with today's date"
  (interactive)
(insert "\n** committed actions: ")
  (org-insert-time-stamp (current-time))
  (insert " [0%]\n")

(insert "*** TODO wake up by 8:30am\n")
(insert "*** TODO blue light\n")

(insert "*** TODO morning pages\n")
(insert "*** TODO bookwriting [0/8]\n")
(insert "**** TODO bookwriting #1\n")
(insert "**** TODO bookwriting #2\n")
(insert "**** TODO bookwriting #3\n")
(insert "**** TODO bookwriting #4\n")
(insert "**** TODO bookwriting #5\n")
(insert "**** TODO bookwriting #6\n")
(insert "**** TODO bookwriting #7\n")
(insert "**** TODO bookwriting #8\n")
(insert "*** TODO ")
; (left-char)
  )


(defun jd-org-2-book-and-accountability ()
 "insert a new heading with today's date"
 (interactive)
(insert "\n** ")
 (org-insert-time-stamp (current-time))
(insert "\n")
(insert "*** TODO bookwriting [0/2]\n")
(insert "**** TODO bookwriting #1\n")
(insert "**** TODO bookwriting #2\n")
(left-char)
 )


(defun jd-org-today-and-book ()
 "insert a new heading with today's date"
 (interactive)
(insert "\n** ")
 (org-insert-time-stamp (current-time))
(insert "\n")
(insert "*** TODO bookwriting\n")
(pomodoro-start)
(pomidor)
 )


(defun org-book-pomodoro ()
 "Insert a new heading with TODO bookwriting and start a pomodoro timer."
 (interactive)

 (insert "*** TODO bookwriting\n")
(pomidor)
 (pomodoro-start))



(defun jd-clock-in ()
 "Insert a new heading with current time and clock in."
 (interactive)
 (org-insert-heading)
 (org-insert-time-stamp (current-time))
 (org-clock-in)
 (next-line 2))





#+END_SRC

* Prose editing settings
** lowercase
#+begin_src emacs-lisp
(defalias 'lowercase-region 'downcase-region)
#+end_src


** Capitalization
*** Intelligently change punctuation of sentences when I change the capitalization
([[http://endlessparentheses.com/super-smart-capitalization.html][source]]):
#+BEGIN_SRC emacs-lisp

#+END_SRC

** Reconfigure shift-select
For prose editing tasks, make m-s-right and m-s-left behave as they do in
traditional word processors, highlighting whole words at a time:
#+BEGIN_SRC emacs-lisp
(defvar lawlist-movement-syntax-table
  (let ((st (make-syntax-table)))
    (modify-syntax-entry ?{ "." st)  ;; { = punctuation
    (modify-syntax-entry ?} "." st)  ;; } = punctuation
    (modify-syntax-entry ?\" "." st) ;; " = punctuation
    (modify-syntax-entry ?\\ "_" st) ;; \ = symbol
    (modify-syntax-entry ?\$ "_" st) ;; $ = symbol
    (modify-syntax-entry ?\% "_" st) ;; % = symbol
    st)
  "Syntax table used while executing custom movement functions.")

(defun lawlist-forward-entity ()
"http://stackoverflow.com/q/18675201/2112489"
(interactive "^")
  (with-syntax-table lawlist-movement-syntax-table
    (cond
      ((eolp)
        (forward-char))
      ((and
          (save-excursion (< 0 (skip-chars-forward " \t")))
          (not (region-active-p)))
        (skip-chars-forward " \t"))
      ((and
          (save-excursion (< 0 (skip-chars-forward " \t")))
          (region-active-p))
        (skip-chars-forward " \t")
        (cond
          ((save-excursion (< 0 (skip-syntax-forward "w")))
            (skip-syntax-forward "w"))
          ((save-excursion (< 0 (skip-syntax-forward ".")))
            (skip-syntax-forward "."))
          ((save-excursion (< 0 (skip-syntax-forward "_()")))
            (skip-syntax-forward "_()"))))
      ((save-excursion (< 0 (skip-syntax-forward "w")))
        (skip-syntax-forward "w")
        (if (and
              (not (region-active-p))
              (save-excursion (< 0 (skip-chars-forward " \t"))))
          (skip-chars-forward " \t")))
      ((save-excursion (< 0 (skip-syntax-forward ".")))
        (skip-syntax-forward ".")
        (if (and
              (not (region-active-p))
              (save-excursion (< 0 (skip-chars-forward " \t"))))
          (skip-chars-forward " \t")))
      ((save-excursion (< 0 (skip-syntax-forward "_()")))
        (skip-syntax-forward "_()")
        (if (and
              (not (region-active-p))
              (save-excursion (< 0 (skip-chars-forward " \t"))))
          (skip-chars-forward " \t"))))))

(defun lawlist-backward-entity ()
"http://stackoverflow.com/q/18675201/2112489"
(interactive "^")
  (with-syntax-table lawlist-movement-syntax-table
    (cond
      ((bolp)
        (backward-char))
      ((save-excursion (> 0 (skip-chars-backward " \t")) (bolp))
        (skip-chars-backward " \t"))
      ((save-excursion (> 0 (skip-chars-backward " \t")) (> 0 (skip-syntax-backward "w")))
        (skip-chars-backward " \t")
        (skip-syntax-backward "w"))
      ((save-excursion (> 0 (skip-syntax-backward "w")))
        (skip-syntax-backward "w"))
      ((save-excursion (> 0 (skip-syntax-backward ".")))
        (skip-syntax-backward "."))
      ((save-excursion (> 0 (skip-chars-backward " \t")) (> 0 (skip-syntax-backward ".")))
        (skip-chars-backward " \t")
        (skip-syntax-backward "."))
      ((save-excursion (> 0 (skip-syntax-backward "_()")))
        (skip-syntax-backward "_()"))
      ((save-excursion (> 0 (skip-chars-backward " \t")) (> 0 (skip-syntax-backward "_()")))
        (skip-chars-backward " \t")
        (skip-syntax-backward "_()")))))

(define-key global-map [M-s-right] 'lawlist-forward-entity)
(define-key global-map [M-s-left] 'lawlist-backward-entity)
#+END_SRC

** Working with windows
Transpose windows, useful:
#+BEGIN_SRC emacs-lisp
(defun transpose-windows (arg)
  "Transpose the buffers shown in two windows."
  (interactive "p")
  (let ((selector (if (>= arg 0) 'next-window 'previous-window)))
    (while (/= arg 0)
      (let ((this-win (window-buffer))
	    (next-win (window-buffer (funcall selector))))
	(set-window-buffer (selected-window) next-win)
	(set-window-buffer (funcall selector) this-win)
	(select-window (funcall selector)))
      (setq arg (if (plusp arg) (1-arg) (1+ arg))))))
#+END_SRC

* move stuff around
** org-refile
#+BEGIN_SRC emacs-lisp
(setq org-outline-path-complete-in-steps nil) ; Refile in a single go
(setq org-completion-use-ido nil)
(setq org-refile-use-outline-path t) ; Show full paths for refiling



(defun my-org-files-list ()
 (delq nil
  (mapc (lambda (buffer)
   (buffer-file-name buffer))
   (org-buffer-list 'files t))))

(setq org-refile-targets '((my-org-files-list :maxlevel . 4)))


;; allow refile to create parent tasks with confirmation:
(setq org-refile-allow-creating-parent-nodes (quote confirm))

; (setq org-goto-interface 'outline-path-completion org-goto-max-level 3)



#+END_SRC

** Refile region
Refile highlighted to a particular heading ([[http://stackoverflow.com/questions/25256304/in-emacs-org-mode-how-to-refile-highlighted-text-under-an-org-heading/25262538?iemail=1&noredirect=1#25262538][Source]]):

#+BEGIN_SRC emacs-lisp
(defvar refile-region-format "\n%s\n")

(defvar refile-region-position 'top
  "Where to refile a region. Use 'bottom to refile at the
end of the subtree. ")

(defun jay-refile-region (beg end copy)
  "Refile the active region.
If no region is active, refile the current paragraph.
With prefix arg C-u, copy region instad of killing it."
  (interactive "r\nP")
  ;; mark paragraph if no region is set
  (unless (use-region-p)
    (setq beg (save-excursion
                (backward-paragraph)
                (skip-chars-forward "\n\t ")
                (point))
          end (save-excursion
                (forward-paragraph)
                (skip-chars-backward "\n\t ")
                (point))))
  (let* ((target (save-excursion (org-refile-get-location)))
         (file (nth 1 target))
         (pos (nth 3 target))
         (text (buffer-substring-no-properties beg end)))
    (unless copy (kill-region beg end))
    (deactivate-mark)
    (with-current-buffer (find-file-noselect file)
      (save-excursion
        (goto-char pos)
        (if (eql refile-region-position 'bottom)
            (org-end-of-subtree)
          (org-end-of-meta-data))
        (insert (format refile-region-format text))))))


#+END_SRC


** move-region-or-subtree-to-other-window
#+BEGIN_SRC emacs-lisp
(defun move-region-or-subtree-to-other-window ()
 (interactive)
 (when (and (eq 'org-mode major-mode)
       (not (region-active-p)))
  (org-mark-subtree))
 (let ((text (buffer-substring (region-beginning) (region-end))))
  (delete-region (region-beginning) (region-end))
  (other-window 1)
  (insert text)))
#+END_SRC

** copy-region
#+begin_src emacs-lisp
(defun copy-region-to-other-window ()
 (interactive)
 (when (region-active-p)
  (let ((text (buffer-substring (region-beginning) (region-end))))
   (other-window 1)
   (insert text)
   (other-window -1))))
#+end_src

* Remove hyperlink
A useful function: remove a hyperlink but leave the link description:

** new
#+begin_src emacs-lisp
(defun remove-link-at-point ()
  "Replace an org link by its description or if empty its address"
 (interactive)
 (if (org-in-regexp org-link-bracket-re 1)
   (save-excursion
    (let ((remove (list (match-beginning 0) (match-end 0)))
       (description
        (if (match-end 2)
          (org-match-string-no-properties 2)
         (org-match-string-no-properties 1))))
     (apply 'delete-region remove)
     (insert description)))))
#+end_src
Source: [[https://emacs.stackexchange.com/questions/10707/in-org-mode-how-to-remove-a-link][in org-mode, how to remove a link? - Emacs Stack Exchange]]

** remove hyperlinks in buffer
#+begin_src emacs-lisp
(defun remove-hyperlinks ()
 "Remove all Org mode style links from the current buffer."
 (interactive)
 (save-excursion
  (goto-char (point-min))
  (while (re-search-forward "\\[\\[\\([^]]+\\)\\]\\[\\([^]]+\\)\\]\\]" nil t)
   (replace-match "\\2"))))


(defun remove-org-links-and-newlines ()
 "Remove all Org mode style links from the current buffer, also removing any newlines from the description."
 (interactive)
 (save-excursion
  (goto-char (point-min))
  (while (re-search-forward "\\[\\[\\([^]]+\\)\\]\\[\\([^]]+\\)\\]\\]" nil t)
   (let ((description (match-string 2)))
    ;; Replace newline characters with a space in the description
    (setq description (replace-regexp-in-string "\n" " " description))
    (replace-match description)))))

#+end_src

* Working with files
** Reopen last closed file, very useful:
#+BEGIN_SRC emacs-lisp
(defun recentf-open-files-compl ()
  (interactive)
  (let* ((all-files recentf-list)
	 (tocpl (mapcar (function
			 (lambda (x) (cons (file-name-nondirectory x) x))) all-files))
	 (prompt (append '("File name: ") tocpl))
	 (fname (completing-read (car prompt) (cdr prompt) nil nil)))
    (find-file (cdr (assoc-string fname tocpl)))))

(global-set-key [(control x)(control r)] 'recentf-open-files-compl)

(defun visit-most-recent-file ()
  "Visits the most recently open file in `recentf-list' that is not already being visited."
  (interactive)
  (let ((buffer-file-name-list
         (mapcar 'file-truename
                 (remove nil (mapcar 'buffer-file-name (buffer-list)))))
        (recent-files-names (delete-dups (mapcar 'file-truename recentf-list)))
        most-recent-filename)
    (dolist (filename recent-files-names)
      (unless (member filename buffer-file-name-list)
        (setq most-recent-filename filename)
        (cl-return)))
    (ignore-errors (find-file most-recent-filename))))

#+END_SRC

** Copy path
Useful for working with files and references:

Add 'filename' to the kill ring *without duplicating it* if it's already there.
#+BEGIN_SRC emacs-lisp


(defun path-copy-path-to-clipboard ()
 "Copy the full current filename and path to the clipboard."
 (interactive)
 (let ((filename (if (equal major-mode 'dired-mode)
           default-directory
          (buffer-file-name))))
  (when (and filename (not (equal filename (car kill-ring))))
   (with-temp-buffer
    (insert filename)
    (clipboard-kill-region (point-min) (point-max)))
   (kill-new filename))
  (when filename
   (message "Copied to clipboard: %s" filename)))
 (push-kill-ring-pasteboard-to-MacOS-clipboard))


(defun path-copy-path-to-clipboard ()
 "Copy the full current filename and path to the clipboard."
 (interactive)
 ;; Define a local variable 'filename' to store the path of the current file or directory.
 (let ((filename (if (equal major-mode 'dired-mode)
           default-directory ; If in 'dired-mode', use the current directory.
          (buffer-file-name)))) ; Otherwise, use the file path of the current buffer.
  ;; Check if 'filename' is non-nil and is not the latest entry in the kill ring.
  (when (and filename (not (equal filename (car kill-ring))))
   ;; Add 'filename' to the kill ring without duplicating it if it's already there.
   (kill-new filename)
   ;; Use a temporary buffer to copy 'filename' to the system clipboard.
   (with-temp-buffer
    (insert filename)
    (clipboard-kill-region (point-min) (point-max))))
  ;; Provide feedback to the user.
  (when filename
   (message "Copied to clipboard: %s" filename)))
 ;; Use custom function to ensure the clipboard content is also in the kill ring.
 (push-kill-ring-pasteboard-to-MacOS-clipboard))

#+END_SRC

** Copy path with quotes
Useful for working with files and references:
#+BEGIN_SRC emacs-lisp
(defun path-copy-path-to-clipboard-with-quotes ()
  "Copy the full current filename and path to the clipboard"
  (interactive)
  (let ((filename (if (equal major-mode 'dired-mode)
                      default-directory
                    (buffer-file-name))))
    (when filename
      (with-temp-buffer
        (insert filename)
        (clipboard-kill-region (point-min) (point-max)))
      (message filename)))
  (push-kill-ring-pasteboard-to-MacOS-clipboard)
)
#+END_SRC

* save some buffers
#+BEGIN_SRC emacs-lisp
(defun jay/save-some-buffers ()
  "Save certain buffers without confirmation based on specific criteria."
  (interactive)
  (save-some-buffers 'no-confirm
    (lambda ()
      (or
       (and buffer-file-name (equal buffer-file-name abbrev-file-name))
       (and buffer-file-name (memq major-mode
                                   '(latex-mode emacs-lisp-mode fundamental-mode
                                                conf-mode markdown-mode js2-mode json-mode
                                                graphviz-dot-mode python-mode text-mode
                                                snippet-mode css-mode xml-mode nxml-mode
                                                fountain-mode nmxml-mode web-mode gitconfig-mode
                                                gitignore-mode sh-mode)))
       (and (or buffer-file-name (buffer-modified-p))
            (derived-mode-p 'org-mode))))))
#+END_SRC

** find-file tricks
[[http://oremacs.com/2015/01/09/ido-find-file-tilde/][tilde in ido-find-file ]]- doesn't work with smex

#+BEGIN_EXAMPLE emacs-lisp
(defun oleh-ido-setup-hook ()
  (define-key ido-file-dir-completion-map "~"
    (lambda ()
      (interactive)
      (ido-set-current-directory "~/")
      (setq ido-exit 'refresh)
      (exit-minibuffer))))

(add-hook 'ido-setup-hook 'oleh-ido-setup-hook)

(defun ido-find-file-jump (dir)
  "Return a command that sends DIR to `ido-find-file'."
  `(lambda ()
     (interactive)
     (ido-set-current-directory ,dir)
     (setq ido-exit 'refresh)
     (exit-minibuffer)))



(defvar oleh-ido-shortcuts
  '(("~/" "~")
    ("~/Dropbox/source/site-lisp/" "!")

    ))

(mapc (lambda (x)
        (setcar x (ido-find-file-jump (car x))))
      oleh-ido-shortcuts)

(defun oleh-ido-setup-hook ()
  (mapc
   (lambda (x)
     (define-key ido-file-dir-completion-map (cadr x) (car x)))
   oleh-ido-shortcuts))

(add-hook 'ido-setup-hook 'oleh-ido-setup-hook)
#+END_EXAMPLE


* Things I want to learn
** Need to add "cleanup buffer safe" here from whattheemacsd.com
#+BEGIN_SRC emacs-lisp

(defun cleanup-buffer-safe ()
 "Perform a bunch of safe operations on the whitespace content of a buffer.
Does not indent buffer, because it is used for a before-save-hook, and that
might be bad."
 (interactive)
 (untabify-buffer)
 (delete-trailing-whitespace)
 (set-buffer-file-coding-system 'utf-8))

(defun cleanup-buffer ()
  "Perform a bunch of operations on the whitespace content of a buffer.
Including indent-buffer, which should not be called automatically on save."
  (interactive)
  (cleanup-buffer-safe)
  (indent-region (point-min) (point-max)))

(global-set-key (kbd "C-c n") 'cleanup-buffer)
#+END_SRC

* Keybindings
Best guide to [[http://www.nongnu.org/emacs-tiny-tools/keybindings/][keybindings]].

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-C-N") 'outline-next-visible-heading)
(global-set-key (kbd "M-C-P") 'outline-previous-visible-heading)
(define-key key-minor-mode-map (kbd "M-C-N") 'outline-next-visible-heading)
(define-key key-minor-mode-map (kbd "M-C-P") 'outline-previous-visible-heading)

(global-set-key (kbd "M-N") 'org-forward-heading-same-level)
(global-set-key (kbd "M-n") 'org-next-visible-heading)
(global-set-key (kbd "M-P") 'org-backward-heading-same-level)
(global-set-key (kbd "M-p") 'org-previous-visible-heading)
(define-key key-minor-mode-map (kbd "M-N") 'org-forward-heading-same-level)
(define-key key-minor-mode-map (kbd "M-P") 'org-backward-heading-same-level)


(define-key key-minor-mode-map (kbd "M-{") 'org-backward-heading-same-level)
(define-key key-minor-mode-map (kbd "M-}") 'org-forward-heading-same-level)
(define-key key-minor-mode-map (kbd "M-[") 'org-backward-heading-same-level)
(define-key key-minor-mode-map (kbd "M-]") 'org-forward-heading-same-level)

(global-set-key (kbd "s-p") 'org-export-dispatch)
(define-key key-minor-mode-map (kbd "s-p") 'org-export-dispatch)

(define-key global-map (kbd "<C-wheel-up>") (lambda ()
                                              (interactive)
                                              (scroll-up-command)))
(define-key global-map (kbd "<C-wheel-down>") (lambda ()
                                               (interactive)
                                               (scroll-down-command)))

(global-set-key "\C-f" 'forward-word)
(global-set-key "\C-b" 'backward-word)

(global-set-key '[(f5)] 'point-stack-push)
(global-set-key '[(f6)] 'point-stack-pop)
(global-set-key '[(f7)] 'point-stack-forward-stack-pop)
(global-set-key '[(f8)] 'search-open-buffers)

(define-key key-minor-mode-map (kbd "<M-S-backspace>") 'backward-kill-sexp)
(define-key key-minor-mode-map (kbd "<M-S-backspace>") 'backward-kill-sexp)
(define-key key-minor-mode-map (kbd "<M-S-backspace>") 'backward-kill-sexp)
(define-key key-minor-mode-map (kbd "<M-S-backspace>") 'backward-kill-sexp)
#+END_SRC

Make ^H delete rather than help:
#+BEGIN_SRC emacs-lisp
;; (global-set-key (kbd "C-h") 'delete-backward-char)
#+END_SRC

Redefine help shortcut:
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-h") 'help-command)
#+END_SRC


** flyspell-correct-space
#+begin_src emacs-lisp
(defun flyspell-auto-correct-word-correct-space ()
  (interactive)
  (when (looking-back " " nil)
    (left-char 1))
  (flyspell-auto-correct-word)
  )

#+end_src

#+BEGIN_SRC emacs-lisp
(global-set-key "\C-ce" 'eval-buffer)
(global-set-key "\C-cr" 'eval-region)
;; (define-key org-mode-map (kbd "`") 'flyspell-auto-correct-word)
(define-key org-mode-map (kbd "`") 'flyspell-auto-correct-word-correct-space)
;; (define-key org-mode-map (kbd "`") 'flyspell-auto-correct-previous-word)
(global-set-key (kbd "s-z") 'undo)
(global-set-key (kbd "s-y") 'redo)
#+END_SRC

** cut-subtree
   :PROPERTIES:
   :ID:       D283A971-F9C3-4683-A419-82F7D9816F72
   :END:

#+BEGIN_SRC emacs-lisp
(define-key key-minor-mode-map (kbd "M-s-k") 'org-cut-subtree)
(define-key key-minor-mode-map (kbd "C-s-k") 'org-cut-subtree)
#+END_SRC

* Searching for things
** isearch
*** isearch settings
#+BEGIN_SRC emacs-lisp
(defun my-isearch-word-at-point ()
  (interactive)
  (call-interactively 'isearch-forward-regexp))

(defun my-isearch-yank-word-hook ()
  (when (equal this-command 'my-isearch-word-at-point)
    (let ((string (concat "\\<"
			  (buffer-substring-no-properties
			   (progn (skip-syntax-backward "w_") (point))
			   (progn (skip-syntax-forward "w_") (point)))
			  "\\>")))
      (if (and isearch-case-fold-search
	       (eq 'not-yanks search-upper-case))
	  (setq string (downcase string)))
      (setq isearch-string string
	    isearch-message
	    (concat isearch-message
		    (mapconcat 'isearch-text-char-description
			       string ""))
	    isearch-yank-flag t)
      (isearch-search-and-update))))

(add-hook 'isearch-mode-hook 'my-isearch-yank-word-hook)

;; (global-set-key "\C-cw" 'my-isearch-word-at-point)
#+END_SRC

*** Position of the Cursor after Searching
Note that when you type ‘C-r’, isearch goes backwards. When you search
backwards, find something, and then end the search, for example by hitting
‘RET’, point is at the beginning of the string you searched. When you search
forwards, point is not necessarily at the end of the string you were searching
for, but only after the last character that you typed – bad usability! That
means that you cannot predict point based on the string you are searching for
(and thinking about). You must predict point based on the numbers of characters
you typed. Here is how to change that in your InitFile, courtesy of
AdrianKubala:

#+BEGIN_SRC emacs-lisp
(add-hook 'isearch-mode-end-hook 'my-goto-match-beginning)

(defun my-goto-match-beginning ()
  (when (and isearch-forward isearch-other-end)
    (goto-char isearch-other-end)))

(defadvice isearch-exit (after my-goto-match-beginning activate)
  "Go to beginning of match."
  (when (and isearch-forward isearch-other-end)
    (goto-char isearch-other-end))
(recenter-top-bottom)
)

(defun isearch-from-buffer-start ()
  (interactive)
  (push-mark)
  (goto-char (point-min))
  (isearch-forward))
#+END_SRC


** projectile
#+BEGIN_SRC emacs-lisp
(use-package projectile
:defer
:config
(setq projectile-completion-system (quote helm))
(setq projectile-enable-caching nil)
;; (setq projectile-globally-ignored-buffers (quote ("docx ")))
(setq projectile-globally-ignored-file-suffixes (quote ("docx " "jpg" "png" "tmp" "tex" "html" "pdf" "pptx" "tmp")))
(setq projectile-globally-ignored-directories
   (quote
    (".idea" ".eunit" ".git" ".hg" ".fslckout" ".bzr" "_darcs" ".tox" ".svn"".tmp" "archived-work" "images" "excel-mindnode-omni" "archive")))


(setq projectile-globally-ignored-files
  (quote
  ("TAGS" ".DS_Store" ".projectile" ".dropbox")))


:bind (:map projectile-mode-map
( "s-o" . nil)
))


#+END_SRC

** isearch

*** isearch arrow keys
  Here's very convenient keys for isearch. Put it in your emacs init.


#+BEGIN_SRC emacs-lisp

(progn
  ;; set arrow keys in isearch. left/right is backward/forward, up/down is history. press Return to exit
;;  (define-key isearch-mode-map (kbd "<up>") 'isearch-ring-retreat )
;; (define-key isearch-mode-map (kbd "<down>") 'isearch-ring-advance )
  (define-key isearch-mode-map (kbd "<tab>") 'isearch-ring-advance )
  (define-key isearch-mode-map (kbd "<S-tab>") 'isearch-repeat-backward) ; single key, useful

;  (define-key isearch-mode-map (kbd "<right>") 'isearch-repeat-forward) ; single key, useful
 )

#+END_SRC


  when in isearch, the arrow keys will:

  → next occurrence.
  ← previous occurrence.
  ↑ previous search term.
  ↓ next search term.
  Enter ↵ exit isearch.

  This way, searching forward/backward is just one single key press, no key combination.

  This is especially useful with a command that searches current word. See: Emacs: isearch Current Word.



** searching

*** swiper
**** ivy
#+BEGIN_SRC emacs-lisp
(use-package ivy


 :config
 (ivy-add-actions t
    '(("W" kill-new "save to kill ring")
     ("I" insert "insert in buffer")))
(define-key ivy-minibuffer-map (kbd "SPC") 'insert-space)
(define-key ivy-minibuffer-map (kbd "s-v") 'pasteboard-paste-no-spaces)
(setq ivy-height 25)
(setq ivy-display-style 'fancy)

)
#+END_SRC

**** swiper
#+BEGIN_SRC emacs-lisp
;; (global-set-key (kbd "C-s") 'swiper)
(setq ivy-re-builders-alist
 '((t . ivy--regex-plus)))

(define-key key-minor-mode-map (kbd "C-7") 'swiper-mc)

#+END_SRC

**** swiper hydra
#+BEGIN_SRC emacs-lisp
(defun ivy-dired-mark (arg)
 (interactive "p")
 (dotimes (_i arg)
  (with-selected-window swiper--window
   (dired-mark 1))
  (ivy-next-line 1)
  (ivy--exhibit)))

(defun ivy-dired-unmark (arg)
 (interactive "p")
 (dotimes (_i arg)
  (with-selected-window swiper--window
   (dired-unmark 1))
  (ivy-next-line 1)
  (ivy--exhibit)))

(defun ivy-replace ()
 (interactive)
 (let ((from (with-selected-window swiper--window
        (move-beginning-of-line nil)
        (when (re-search-forward
            (ivy--regex ivy-text) (line-end-position) t)
         (match-string 0)))))
  (if (null from)
    (user-error "No match")
   (let ((rep (read-string (format "Replace [%s] with: " from))))
    (with-selected-window swiper--window
     (undo-boundary)
     (replace-match rep t t))))))

(defun ivy-undo ()
 (interactive)
 (with-selected-window swiper--window
  (undo)))


(defhydra hydra-ivy (:hint nil
           :color pink)
 "
^^^^^^     ^Actions^  ^Dired^   ^Quit^
^^^^^^--------------------------------------------
^ ^ _l_ ^ ^   _._ repeat  _m_ark   _i_: cancel
_j_ ^✜^ _;_   _r_eplace  _,_ unmark _o_: quit
^ ^ _k_ ^ ^   _u_ndo
"
 ;; arrows
 ("j" ivy-beginning-of-buffer)
 ("k" ivy-next-line)
 ("l" ivy-previous-line)
 (";" ivy-end-of-buffer)
 ;; actions
 ("." hydra-repeat)
 ("r" ivy-replace)
 ("u" ivy-undo)
 ;; dired
 ("m" ivy-dired-mark)
 ("," ivy-dired-unmark)
 ;; exit
 ("o" keyboard-escape-quit :exit t)
 ("i" nil))

(define-key ivy-minibuffer-map (kbd "C-o") 'hydra-ivy/body)

#+END_SRC

** searching

*** Tell isearch that curly apostrophes are the same as straight ones
 Source: [[http://endlessparentheses.com/ispell-and-apostrophes.html][Ispell and Apostrophes in Emacs]]

#+BEGIN_SRC emacs-lisp
 ;;; Tell ispell.el that ’ can be part of a word.
(setq ispell-local-dictionary-alist
      `((nil "[[:alpha:]]" "[^[:alpha:]]"
             "['\x2019]" nil ("-B") nil utf-8)))

;;; Don't send ’ to the subprocess.
(defun endless/replace-apostrophe (args)
  (cons (replace-regexp-in-string
         "’" "'" (car args))
        (cdr args)))
(advice-add #'ispell-send-string :filter-args
            #'endless/replace-apostrophe)

;;; Convert ' back to ’ from the subprocess.
(defun endless/replace-quote (args)
  (if (not (derived-mode-p 'org-mode))
      args
    (cons (replace-regexp-in-string
           "'" "’" (car args))
          (cdr args))))
(advice-add #'ispell-parse-output :filter-args
            #'endless/replace-quote)
#+END_SRC




* these seem to need to go at the end
** Palimpsest - best ever
#+BEGIN_SRC emacs-lisp
;; (use-package palimpsest)
(palimpsest-mode 1)
(define-key org-mode-map (kbd "C-c C-r") 'palimpsest-move-region-to-bottom)
#+END_SRC

C-C C-R to move text to the bottom of the buffer

** Make block quotes appear nicely in buffer, displaying > instead of :
This doesn't seem to be working.

http://thread.gmane.org/gmane.emacs.orgmode/64980/focus=65987
#+BEGIN_SRC emacs-lisp
(font-lock-add-keywords
 'org-mode '(("^\\(:+\\) " 1 (compose-region (match-beginning 1) (match-end 1) ?❱) nil)))
#+END_SRC

* replace word
#+BEGIN_SRC emacs-lisp
(defun replace-word (tosearch toreplace)
  (interactive "sSearch for word: \nsReplace with: ")
  (save-excursion
    (goto-char (point-min))
    (let ((case-fold-search nil)
          (count 0))
      (while (re-search-forward (concat "\\b" tosearch "\\b") nil t)
        (setq count (1+ count))
        (replace-match toreplace 'fixedcase 'literal))
      (message "Replaced %s match(es)" count))))
#+END_SRC



* capitalization
** words to never downcase
#+BEGIN_SRC emacs-lisp
(setq never-downcase-words '("Internet" "Jay" "Dixit" "Monday" "Tuesday" "Wednesday" "Thursday" "Friday" "Saturday" "Sunday" "York" "Canada" "I" "U" "I'm" "I'll" "I've" "I'd" "OK"))
#+END_SRC

** auto-capitalize-predicate
#+BEGIN_SRC emacs-lisp
(setq auto-capitalize-predicate
      (lambda ()
        (and
         (not (org-checkbox-p))
         (save-match-data
           (not (and
;; (org-or-orgalist-p)
                 (looking-back
                 "\\[\\[.*\\]\\][^.\n]*\\.?"))))
         (save-match-data
           (not (looking-back
                 "\\([Ee]\\.g\\|[Uu]\\.S\\|[Uu]\\.K\\|Ph\\.D\\|\\bal\\|Mr\\|Mrs\\|[M]s\\|cf\\|[N]\\.B\\|[U]\\.N\\|[E]\\.R\\|[M]\\.C\\|[Vv]S\\|[Ii]\.e\\|\\.\\.\\)\\.[^.\n]*\\|E.R\\|\!\"[ ]*\\|\?\"[ ]*"
                 (- (point) 20)))))))

#+END_SRC

** words to never upcase (always downcase)
#+BEGIN_SRC emacs-lisp
(setq auto-capitalize-words '("fn" "\bI\b" "setq" "iPhone" "IPad" "nil" "use" "ediff" "btw" "nyc" "file" "http" "provide" "load" "require" "alias" "looking-at" "blockquote" "http" "https" "eBay" "omg" "zk" "http" "https" "looking" "or" "youarehere"))
#+END_SRC

* org-links
** allow org-insert-link to accept mail addresses like 'Name <name@some.address>'?
#+BEGIN_SRC emacs-lisp
(advice-add #'org-remove-angle-brackets :before-until
            (lambda (s) (if (string-prefix-p "mailto:" s) s)))
#+END_SRC
source: [[http://emacs.stackexchange.com/questions/12743/how-to-allow-org-insert-link-to-accept-mail-addresses-like-name-namesome-addr][org mode - How to allow org-insert-link to accept mail addresses like 'Name <name@some.address>'? - Emacs Stack Exchange]]


* update packages
 (run-with-idle-timer 6000 t 'endless/upgrade)

* pop to mark
Handy way of getting back to previous places.

#+BEGIN_SRC emacs-lisp
;(setq set-mark-command-repeat-pop t)
#+END_SRC

* Treat all themes as safe
#+BEGIN_SRC emacs-lisp
(setq custom-safe-themes t)
#+END_SRC


* org-toggle-heading-same-level
#+BEGIN_SRC emacs-lisp
(defun org-toggle-heading-same-level ()
  "Toggles the current line between a non-heading and TODO heading."
  (interactive)
  (let ((is-heading))
    (save-excursion
      (forward-line 0)
      (when (looking-at "^\\*")
        (setq is-heading t)))
    (if is-heading
        (progn
          (org-todo 'none) ; remove TODO
          (org-toggle-heading)) ; remove heading
      (progn
        (org-toggle-heading) ; convert to heading
(org-do-promote)
;        (org-todo 'nextset)
)))) ; add TODO#+END_SRC
#+END_SRC

* org-toggle-todo-heading
#+BEGIN_SRC emacs-lisp
(defun org-toggle-todo-heading ()
  "Toggles the current line between a non-heading and TODO heading."
  (interactive)
  (let ((is-heading))
    (save-excursion
      (forward-line 0)
      (when (looking-at "^\\*")
        (setq is-heading t)))
    (if is-heading
        (progn
          (org-todo 'none) ; remove TODO
          (org-toggle-heading)) ; remove heading
      (progn
        (org-toggle-heading) ; convert to heading
(org-do-promote)
        (org-todo 'nextset))))) ; add TODO#+END_SRC
#+END_SRC

* delete-extra-whitespace-region
#+BEGIN_SRC emacs-lisp
(defun delete-extra-whitespace-region (beg end)
  "replace all whitespace in the region with single spaces"
  (interactive "r")
  (save-excursion
    (save-restriction
      (narrow-to-region beg end)
      (goto-char (point-min))
      (while (re-search-forward "^\\s-+" nil t)
        (replace-match "")))))
#+END_SRC

* double-line-breaks-in-region
#+BEGIN_SRC emacs-lisp
(defun double-line-breaks-in-region (begin end)
  (interactive "r")
  (xah-replace-pairs-region begin end
 '(
 ["\r" "\n\n"]
["\n" "\n\n"]
)))
#+END_SRC

* xah-replace-pairs
(use-package xah-replace-pairs
:defer
)
#+BEGIN_SRC emacs-lisp

(defun xah-convert-entities-to-html-chars-region (begin end)
  (interactive "r")
  (xah-replace-pairs-region begin end
 '(
 ["&" "&amp;"]
 ["<" "&lt;"]
 [">" "&gt;"]
 )))


(defun xah-convert-html-chars-to-entities-region (begin end)
 (interactive "r")
 (xah-replace-pairs-region begin end
 '(
 ["&amp;" "&"]
 ["&lt;" "<"]
 ["&gt;" ">"]
 )))

#+END_SRC

* Monochrome rainbows are the best way to reveal unbalanced delimiters
I rely and paredit and formatting to keep my parenthesis honest, and for the most part that works out great. Occasionally I need to go outside the box. Emacs defaults are terrible for finding unbalanced forms when things go wrong. This setting makes it obvious that there is an error when I have fallen out with my grouping delimiters.

The trick is to not use different colored delimiters! The reason I need the rainbow delimiters package is only to highlight unbalanced delimiters, which it does quickly and accurately. For those cases where I really want to differentiate a group, placing the cursor on the delimiter causes Emacs to highlight the other delimiter.

#+BEGIN_EXAMPLE emacs-lisp
(add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
;; (add-hook 'emacs-lisp-mode-hook 'rainbow-delimiters-mode)
(add-hook 'emacs-lisp-mode-hook #'rainbow-delimiters-mode)
(use-package rainbow-delimiters
:defer)
(set-face-attribute 'rainbow-delimiters-unmatched-face nil
                    :foreground 'unspecified
                    :inherit 'error)
#+END_EXAMPLE


* contract-contractions
#+BEGIN_SRC emacs-lisp

(defun contract-contractions (begin end)
(interactive "r")
  (xah-replace-pairs-region begin end
 '(
 ["I have" "I've"]
["I am" "I'm"]
)))

#+END_SRC

* fix double capitals
Source: [[http://endlessparentheses.com/fixing-double-capitals-as-you-type.html?source%3Drss][Fixing DOuble CApitals as you type · Endless Parentheses]]

#+BEGIN_SRC emacs-lisp
(defun dcaps-to-scaps ()
  "Convert word in DOuble CApitals to Single Capitals."
  (interactive)
  (and (= ?w (char-syntax (char-before)))
       (save-excursion
         (and (if (called-interactively-p)
                  (skip-syntax-backward "w")
                (= -3 (skip-syntax-backward "w")))
              (let (case-fold-search)
                (looking-at "\\b[[:upper:]]\\{2\\}[[:lower:]]"))
              (capitalize-word 1)))))

(add-hook 'post-self-insert-hook #'dcaps-to-scaps nil 'local)

(define-minor-mode dubcaps-mode
  "Toggle `dubcaps-mode'.  Converts words in DOuble CApitals to
Single Capitals as you type."
  :init-value nil
  :lighter (" DC")
  (if dubcaps-mode
      (add-hook 'post-self-insert-hook #'dcaps-to-scaps nil 'local)
    (remove-hook 'post-self-insert-hook #'dcaps-to-scaps 'local)))

#+END_SRC

* yasnippets
** yasnippets
#+BEGIN_SRC emacs-lisp
(defun yas-expand-and-copy-to-clipboard (&optional field)
 "Expand snippet at point and copy the expansion to the clipboard.

Optional argument FIELD is for non-interactive use and is an
object satisfying `yas--field-p' to restrict the expansion to."
 (interactive)
 (let ((yas-triggers-in-field t)
    (yas-fallback-behavior nil))
  (setq field (yas-expand-from-trigger-key field))
  (when field
   (when (eq field t)
    (let ((snippet (car (yas-active-snippets))))
     (setq field (yas--snippet-exit snippet))))
   (gui-select-text (yas--field-start field)
            (yas--field-end field))
   (clipboard-kill-ring-save (yas--field-start field)
                (yas--field-end field)))))
(use-package yasnippet
  :defer t
  :ensure t
  :bind
  (("C-c e" . yas-load-snippet-buffer)
   ("." . insert-period))
  :init
:hook ((org-mode . yas-minor-mode)
         (text-mode . yas-minor-mode))
  :config
  ;; Load yasnippet directories
  (setq yas-snippet-dirs '("~/emacs/interesting-snippets" "~/emacs/snippets"))

  ;; Add hooks
  (add-hook 'yas-before-expand-snippet-hook (lambda () (key-minor-mode nil)))
  (add-hook 'yas-after-exit-snippet-hook (lambda () (key-minor-mode 1)))

  ;; Don't insert random spaces in my prose
  (setq yas-indent-line 'none)

  ;; Take input word including hyphen
  (setq yas/key-syntaxes '("w_" "w_." "^ ")) ; default is '("w" "w_" "w_." "^ ")

  ;; Suppress backquote warnings
  (add-to-list 'warning-suppress-types '(yasnippet backquote-change))
  (defun suppress-backquote-warnings ()
    (interactive)
    (add-to-list 'warning-suppress-types '(yasnippet backquote-change))))

(add-to-list 'warning-suppress-types '(yasnippet backquote-change))

#+END_SRC

** fix yasnippet org-mode conflict
#+BEGIN_SRC emacs-lisp
(defun yas-org-very-safe-expand ()
 "Expand the snippet at point and copy the expansion to the clipboard safely in org-mode."
 (let ((yas-fallback-behavior 'return-nil))
  (yas-expand)))

(add-hook 'org-mode-hook
     (lambda ()
      (make-variable-buffer-local 'yas--trigger-key)
      (setq yas-trigger-key [tab])
      (add-to-list 'org-tab-first-hook 'yas-org-very-safe-expand)
      (define-key yas-keymap [tab] 'yas-next-field)))
#+END_SRC

** create new yasnippet
#+begin_src emacs-lisp
(defun new-yasnippet ()
  "Create a new Org-mode snippet file."
  (interactive)
  (let ((snippet-dir "/Users/jay/emacs/interesting-snippets/org-mode/")
        (snippet-name (read-string "Snippet name: "))
        (snippet-key (read-string "Snippet key: "))
        full-path)

    ;; Construct the full file path
    (setq full-path (concat snippet-dir snippet-name ".yasnippet"))

    ;; Ensure the snippet directory exists
    (unless (file-exists-p snippet-dir)
      (make-directory snippet-dir t))

    ;; Check if the file already exists
    (if (file-exists-p full-path)
        (if (yes-or-no-p "Snippet file already exists. Overwrite? ")
            (create-and-insert-snippet full-path snippet-name snippet-key)
          (message "Snippet creation canceled."))
      (create-and-insert-snippet full-path snippet-name snippet-key))))

(defun create-and-insert-snippet (full-path snippet-name snippet-key)
  "Helper function to create and insert snippet content."
  ;; Create and open the new snippet file
  (find-file full-path)
  ;; Insert the snippet structure
  (insert "# -*- mode: snippet -*-\n")
  (insert "# name: " snippet-name "\n")
  (insert "# key: " snippet-key "\n")
  (insert "# --\n")
  (insert "$0\n"))

(define-key key-minor-mode-map (kbd "s-k y a") 'new-yasnippet)
#+end_src

* tiny-expand
#+BEGIN_SRC emacs-lisp
(use-package tiny
  :defer
:config
(tiny-setup-default)
)
(defun new-week ()
  (interactive)
(tiny-expand "m0\n7|*** committed actions:  <%(date "mon" x)>\n**** TODO \n")
  )

#+END_SRC


* outline mode
#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-lisp-mode-hook
          (lambda ()
            (make-local-variable 'outline-regexp)
            (setq outline-regexp "^;;; ")
            (make-local-variable 'outline-heading-end-regexp)
            (setq outline-heading-end-regexp ":\n")
            (outline-minor-mode 1)
))
#+END_SRC

* poetry
(define-key key-minor-mode-map (kbd "s-}") 'poetry-rhyme-word)


* Treat all new files as modified
#+BEGIN_SRC emacs-lisp
(add-hook 'find-file-hooks 'assume-new-is-modified)
(defun assume-new-is-modified ()
  (when (not (file-exists-p (buffer-file-name)))
    (set-buffer-modified-p t)))
#+END_SRC



* olivetti
#+BEGIN_SRC emacs-lisp
(use-package olivetti
:defer
:config
(setq olivetti-body-width 120)
(unbind-key (kbd "C-c [") olivetti-mode-map)
(unbind-key (kbd "C-c ]") olivetti-mode-map)
(setq org-tags-column 40)
)

(add-hook 'olivetti-mode-hook 'turn-on-visual-line-mode)
(add-hook 'text-mode-hook 'olivetti-mode 1)
;; (add-hook 'org-mode-hook 'olivetti-mode 1)
(add-hook 'message-mode-hook 'olivetti-mode 1 'append)
(add-hook 'emacs-lisp-mode-hook 'olivetti-mode 1)
(add-hook 'css-mode-hook 'olivetti-mode 1)
(add-hook 'Custom-mode-hook 'olivetti-mode 1)
(add-hook 'helpful-mode-hook 'olivetti-mode 1)
(add-hook 'sh-mode-hook 'olivetti-mode 1)
(add-hook 'web-mode-hook 'olivetti-mode 1)
(add-hook 'fundamental-mode-hook 'olivetti-mode 1)
(add-hook 'web-mode-hook 'olivetti-mode 1)
(add-hook 'help-mode-hook 'olivetti-mode 1)
(add-hook 'srecode-template-mode-hook 'olivetti-mode 1)
(add-hook 'srecode-template-mode-hook 'olivetti-mode 1)
(add-hook 'prog-mode-hook 'olivetti-mode 1)
(add-hook 'magit-status-mode-hook 'olivetti-mode 1)
(add-hook 'dired-mode-hook 'olivetti-mode 1)
(add-hook 'Info-mode-hook 'olivetti-mode 1)
(add-hook 'eww-mode-hook 'olivetti-mode 1)
#+END_SRC


* Functions to quickly access config files
#+BEGIN_SRC emacs-lisp
(defun load-shared-functions ()
  (interactive)
(find-file "/Users/jay/emacs/emacs-settings/shared-functions.org"))

(defun load-gnu-startup ()
  (interactive)
(find-file "/Users/jay/emacs/emacs-settings/gnu-emacs-startup.org"))

(defun load-spacecraft-mode ()
 (interactive)
(find-file "~/emacs/emacs-settings/spacecraft-mode.org"))


(defun load-spacemacs-config ()
 (interactive)
(find-file "/Users/jay/emacs/emacs-settings/spacemacs-new-config.el"))

(defun load-roam-config ()
 (interactive)
(find-file "/Users/jay/emacs/emacs-settings/org-roam-config.el"))

(defun load-search-config ()
 (interactive)
(find-file "/Users/jay/emacs/emacs-settings/search-commands.org"))


(defun open-abbrevs ()
  (interactive)
(find-file "/Users/jay/emacs/aquamacs-jay/.abbrev_defs")
;; (olivetti-mode 1)
)
#+END_SRC


M-p
C-x y
C-x x
C-x w
C-x t
C-x j
C-c z
C-c x
C-c q


* embolden-region-or-point
#+BEGIN_SRC emacs-lisp
(defun embolden-region-or-point ()
  (interactive)
  (if (region-active-p)
      (progn
        (goto-char (region-end))
        (insert "*")
        (goto-char (region-beginning))
        (insert "*"))
    (insert "**")
    (backward-char)))

(define-key key-minor-mode-map (kbd "M-s-b") 'embolden-region-or-point)
#+END_SRC


* italicize-region-or-point
#+BEGIN_SRC emacs-lisp
(defun italicize-region-or-point ()
  (interactive)
  (if (region-active-p)
      (progn
        (goto-char (region-end))
        (insert "/")
        (goto-char (region-beginning))
        (insert "/"))
(insert "//")
    (backward-char)))

(define-key key-minor-mode-map (kbd "<C-i>") 'italicize-region-or-point)
#+END_SRC


* org todo stuff
** move point to next TODO heading upon DONE state change
#+BEGIN_SRC emacs-lisp
(defun bb/next-heading (&rest args)
(when

(or
(org-entry-is-done-p)
(string= (org-get-todo-state) "MISSED")
)
(outline-next-visible-heading 1)))



(advice-add 'org-todo :after 'bb/next-heading)
#+END_SRC


** Check checkbox then automatically move to next item in list ([[http://superuser.com/questions/568482/org-mode-function-to-check-checkbox-and-move-to-next-in-list#][Source]]):
#+BEGIN_SRC emacs-lisp
(defmacro my/with-advice (adlist &rest body)
  "Execute BODY with temporary advice in ADLIST.
Each element of ADLIST should look like:
  (FUNCTION WHERE AD-FN)
which is suitable for passing to `advice-add'."
  (declare (debug ((&rest (&rest form)) body))
           (indent 1))
  `(progn
     ;; Generate the (advice-add ...) calls
     ,@(mapcar (lambda (adform)
                 (let ((fn    (car  adform))
                       (where (cadr adform))
                       (afn   (caddr adform)))
                   `(advice-add ',fn ,where ,afn)))
               adlist)
     ;; Wrap BODY in unwind-protect so advice is always removed
     (unwind-protect (progn ,@body)
       ;; Generate the (advice-remove ...) calls
       ,@(mapcar (lambda (adform)
                   (let ((fn  (car adform))
                         (afn (caddr adform)))
                     `(advice-remove ',fn ,afn)))
                 adlist))))

(defun my/org-checkbox-toggle-advice (orig-fn &rest args)
  "Advice to move to next list item on checkbox toggle."
  (my/with-advice
   ((org-update-checkbox-count-maybe
     :after (lambda () (ignore-errors (progn (org-next-item) (end-of-line))))))
   (apply orig-fn args)))

(advice-add #'org-ctrl-c-ctrl-c   :around #'my/org-checkbox-toggle-advice)
(advice-add #'org-toggle-checkbox :around #'my/org-checkbox-toggle-advice)

#+END_SRC

*** an alternative approach, probably not needed
#+BEGIN_EXAMPLE emacs-lisp
;; a temporary hack
(defun zin/org-checkbox-next ()
 (interactive)
 (when (org-at-item-checkbox-p)
 (org-toggle-checkbox))
 (org-next-item))
#+END_EXAMPLE

* wrap region
#+BEGIN_SRC emacs-lisp
;; (use-package wrap-region)
;; (wrap-region-add-wrapper "*" "*" "*")
;; (wrap-region-add-wrapper "\/" "\/" "\/")


;; wrap-region
(use-package wrap-region
  :defer
  :ensure t
  :config
  (wrap-region-add-wrapper "\n#+BEGIN_QUOTE\n" "\n#+END_QUOTE\n" ";")

  (defun wrap-region-define-wrappers ()
    "Defines defaults wrappers."
    (mapc
     (lambda (pair)
       (apply 'wrap-region-add-wrapper pair))
     '(
       ;; ("\"" "\"")
       ;; ("'"  "'")
       ;; ("("  ")")
       ("{"  "}")
       ;; ("["  "]")
       ;; ("<"  ">")
       ;; ("<"  ">")
       )))
  (wrap-region-add-wrappers
   '(
     ;;     ("*" "*" nil org-mode)
     ;;     ("/" "/" nil org-mode)
     ;; ("\"" "\"" nil org-mode)
     ("~" "~" nil org-mode)
     ("_" "_" nil org-mode)
     ("*" "*" nil (org-mode message-mode))
     ("/" "/" nil (org-mode message-mode))
     ("$" "$" nil (org-mode latex-mode))
     ))

  )
#+END_SRC
Source: [[http://pragmaticemacs.com/emacs/wrap-text-in-custom-characters/][Wrap text in custom characters | Pragmatic Emacs]]


* faces
** bold
#+BEGIN_SRC emacs-lisp
(custom-set-faces
 ;; custom-set-faces was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 '(bold ((t (:inherit font-lock-warning-face :weight bold))))
)
#+END_SRC

** C-c C-c to exit source code blocks
#+BEGIN_SRC emacs-lisp
(eval-after-load 'org-src
  '(define-key org-src-mode-map
     "\C-c\C-c" #'org-edit-src-exit))
#+END_SRC


** narrow or widen
#+BEGIN_SRC emacs-lisp
(defun narrow-or-widen-dwim (p)
  "Widen if buffer is narrowed, narrow-dwim otherwise.
Dwim means: region, org-src-block, org-subtree, or defun,
whichever applies first. Narrowing to org-src-block actually
calls `org-edit-src-code'.

With prefix P, don't widen, just narrow even if buffer is
already narrowed."
  (interactive "P")
  (declare (interactive-only))
  (cond ((and (buffer-narrowed-p) (not p)) (widen))
        ((region-active-p)
         (narrow-to-region (region-beginning) (region-end)))
        ((derived-mode-p 'org-mode)
         ;; `org-edit-src-code' is not a real narrowing
         ;; command. Remove this first conditional if you
         ;; don't want it.
         (cond ((ignore-errors (org-edit-src-code))
                (delete-other-windows))
               ((ignore-errors (org-narrow-to-block) t))
               (t (org-narrow-to-subtree))))
        ((derived-mode-p 'latex-mode)
         (LaTeX-narrow-to-environment))
        (t (narrow-to-defun))))
#+END_SRC


** org insert easy template source blocks
#+BEGIN_SRC emacs-lisp

(use-package org-tempo
; do not defer!
  )

                                        ; do not defer, is needed for these structure templates

(add-to-list 'org-structure-template-alist '("sr" . "src"))

(add-to-list 'org-structure-template-alist '("sh" . "src sh"))

;; (add-to-list 'org-structure-template-alist '("p" . "src python"))

(add-to-list 'org-structure-template-alist '("le" . "example"))

(add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))

;; (add-to-list 'org-structure-template-alist '("la" . "Export latex"))

(add-to-list 'org-structure-template-alist '("v" . " verse"))
#+END_SRC

Source: [[http://emacs.stackexchange.com/questions/12841/quickly-insert-source-blocks-in-org-mode][org babel - Quickly insert source blocks in org mode - Emacs Stack Exchange]]

#+begin_src emacs-lisp
(setq org-structure-template-alist
 '(("a" . "export ascii")
  ("c" . "center")
  ("C" . "comment")
  ("e" . "example")
  ("x" . "example")
  ("le" . "example")
  ("E" . "export")
  ("h" . "export html")
  ("l" . "src emacs-lisp")
  ("el" . "src emacs-lisp")
  ("la" . "export latex")
  ("q" . "quote")
  ("s" . "src")
  ("sh" . "src sh")
  ("f" . "example fountain")
  ("v" . "example verse")))
#+end_src




* if then else indentation
#+BEGIN_SRC
(put 'if 'lisp-indent-function nil)
#+END_SRC


* Create org file and insert path of screen shot
#+BEGIN_SRC emacs-lisp
(defun insert-file-link-from-clipboard ()
  "Make sure the full path of file exist in clipboard. This command will convert
The full path into relative path and insert it as a local file link in org-mode"
  (interactive)
  (let (str)
    (with-temp-buffer
      (shell-command
       (cond
        ((eq system-type 'cygwin) "getclip")
        ((eq system-type 'darwin) "pbpaste")
        (t "xsel -ob"))
       1)
      (setq str (buffer-string)))

    ;; convert to relative path (relative to current buffer) if possible
    (let ((m (string-match (file-name-directory (buffer-file-name)) str) ))
      (when m
        (if (= 0 m )
            (setq str (substring str (length (file-name-directory (buffer-file-name)))))
          ))
        (insert (format "[[file:%s]]" str)))
    ))
#+END_SRC


* unbind meta-number
This unbinds M-1, M-2, ..., M-0, which I very rarely used (I use C-u for count arguments) and I suddenly found myself with 10 new shortcuts that are easy to type (especially M-1, M-2 and M-3). You can also use them as prefixes, so for example M-1 r could be ivy-recentf and M-1 s could be swiper.

I hope this is somewhat helpful to someone else, happy hacking! Source: [[https://www.reddit.com/r/emacs/comments/3ricev/tip_for_when_you_are_running_out_of_easytopress/][Tip for when you are running out of easy-to-press key shortcuts : emacs]]

#+BEGIN_SRC emacs-lisp
(dotimes (n 10)
  (global-unset-key (kbd (format "M-%d" n))))
#+END_SRC



* fontify list titles
#+BEGIN_SRC emacs-lisp

;; define list-title face
(defface list-title-face
  '((t (:foreground "red" :weight bold)))
  "fontify list titles")

;; define heading-title face
(defface heading-title-face
  '((t (:foreground "red" :weight bold)))
  "fontify heading titles")


;; define anki-clozure face
(defface anki-clozure-face
  '((t (:foreground "red" :weight bold)))
  "fontify anki clozures")


(font-lock-add-keywords 'org-mode
                        '(
			  ;; ("^.*:[ ]*$" . 'list-title-face) ; fontify any line that ends with a colon
                          ("^Q\\(UESTION\\|uestion\\):" . 'list-title-face) ; fontify "Question:" and "QUESTION:"

			  ("^[A-Za-z]+:" . 'list-title-face); fontify any word followed by a colon if it begins the line

			  ;; ("^\\*+[ ]*[a-Za-z]+:" . 'heading-title-face); fontify any heading that starts with a word followed by a colon. But how to make this face supersede the other one?
                          )
                        )



#+END_SRC

** and on export
#+BEGIN_SRC emacs-lisp

;; old code (works for HTML export, breaks http links)
;; (add-hook 'org-export-before-parsing-hook (lambda (backend) (replace-regexp "^[A-Za-z]+:" "*\\&*")))

(add-hook 'org-export-before-parsing-hook (lambda (backend) (replace-regexp "^\\([A-Za-z]+:\\)\\([^/]\\|/[^/]\\|$\\)" "*\\1*\\2")))

;; (add-hook 'org-export-before-parsing-hook (lambda (backend) (replace-regexp "^\\(.*:\\)[ ]*$" "*\\1*")))
 ;; any line that ends with a colon


#+END_SRC

* downcase-or-endless-downcase
#+BEGIN_SRC emacs-lisp
(defun downcase-or-endless-downcase ()
(interactive)
(if

; If
(or
(looking-back "\\.\\.\\.[ ]*[\n\t ]*")
(looking-back "i.e.[ ]*")
(looking-back "[0-9]\.[ ]*")
(looking-back "e.g.[ ]*")
(looking-back "vs.[ ]*")
(looking-back "U.K.[ ]*")
(looking-back "U.S.[ ]*")
(looking-back "vs.[ ]*")
(looking-back "^")
)
    (call-interactively 'downcase-word); then
    (call-interactively 'endless/downcase); else

)
)
#+END_SRC



* sort lines case insensitive
#+BEGIN_SRC emacs-lisp
(defun sort-lines-case-insensitive ()
  (interactive)
  (let ((sort-fold-case t))
    (call-interactively 'sort-lines)))
#+END_SRC

* typewriter mode
#+BEGIN_SRC emacs-lisp
(defun typewriter-mode ()
  (interactive)
  (setq centered-cursor-mode t)
  (setq global-centered-cursor-mode t)
  )
#+END_SRC

* Save file as new
#+BEGIN_SRC emacs-lisp
(defun save-file-as-new ()
  "Force modification of current file, unless already modified."
  (interactive)
  (if (and (verify-visited-file-modtime (current-buffer))
           (not (buffer-modified-p)))
      (progn
        (set-buffer-modified-p t)
        (save-buffer 0))))
#+END_SRC

* touch-file
#+BEGIN_SRC emacs-lisp

    (defun touch-file (file)
    "Create a file called FILE.
  If FILE already exists, signal an error."
    (interactive
    (list (read-file-name "Create file: " (dired-current-directory))))
    (let* ((expanded (expand-file-name file))
      (try expanded)
      (dir (directory-file-name (file-name-directory expanded)))
      new)
     (if (file-exists-p expanded)
      (error "Cannot create file %s: file exists" expanded))
     ;; Find the topmost nonexistent parent dir (variable `new')
     (while (and try (not (file-exists-p try)) (not (equal new try)))
     (setq new try
       try (directory-file-name (file-name-directory try))))
     (when (not (file-exists-p dir))
     (make-directory dir t))
     (write-region "" nil expanded t)
     (when new
     (dired-add-file new)
     (dired-move-to-filename))))
#+END_SRC

* exporting
** org-twbs
#+BEGIN_SRC emacs-lisp
(use-package ox-twbs)
; '(org-twbs-head-include-default-style nil)
;; '(org-twbs-htmlize-output-type (quote inline-css))
; '(org-twbs-indent t)

#+END_SRC


** LaTeX
*** Find LaTeX on my system
#+BEGIN_SRC emacs-lisp
(if (eq window-system 'mac)
    (add-to-list 'exec-path "/usr/local/texlive/2024/bin/universal-darwin")
  )
#+END_SRC

*** XeLaTeX customisations
 ~org~ to LaTeX customisations, ~-shell-escape~ needed for ~minted~:
#+BEGIN_SRC emacs-lisp
(setq  ; org-export-dispatch-use-expert-ui t non-intrusive export dispatch
 org-latex-pdf-process               ; for regular export

 '("xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"))

;; don't add extra lines to numbered lists and bulleted lists (set to nil)

;; add padding to numbered lists and bulleted lists (set to t)
#+END_SRC

*** load my custom latex templates
#+BEGIN_SRC emacs-lisp

(defun jay-load-latex ()
(interactive)

;; (load "/Users/jay/emacs/emacs-settings/latex-templates/blue-ruin.el")
;; (load "/Users/jay/emacs/emacs-settings/latex-templates/modest-ruin.el")
(load "/Users/jay/emacs/emacs-settings/latex-templates/elegant.el")
;; (load "/Users/jay/emacs/emacs-settings/latex-templates/inelegant.el")
;; (load "/Users/jay/emacs/emacs-settings/latex-templates/elegant-wider.el")
(load "/Users/jay/emacs/emacs-settings/latex-templates/beautiful-racket.el")
(load "/Users/jay/emacs/emacs-settings/latex-templates/elegant-garamond.el")
;; (load "/Users/jay/emacs/emacs-settings/latex-templates/resonate.el")
(load "/Users/jay/emacs/emacs-settings/latex-templates/blue-invoice.el")
(load "/Users/jay/emacs/emacs-settings/latex-templates/blue-invoice-with-letterhead.el")
;; (load "/Users/jay/emacs/emacs-settings/latex-templates/blue-ruin_no_cover.el")
(load "/Users/jay/emacs/emacs-settings/latex-templates/jay-latex-yosemite-setup.el")
;; (use-package blue-ruin)
;; (use-package blue-invoice)
;; (use-package blue-ruin-no-cover)
  )
#+END_SRC

*** fix latex verbatim
  You can use a filter function that will replace default "verbatim" with
  whatever you want.

  Here's my fancyvrb filter for when such a place is created.

  Source: [[https://lists.gnu.org/archive/html/emacs-orgmode/2013-04/msg01035.html][Re: {O} {patch} ox-latex.el to allow customization of verbatim environment]]
#+BEGIN_SRC emacs-lisp

 (defun org-latex-filter-fancyvrb (text backend info)
  "Convert begin/end{verbatim} to begin/end{Verbatim}.
 Allows use of the fancyvrb latex package."
  (when
    (org-export-derived-backend-p backend 'latex)
  (replace-regexp-in-string
   "\\\\\\(begin\\|end\\){verbatim}"
   "\\\\\\1{quote}"
   text)))

 (add-to-list 'org-export-filter-final-output-functions
     'org-latex-filter-fancyvrb)
#+END_SRC

* no inline images
#+BEGIN_SRC emacs-lisp
(setq org-startup-with-inline-images nil)
#+END_SRC


* query-replace-duplicate-lines-keep-blanks
Source: [[http://emacs.stackexchange.com/questions/20344/how-to-query-delete-duplicate-lines/20384?noredirect=1#comment31370_20384][replace - how to query-delete-duplicate-lines? - Emacs Stack Exchange]]

#+BEGIN_SRC emacs-lisp
(defun delete-duplicate-lines-keep-blanks ()
 (interactive)
 (delete-duplicate-lines (region-beginning) (region-end) nil nil t))
#+END_SRC

* display
** recenter top bottom
#+BEGIN_SRC emacs-lisp
(setq scroll-margin 25)
;; (setq recenter-positions (quote (top middle bottom)))
#+END_SRC



* org-clock
#+BEGIN_SRC emacs-lisp
(setq org-clock-auto-clock-resolution t)
 (setq org-clock-idle-time 30)
 (setq org-clock-in-resume t)
 (setq org-clock-persist-query-resume nil)
 (setq org-clock-report-include-clocking-task t)
(setq org-clock-persist 'history)
(org-clock-persistence-insinuate)
(setq org-clock-persist t)
(setq org-clock-into-drawer nil)
(setq org-clocktable-defaults
 (quote
 (:maxlevel 3 :lang "en" :scope file :block nil :wstart 1 :mstart 1 :tstart nil :tend nil :step nil :stepskip0 nil :fileskip0 nil :tags nil :emphasize nil :link nil :narrow 40! :indent t :formula nil :timestamp nil :level nil :tcolumns nil :formatter nil)))

(setq org-time-clocksum-format
 (quote
 (:hours "%d" :require-hours t :minutes ":%02d" :require-minutes t)))
#+END_SRC



* sensible defaults
Source: [[https://github.com/hrs/sensible-defaults.el/blob/master/sensible-defaults.el][sensible-defaults.el/sensible-defaults.el at master · hrs/sensible-defaults.el 🔊]]

#+BEGIN_SRC emacs-lisp

;; Utility functions:

(defun sensible-defaults/comment-or-uncomment-region-or-line ()
 "Comments or uncomments the region or the current line if there's no active region."
 (interactive)
 (let (beg end)
  (if (region-active-p)
    (setq beg (region-beginning) end (region-end))
   (setq beg (line-beginning-position) end (line-end-position)))
  (comment-or-uncomment-region beg end)))

(global-set-key (kbd "M-;")
         'sensible-defaults/comment-or-uncomment-region-or-line)



(setq vc-follow-symlinks t)

"When saving a file that starts with `#!', make it executable."
 (add-hook 'after-save-hook
      'executable-make-buffer-file-executable-if-script-p)
#+END_SRC


* repeat-last-command
#+BEGIN_SRC emacs-lisp
(defun repeat-last-command ()
"repeats the last command called via M-x"
(interactive)
(let ((history extended-command-history)
cmd)
;; remove any occurence of this-command at the head of `history'.
(while (string= this-command (setq cmd (pop history))))
(message "Running cmd: %s" cmd)
(call-interactively (intern cmd))))
#+END_SRC

* org
** editing
*** lines
**** org-copy-line
#+BEGIN_SRC emacs-lisp
(defun org-select-line ()
 "Select the current line"
 (interactive)
 (org-beginning-of-line) ; move to end of line
 (set-mark (line-end-position)))

(defun org-copy-line ()
 (interactive)
(org-select-line)
(pasteboard-copy)
(set-mark nil))
#+END_SRC


*** paragraphs
**** kill whole paragraph
     :PROPERTIES:
     :ID:       4DCE53D0-0D37-464B-B398-BD5B4BE18492
     :END:
#+BEGIN_SRC emacs-lisp
(defun kill-paragraph-from-beginning (b e)
  (interactive)
  (mark-paragraph)
  (kill-region)
  )
#+END_SRC


*** subtrees
**** eval-subtree
     :PROPERTIES:
     :ID:       A97FDEB2-CB0D-4B17-9A73-FB737A5F030F
     :END:
#+BEGIN_SRC emacs-lisp
(defun eval-subtree ()
 (interactive)
 (org-edit-src-code)
 (eval-buffer)
 (org-edit-src-exit)
 )
#+END_SRC

*** document
**** kill to buffer end
     :PROPERTIES:
     :ID:       49820CA2-490C-4DA0-9036-F16B262F712E
     :END:

#+BEGIN_SRC emacs-lisp
(defun kill-to-buffer-end-or-beginning (arg)
  (interactive "p")
  (if (and arg (= 0 (mod arg 4)))
      (beginning-of-buffer)
    (end-of-buffer))
  (kill-region (mark) (point))
  (recenter-top-bottom))

(define-key key-minor-mode-map (kbd "M-w") 'kill-to-buffer-end-or-beginning)
#+END_SRC


** navigation
*** up by degrees
#+BEGIN_SRC emacs-lisp
(defun up-by-degrees ()
 (interactive)
       (previous-line 6)
 )


(defun down-by-degrees ()
 (interactive)
       (next-line 6)
 )


#+END_SRC


*** next-subtree-same-level-and-narrow
#+BEGIN_SRC emacs-lisp
(defun org-next-subtree-same-level-and-narrow ()
 (interactive)
 (widen)
 (org-forward-heading-same-level 1)
 (org-narrow-to-subtree)
 )

(defun org-previous-subtree-same-level-and-narrow ()
 (interactive)
(org-previous-visible-heading 1)
 (widen)
(org-backward-heading-same-level 1)
 (org-narrow-to-subtree)
 )
#+END_SRC

*** next-subtree-and-narrow - original
#+BEGIN_SRC emacs-lisp
(defun org-next-subtree-and-narrow ()
 (interactive)
 (widen)
 (org-next-visible-heading 1)
 (org-narrow-to-subtree)
 )

(defun org-previous-subtree-and-narrow ()
 (interactive)
(org-previous-visible-heading 1)
 (widen)
 (org-previous-visible-heading 1)
 (org-narrow-to-subtree)
 )
#+END_SRC

*** filing

**** refile active region or subtree
#+BEGIN_SRC emacs-lisp
(defun refile-region-or-subtree ()
  (interactive)
  (if (region-active-p)
      (call-interactively 'jay-refile-region)
    (org-refile)))
#+END_SRC


* org-config-files-mode
#+BEGIN_SRC emacs-lisp
(define-minor-mode org-config-files-local-mode
  "Minor mode for editing configuration files in org-mode."
  :init-value nil
  :lighter " OrgCfg"
  :keymap (let ((map (make-sparse-keymap)))
            (define-key map (kbd "<SPC>") 'insert-space)
            map)
  (message "org-config-files-local-mode is now %s" org-config-files-local-mode)
  (if org-config-files-local-mode
      (progn
        ;; When enabling, set any additional buffer-local variables
        (setq-local abbrev-mode nil))
    (kill-local-variable 'abbrev-mode)))
#+END_SRC

* yasnippet fixes
#+BEGIN_SRC emacs-lisp
(defun yas/pasteboard-without-spaces ()
 "Return content of OS X system pasteboard via `pbpaste'."
 (shell-command-to-string "pbpaste | perl -p -e 's/\r$//' | tr '\r' '\n'"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun yas/org-get-time-stamp (&rest args)
 "Return the string that `org-insert-time-stamp' would insert."
 (with-temp-buffer
  (apply #'org-insert-time-stamp args)
  (buffer-string)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun yas/tiny-expand (str)
  (with-temp-buffer
    (insert str)
    (goto-char (point-max)) ; tiny-expand works on text preceding point
    (tiny-expand)
    (buffer-string)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun yas/suppress-errors ()
(interactive)
  (ignore-errors (add-to-list 'warning-suppress-types '(yasnippet backquote-change)))
)
#+END_SRC

* optimize emacs load time
#+BEGIN_SRC emacs-lisp
(defun loadup-gen ()
 "Generate the lines to include in the lisp/loadup.el file
to place all of the libraries that are loaded by your InitFile
into the main dumped emacs"
 (interactive)
 (defun get-loads-from-*Messages* ()
  (save-excursion
   (let ((retval ()))
	(set-buffer "*Messages*")
	(beginning-of-buffer)
	(while (search-forward-regexp "^Loading " nil t)
	 (let ((start (point)))
	  (search-forward "...")
	  (backward-char 3)
	  (setq retval (cons (buffer-substring-no-properties start (point)) retval))))
	retval)))
 (map 'list
    (lambda (file) (princ (format "(load \"%s\")\n" file)))
    (get-loads-from-*Messages*)))
#+END_SRC

* crux
#+BEGIN_SRC emacs-lisp

(use-package crux
:defer
:bind
( "M-`" . crux-swap-windows)
( "s-k rf" .  crux-rename-file-and-buffer)
( "s-k df" . crux-delete-file-and-buffer)
( "C-c d" . crux-duplicate-current-line-or-region)
( "C-c i" . crux-find-user-init-file)
)
#+END_SRC

* typography custom functions
** em dash
#+BEGIN_SRC emacs-lisp
(defun em-dash ()
(interactive)
(cond (mark-active
   (progn (delete-region (mark) (point)))))
(expand-abbrev)
(insert "---")
  )
#+END_SRC

** true em dash
#+BEGIN_SRC emacs-lisp
(defun true-em-dash ()
(interactive)
(cond (mark-active
   (progn (delete-region (mark) (point)))))
(expand-abbrev)
(insert "—")
  )
#+END_SRC

** double quote
   #+BEGIN_SRC emacs-lisp
(defun insert-one-double-quote ()
(interactive)
(cond (mark-active
   (progn (delete-region (mark) (point)))))
(insert "\""))
#+END_SRC


** insert right-bracket
   :PROPERTIES:
   :ID:       C6D2D34A-628B-4DB2-9082-DECEBB5D8F9F
   :END:
#+BEGIN_SRC emacs-lisp
(defun insert-right-bracket ()
  (interactive)
(cond (mark-active
   (progn (delete-region (mark) (point)))))
  (insert "\]")
  )
#+END_SRC

** insert equals sign
#+BEGIN_SRC emacs-lisp
(defun insert-equals-sign ()
  (interactive)
(cond (mark-active
   (progn (delete-region (mark) (point)))))
  (insert "=")
  )
#+END_SRC

** insert slash no abbrev
#+BEGIN_EXAMPLE emacs-lisp
(defun jay/insert-slash ()
  (interactive)
  (insert "/")
  )
#+END_EXAMPLE


* undo-tree-mode
#+BEGIN_SRC emacs-lisp
(defun undo-fu-only-redo-fail-silently ()
 "Redo the last undone change if possible, silently fail if no more redo steps."
 (interactive)
 (ignore-errors
  (undo-fu-only-redo)))

(defun undo-fu-only-redo-fail-with-heart ()
 "Redo the last undone change if possible."
 (interactive)
 (condition-case nil
   (undo-fu-only-redo)
  (user-error (message "❤️"))))

(setq undo-tree-auto-save-history nil)

;; Install and configure undo-fu-session to save undo history between sessions
(use-package undo-fu-session
 :ensure t
 :config
;; (undo-fu-session-global-mode) ; do not persist undo tree across sessions
)

(setq undo-limit 67108864) ; 64mb.
(setq undo-strong-limit 100663296) ; 96mb.
(setq undo-outer-limit 1006632960) ; 960mb.
#+END_SRC

* Emacs 25
** don't create new frames
#+BEGIN_SRC emacs-lisp
(setq display-buffer-alist (quote (("" ignore (nil . reusable-frames)))))
#+END_SRC

* from Harry Schwartz
** find file as sudo
#+BEGIN_SRC emacs-lisp
(defun edit-this-file-as-sudo ()
  (interactive)
  (let ((file-name (buffer-file-name)))
   (when file-name
    (find-alternate-file (concat "/sudo::" file-name)))))

(defun sudo-find-file ()
 (interactive)
 (let ((file-name (buffer-file-name)))
  (when file-name
  (find-file (concat "/sudo::" file-name)))))

(defun sudo-edit-paths ()
 (interactive)
(find-file "/etc/paths")
(sudo-edit)
)

(defun sudo-edit-hosts ()
 (interactive)
(find-file "/private/etc/hosts")
(sudo-edit)
)


#+END_SRC


** Use fancy lambdas
Why not?

#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook #'prettify-symbols-mode)
#+END_SRC



** Projectile
Projectile's default binding of =projectile-ag= to =C-c p s s= is clunky enough
that I rarely use it (and forget it when I need it). This binds the
easier-to-type =C-c C-v= and =C-c v= to useful searches.

#+BEGIN_SRC emacs-lisp
 (defun hrs/search-project-for-symbol-at-point ()
  "Use `projectile-ag' to search the current project for `symbol-at-point'."
  (interactive)
  (projectile-ag (projectile-symbol-at-point)))

 (global-set-key (kbd "C-c v") 'projectile-ag)
 (global-set-key (kbd "C-c C-v") 'hrs/search-project-for-symbol-at-point)
;; (setq projectile-indexing-method 'native)
#+END_SRC

*** Ignore files specified in .projectile (doesn't work)
The function counsel-projectile-grep is failing to ignore the files I
specified to ignore in my .projectile file. How can I direct
counsel-projectile-grep to ignore these files?

By default, =counsel-projectile-grep= doesn't use the settings from your
=.projectile= file. To configure =counsel-projectile-grep= to respect
the ignore patterns specified in your =.projectile= file, you can modify
the =counsel-projectile-grep= function by using the =advice-add= feature
in Emacs Lisp.

Here's an example of how to create an advice function that passes the
ignore patterns to =counsel-projectile-grep=:

#+begin_EXAMPLE emacs-lisp
(defun my-projectile-ignore-list ()
 (let ((project-root (projectile-project-root))
    (projectile-file (concat (projectile-project-root) ".projectile")))
  (when (file-exists-p projectile-file)
   (with-temp-buffer
    (insert-file-contents projectile-file)
    (split-string (buffer-string) "\n" t)))))

(defun my-ignore-list-to-grep-options (ignore-list)
 (when ignore-list
  (mapconcat (lambda (pattern)
         (concat "--exclude=" (shell-quote-argument pattern)))
        ignore-list " ")))

(defun my-counsel-projectile-grep-ignore-config (orig-fun &rest args)
 (let ((counsel-projectile-grep-base-command
     (concat counsel-projectile-grep-base-command " "
         (my-ignore-list-to-grep-options


#+end_EXAMPLE

* web-mode
If I'm in =web-mode=, I'd like to:

- Color color-related words with =rainbow-mode=.
- Still be able to run RSpec tests from =web-mode= buffers.
- Indent everything with 2 spaces.

Use =web-mode= with embedded Ruby files, regular HTML, and PHP.

#+BEGIN_SRC emacs-lisp
(defun hrs/add-auto-mode (mode &rest patterns)
  "Add entries to `auto-mode-alist' to use `MODE' for all given file `PATTERNS'."
  (dolist (pattern patterns)
   (add-to-list 'auto-mode-alist (cons pattern mode))))


 (hrs/add-auto-mode
  'web-mode
  "\\.erb$"
  "\\.html$"
  "\\.php$"
  "\\.rhtml$")
#+END_SRC


When editing a code snippet, use the current window rather than popping open a
new one (which shows the same information).

#+BEGIN_SRC emacs-lisp
 (setq org-src-window-setup 'current-window)
#+END_SRC


* how to do an argument
Insert today's date
Ben Maughan

Here's a simple bit of code from the Emacs wiki to insert the current date. I've set the default to be in the format YYYY-MM-DD, but if you use a prefix C-u then you get DD-MM-YYYY.

;; from http://bit.ly/2aBY92J

#+BEGIN_SRC emacs-lisp
(defun insert-todays-date (arg)
 (interactive "P")
 (insert (if arg
    (format-time-string "%d-%m-%Y")
   (format-time-string "%Y-%m-%d"))))
#+END_SRC


* toggle-between-src-and-example-block
#+BEGIN_SRC emacs-lisp
(defun toggle-between-src-and-example-block ()
  (interactive)
  (save-excursion
    (let* ((elt (org-element-at-point))
           (elt-type (org-element-type elt))
           (bgn (org-element-property :begin elt)))
      (cond
       ((eq elt-type 'src-block)
        (goto-char bgn)
        (re-search-forward "#\\+BEGIN_SRC\\s-*\\(\\S-+\\)?")
        (replace-match "#+BEGIN_EXAMPLE \\1")
        (re-search-forward "#\\+END_SRC" nil t)
        (replace-match "#+END_EXAMPLE"))
       ((eq elt-type 'example-block)
        (goto-char bgn)
        (re-search-forward "#\\+BEGIN_EXAMPLE\\s-*\\(\\S-+\\)?")
        (replace-match "#+BEGIN_SRC \\1")
        (re-search-forward "#\\+END_EXAMPLE" nil t)
        (replace-match "#+END_SRC"))
       (t (message "Not in a src or example block!"))))))
#+END_SRC



* ediff
#+BEGIN_SRC emacs-lisp
(setq ediff-diff-options "-w")
#+END_SRC

* mouse scrolling
#+BEGIN_SRC emacs-lisp
(setq mac-wheel-button-is-mouse-2 nil)
;; so that the middle button works

(setq scroll-conservatively 1000) ; seems nice

#+END_SRC

* fix image links
#+BEGIN_SRC emacs-lisp
(defun fix-image-links ()
(interactive)
)
#+END_SRC

* ox-clip
#+BEGIN_SRC emacs-lisp
(use-package ox-clip
  :defer)
#+END_SRC

* org-def
#+BEGIN_SRC emacs-lisp
(defun org-def ()
(interactive)
(save-excursion
(beginning-of-line)
 (insert "- "))
(insert " :: ")
)
#+END_SRC


* delete html blocks
#+BEGIN_SRC emacs-lisp
(defun delete-html-blocks ()
(interactive)
(replace-regexp "#\\+BEGIN_HTML\\(?:.*\\|\n\\)*#\\+END_HTML" "")
)
#+END_SRC

* beacon
#+BEGIN_EXAMPLE emacs-lisp
(use-package beacon
:defer
 :init

 (beacon-mode 1)
(setq beacon-push-mark 35)
(setq beacon-color "#FFF876")
 )
#+END_EXAMPLE

* Tufte
** tufte export to HTML
#+BEGIN_SRC emacs-lisp
(use-package ox-tufte
  :defer)
#+END_SRC

** tufte export to LaTeX
#+begin_src emacs-lisp
(use-package ox-tufte-LaTeX
:defer
  :ensure nil
  :init (load "/Users/jay/emacs/emacs-settings/tufte-org-mode-master/ox-tufte-latex.el")
  )
#+end_SRC

* add YouTube link type yt:
#+BEGIN_SRC emacs-lisp
(defvar yt-iframe-format
 ;; You may want to change your width and height.
 (concat "<iframe width=\"440\""
     " height=\"335\""
     " src=\"https://www.youtube.com/embed/%s\""
     " frameborder=\"0\""
     " allowfullscreen>%s</iframe>"))

(org-add-link-type
 "yt"
 (lambda (handle)
  (browse-url
  (concat "https://www.youtube.com/embed/"
      handle)))
 (lambda (path desc backend)
  (cl-case backend
   (html (format yt-iframe-format
          path (or desc "")))
   (latex (format "\href{%s}{%s}"
          path (or desc "video"))))))
#+END_SRC


[[http://endlessparentheses.com/embedding-youtube-videos-with-org-mode-links.html][Embedding Youtube videos with org-mode links · Endless Parentheses]]

To use this, just write your org links in the following way (optionally adding a description).

[[yt:A3JAlWM8qRM]]

* display and copy spacemacs version info
#+BEGIN_SRC emacs-lisp
(defun spacemacs-version-display-and-copy ()
 "Echo the current version of Spacemacs, Emacs, and org-mode, and copy it."
 (interactive)
(setq system-version
 (substring
 (shell-command-to-string "defaults read loginwindow SystemVersionStampAsString")
 0 -1))
 (kill-new
   (message "Mac OSX Sierra version %s, Spacemacs version %s, Emacs version %s, org-mode version %s"
       system-version spacemacs-version emacs-version org-version))
 (push-kill-ring-pasteboard-to-MacOS-clipboard)
)
#+END_SRC

See also spacemacs/describe-system-info

* display and copy emacs version info
#+BEGIN_SRC emacs-lisp
(defun emacs-version-display-and-copy ()
 "Echo the current version of Spacemacs, Emacs, and org-mode, and copy it."
 (interactive)
(setq system-version
 (substring
 (shell-command-to-string "defaults read loginwindow SystemVersionStampAsString")
 0 -1))
 (kill-new
   (message "Mac OSX Sierra version %s, Emacs version %s, org-mode version %s"
       system-version emacs-version org-version))
 (push-kill-ring-pasteboard-to-MacOS-clipboard)
)
#+END_SRC

See also spacemacs/describe-system-info

* shell command on region
#+BEGIN_SRC emacs-lisp
(defun tidy-html ()
 "Tidies the HTML content in the buffer using `tidy'"
 (interactive)
 (shell-command-on-region
  ;; beginning and end of buffer
  (point-min)
  (point-max)
  ;; command and parameters
  "tidy -i -w 120 -q"
  ;; output buffer
  (current-buffer)
  ;; replace?
  t
  ;; name of the error buffer
  "*Tidy Error Buffer*"
  ;; show error buffer?
  t))
#+END_SRC
[[https://www.masteringemacs.org/article/executing-shell-commands-emacs][Executing Shell Commands in Emacs - Mastering Emacs]]


* smart question mark
#+BEGIN_SRC emacs-lisp
(defun qm-maybe ()
(interactive)
(when
(not
(looking-back "$")
)
(smart-question-mark)
)
)

;; (define-key key-minor-mode-map (kbd "?") 'qm-maybe)
#+END_SRC



* convert to chat format
#+BEGIN_EXAMPLE emacs-lisp
(defun intern-convert-to-chat-format (begin end)
 (interactive "r")
 (xah-replace-pairs-region begin end
 '(
 ["Mary Dean: " "** Mary Dean\n"]
 ["Ricky DeSantis: " "** Ricky DeSantis\n"]
 ["Jay Dixit: " "** Jay Dixit\n"]
 ["me: " "** Jay Dixit\n"]
 ["Benjamin: " "** Benjamin Carp\n"]
 ["Camille Inge: " "** Camille Inge\n"]
 ["Benjamin: " "** Ben Bechar\n"]
 )))

#+END_EXAMPLE


* shell-pop
#+BEGIN_SRC emacs-lisp
(use-package shell-pop
:defer
 :bind (("C-t" . shell-pop))
 :config
 (setq shell-pop-shell-type (quote ("ansi-term" "*ansi-term*" (lambda nil (ansi-term shell-pop-term-shell)))))
 (setq shell-pop-term-shell "/bin/zsh")
 ;; need to do this manually or not picked up by `shell-pop'
 (shell-pop--set-shell-type 'shell-pop-shell-type shell-pop-shell-type))
#+END_SRC



* fix case

* ignore case in searches
#+BEGIN_SRC emacs-lisp
(defun ignore-case-in-searches ()
 (interactive)
 (setq case-fold-search t)
 )
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun isearch-forward-ignore-case ()
(interactive)
(ignore-case-in-searches)
(isearch-forward)
)
#+END_SRC


* org count words
Source: [[https://www.reddit.com/r/emacs/comments/8qm1lb/new_orgcountwords_command/][New org-count-words command : emacs]]


Note that it does not count words in heading lines, planning lines, and drawers, so it gives a more useful count for the "prose" in the subtree.

ounts lines, words, and characters in the region or the subtree at point. It prints a message like count-words does, like:

: Subtree "Heading" has 7 line, 5 words, and 28 characters.


#+BEGIN_SRC emacs-lisp

(defun ap/org-count-words ()
  "If region is active, count words in it; otherwise count words in current subtree."
  (interactive)
  (if (use-region-p)
    (funcall-interactively #'count-words-region (region-beginning) (region-end))
   (org-with-wide-buffer
    (cl-loop for (lines words characters)
        in (org-map-entries
          (lambda ()
           (ap/org-forward-to-entry-content 'unsafe)
           (let ((end (org-entry-end-position)))
            (list (count-lines (point) end)
               (count-words (point) end)
               (- end (point)))))
          nil 'tree)
        sum lines into total-lines
        sum words into total-words
        sum characters into total-characters
        finally do (message "Subtree \"%s\" has %s lines, %s words, and %s characters."
                  (org-get-heading t t) total-lines total-words total-characters)))))

(defun ap/org-forward-to-entry-content (&optional unsafe)
  "Skip headline, planning line, and all drawers in current entry.
If UNSAFE is non-nil, assume point is on headline."
  (unless unsafe
   ;; To improve performance in loops (e.g. with `org-map-entries')
   (org-back-to-heading))
  (cl-loop for element = (org-element-at-point)
       for pos = (pcase element
             (`(headline . ,_) (org-element-property :contents-begin element))
             (`(,(or 'planning 'property-drawer 'drawer) . ,_) (org-element-property :end element)))
       while pos
       do (goto-char pos)))
#+END_SRC


* time stamps
[[http://emacs-fu.blogspot.com/2008/12/automatic-timestamps.html][emacs-fu: automatic timestamps]]


#+BEGIN_SRC emacs-lisp
(setq
 time-stamp-active t     ; do enable time-stamps
time-stamp-line-limit 50; check first 50 lines
time-stamp-format "%04y-%02m-%02d"; date format
time-stamp-pattern "50//*Invoice date:\\*+\s%:y-%02m-%02d\\\\?$"
)

;; (add-hook 'write-file-hooks 'time-stamp) ; update when saving

(add-hook 'before-save-hook 'time-stamp)
#+END_SRC


* server reflash
#+BEGIN_SRC emacs-lisp
(defun server-reflash ()
  (interactive)
  (server-force-delete)
  (server-start)
  )
#+END_SRC


* poet-mode
#+BEGIN_SRC emacs-lisp
;; (add-hook 'org-mode-hook
;;         (lambda ()
;;         (variable-pitch-mode 1)))

;; (set-face-attribute 'variable-pitch nil :family "Baskerville")
(set-face-attribute 'variable-pitch nil :family "Triplicate T3")

(add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
  (add-to-list 'default-frame-alist '(ns-appearance . light))


;;  (typo-mode 1)      ;; Good for symbols like em-dash
(add-hook 'poetry-mode-hook 'olivetti-mode 1)
;; (add-hook 'poetry-mode-hook 'olivetti-mode 1)

(defun poet-mode ()
(interactive)
(set-face-attribute 'default nil :family "Iosevka" :height 130)
(set-face-attribute 'fixed-pitch nil :family "Iosevka")
        (variable-pitch-mode 1)
(poetry-mode)
(olivetti-mode 1)
;; (turn-off-auto-capitalize-mode)

)
#+END_SRC


* default org-css
#+begin_SRC emacs-lisp
(defvar my-org-selected-css "/Users/jaydixit/Dropbox/web-design/custom-css/sans-serif.css"
  "Path of the selected CSS file or 'none' for no stylesheet. Defaults to sans-serif.css if not manually selected.")

(defvar my-org-css-options
  '("/Users/jay/Dropbox/web-design/custom-css/email.css"
    "/Users/jay/Dropbox/web-design/custom-css/gmail.css"
    "/Users/jay/Dropbox/github/incandescentman.github.io/css/neocortex.css"
    "/Users/jaydixit/Dropbox/web-design/custom-css/sakura.css"
    "/Users/jaydixit/Dropbox/web-design/custom-css/sans-serif.css"
    "/Users/jay/Dropbox/github/org-html-themes/src/bigblow_theme/css/bigblow.css"
    "none")
  "List of CSS file options for Org HTML export.")

(defun select-org-export-css ()
  "Prompt the user to select a CSS file or choose none."
  (interactive)
  (setq my-org-selected-css
        (completing-read "Choose a CSS file or none: " my-org-css-options))
  (when (string-equal my-org-selected-css "none")
    (setq my-org-selected-css nil)))

(defun my-org-inline-css-hook (exporter)
  "Insert custom inline CSS for Org HTML export."
  (when (eq exporter 'html)
    (when (eq my-org-selected-css 'unset)
      (select-org-export-css))
    (if (and my-org-selected-css (not (eq my-org-selected-css 'unset)))
        (let ((final my-org-selected-css))
          (when (file-exists-p final)
            (setq org-html-head-include-default-style nil)
            (setq org-html-head (concat
                                 "<style type=\"text/css\">\n"
                                 "<!--/*--><![CDATA[/*><!--*/\n"
                                 (with-temp-buffer
                                   (insert-file-contents final)
                                   (buffer-string))
                                 "/*]]>*/-->\n"
                                 "</style>\n"))))
      (setq org-html-head-include-default-style nil)
      (setq org-html-head nil))))

(add-hook 'org-export-before-processing-hook 'my-org-inline-css-hook)
#+END_SRC

* hashtags
#+begin_src emacs-lisp
(defun show-duplicate-words (&optional alphabetical)
 "Collect all of the unique words in the current buffer and
display them in a new buffer. With prefix, alphabetize the
list."
 (interactive "P")
 (let ((buf (buffer-name))
    (new (get-buffer-create "*Unique Words*"))
    (txt (delete-dups (mapcar #'downcase
                 (split-string (buffer-string)
                        nil nil
                        "[^[:alnum:]]+")))))
  (with-current-buffer new
   (delete-region (point-min) (point-max))
   (insert (format "%d unique words in the <%s> buffer:\n\n"
           (length txt) buf))
   (cl-dolist (word (if alphabetical (sort txt #'string<) txt))
    (insert (concat word "\n"))))
  (pop-to-buffer new)))
#+end_src


* suppress org-tempo warning
Redefine org-tempo-add-templates

#+begin_src emacs-lisp

(defun org-tempo-add-templates ()
 "Update all Org Tempo templates.

Go through `org-structure-template-alist' and
`org-tempo-keywords-alist' and update tempo templates."
 (mapc 'org--check-org-structure-template-alist '(org-structure-template-alist
						  org-tempo-keywords-alist))
 (let ((keys (org-tempo--keys)))
  ;; Check for duplicated snippet keys and warn if any are found.
  (when (> (length keys) (length (delete-dups keys)))
)
  ;; Remove any keys already defined in case they have been updated.
  (setq org-tempo-tags
	 (cl-remove-if (lambda (tag) (member (car tag) keys)) org-tempo-tags))
  (mapc #'org-tempo-add-block org-structure-template-alist)
  (mapc #'org-tempo-add-keyword org-tempo-keywords-alist)))

#+END_SRC


* multiple cursors
#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :defer)
(setq mc/list-file "/Users/jay/emacs/emacs-settings/mc-lists.el")


(define-key key-minor-mode-map (kbd "C-8") 'endless/mc-map)
(define-prefix-command 'endless/mc-map)
(define-key ctl-x-map "m" 'endless/mc-map)
(define-key key-minor-mode-map (kbd "C-8") 'endless/mc-map)

;;; Really really nice!
(define-key endless/mc-map "i" #'mc/insert-numbers)
(define-key endless/mc-map "h" #'mc-hide-unmatched-lines-mode)
(define-key endless/mc-map "a" #'mc/mark-all-like-this)

;;; Occasionally useful
(define-key endless/mc-map (kbd "<backspace>") 'delete-backward-char)
(define-key endless/mc-map "d" #'mc/mark-all-symbols-like-this-in-defun)
(define-key endless/mc-map "r" #'mc/reverse-regions)
(define-key endless/mc-map "s" #'mc/sort-regions)
(define-key endless/mc-map "l" #'mc/edit-lines)
(define-key endless/mc-map (kbd "<return>") #'newline-and-indent)
(define-key endless/mc-map "\C-a"
 #'mc/edit-beginnings-of-lines)
(define-key endless/mc-map "\C-e"
 #'mc/edit-ends-of-lines)


#+END_SRC
* org-mode-hooks and text-mode-hooks
** text-mode-hooks
#+begin_src emacs-lisp

(add-hook 'text-mode-hook 'flyspell-mode)
(add-hook 'text-mode-hook #'dubcaps-mode)
(add-hook 'org-mode-hook #'dubcaps-mode)

(add-hook 'text-mode-hook #'olivetti-mode 1)
;; (add-hook 'org-mode-hook 'turn-off-autocomplete-mode )

(add-hook 'org-mode-hook 'turn-on-flyspell)
(add-hook 'org-mode-hook (lambda () (flyspell-lazy-mode 1)))

(add-hook 'org-mode-hook #'flycheck-mode)
;; (add-hook 'org-mode-hook (lambda () (org-sticky-header-mode 1)))

#+end_src

** org-mode-hooks
#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook 'turn-on-visual-line-mode)
(add-hook 'org-mode-hook #'(lambda () (auto-fill-mode -1)))

;; (add-hook 'org-mode-hook 'turn-on-auto-capitalize-mode)


(add-hook 'org-mode-hook 'wrap-region-mode)
 (add-hook 'latex-mode-hook 'wrap-region-mode)

(add-hook
 'org-mode-hook
 (lambda ()
 (define-key org-mode-map (kbd "DEL")
  'new-org-delete-backward-char)))

#+END_SRC


* wide-screen
#+begin_src emacs-lisp
(defun wide-screen ()
(interactive)
(setq olivetti-body-width 72)
)
#+end_src


* hide blank lines only in heading mode
In collapsed view, hide empty lines between subtrees

#+begin_src emacs-lisp
(setq org-cycle-separator-lines 0)
#+end_src

* Demote sequence for list bullets
#+begin_src emacs-lisp
(setq org-list-demote-modify-bullet '(("+" . "-") ("-" . "+")))
#+end_src


* embiggen text
#+begin_SRC emacs-lisp


(defun embiggen-text ()
 (interactive)
 (text-scale-increase 1)
 )

(defun ensmallen-text ()
 (interactive)
 (text-scale-decrease 1)
 )

#+END_SRC


* yesterday
#+begin_src emacs-lisp

(defun yesterday ()
  (interactive)
    (insert (shell-command-to-string "echo -n $(date -v -1d +%F)"))
  )
#+end_src



For bash:

#+begin_src sh

yesterday=$(date -v -1d '+%m-%d-%y') && echo $yesterday

#+end_src

* today
#+begin_src emacs-lisp

(defun today ()
  (interactive)
    (insert (shell-command-to-string "echo -n $(date +%F)"))
  )
#+end_src


* minimalist org ellipsis
#+begin_src emacs-lisp
(custom-set-faces
 '(org-ellipsis ((t (:family "Iosevka Nerd Font" :foreground "LightGray" :underline nil)))))
(setq org-ellipsis " ")
;; (setq org-ellipsis " ▶")
#+end_src

Courtesy of Mike Goldenberg



* render org-tables in buffer
[[https://www.reddit.com/r/emacs/comments/d3a8or/pretty_org_tables_in_the_buffer_chapter_2_it/][Pretty org tables in the buffer - chapter 2 (it works properly) : emacs]]

#+begin_src emacs-lisp
(defun org-render-table-at-point ()
 (interactive)
 (save-excursion
  (beginning-of-line)
  (if (overlays-at (point))
    ;; this is a rough solution, because there can
    ;; be other overlays at point
    (delete-overlay (car (overlays-at (point))))

   (let* ((element-type (org-element-type (org-element-at-point))))
    (if (and (not (eq element-type 'table))
         (not (eq element-type 'table-row)))
      (error "not at an org table")

     (while (not (eq 'table (org-element-type (org-element-at-point))))
      (forward-line -1))

     (org-render-table (org-element-at-point)))))))


(defun org-render-table (table)
 (interactive)
 (let* ((begin (org-element-property :begin table))
     (end (let ((pos (org-element-property :end table)))
        (goto-char pos)
        (beginning-of-line)
        ;; skip possible space after table
        (while (not (looking-at " *[|#]"))
         (setq pos (point))
         (forward-line -1))
        pos))
     (tabletxt (buffer-substring-no-properties begin end))
     (img (with-temp-buffer
        (insert tabletxt)
        (mark-whole-buffer)
        (org-latex-convert-region-to-latex)
        (org-preview-latex-fragment)
        (goto-char (point-min))
        (overlay-get (car (overlays-at (point))) 'display)))
     (overlay (make-overlay begin end)))
  (overlay-put overlay 'display img)
  (forward-line -1)))


(defun org-render-tables-in-buffer ()
 (save-excursion
  (org-element-map (org-element-parse-buffer) 'table 'org-render-table)))

#+end_src


* org-show-inline-images
#+begin_src emacs-lisp
(defun org-show-inline-images ()
 (interactive)
(org-toggle-inline-images))
#+end_src

* ido-vertical-mode
Pretty cool here:
[[https://github.com/creichert/ido-vertical-mode.el][creichert/ido-vertical-mode.el: makes ido-mode display vertically]]


#+begin_src emacs-lisp
(use-package ido-vertical-mode
  :defer)
(ido-mode 1)
(ido-vertical-mode 1)
(setq ido-vertical-define-keys 'C-n-and-C-p-only)

(setq ido-vertical-define-keys 'C-n-C-p-up-down-left-right)

;; optionally
(setq ido-use-faces nil)

;; (setq ido-use-faces t)
;; (set-face-attribute 'ido-vertical-first-match-face nil :foreground "orange")

#+end_src

#+begin_src emacs-lisp
(defvar mode-line-cleaner-alist
 `((auto-complete-mode . " α")
  (yas/minor-mode . " υ")
  (paredit-mode . " π")
  (eldoc-mode . "")
  (abbrev-mode . "")
  (rmail-mode . "")
  (counsel-mode . ".")
  (palimpsest-mode . "")
  ;; Major modes
  (lisp-interaction-mode . "λ")
  (hi-lock-mode . "")
  (python-mode . "Py")
  (emacs-lisp-mode . "EL")
  (nxhtml-mode . "nx"))
 "Alist for `clean-mode-line'.

When you add a new element to the alist, keep in mind that you
must pass the correct minor/major mode symbol and a string you
want to use in the modeline *in lieu of* the original.")


(defun clean-mode-line ()
 (interactive)
 (cl-loop for cleaner in mode-line-cleaner-alist
    do (let* ((mode (car cleaner))
         (mode-str (cdr cleaner))
         (old-mode-str (cdr (assq mode minor-mode-alist))))
       (when old-mode-str
         (setcar old-mode-str mode-str))
        ;; major mode
       (when (eq mode major-mode)
        (setq mode-name mode-str)))))


(add-hook 'after-change-major-mode-hook 'clean-mode-line)

;;; alias the new `flymake-report-status-slim' to
;;; `flymake-report-status'
(defalias 'flymake-report-status 'flymake-report-status-slim)
(defun flymake-report-status-slim (e-w &optional status)
 "Show \"slim\" flymake status in mode line."
 (when e-w
  (setq flymake-mode-line-e-w e-w))
 (when status
  (setq flymake-mode-line-status status))
 (let* ((mode-line " Φ"))
  (when (> (length flymake-mode-line-e-w) 0)
   (setq mode-line (concat mode-line ":" flymake-mode-line-e-w)))
  (setq mode-line (concat mode-line flymake-mode-line-status))
  (setq flymake-mode-line mode-line)
  (force-mode-line-update)))

(setq flymake-mode-line-format "")

(add-to-list 'mode-line-cleaner-alist '(org-ai-mode . ""))

(setq-default mode-line-format
       (remove '(vc-mode vc-mode) mode-line-format))

(setq evil-want-keybinding nil)
(setq evil-mode-line-format nil)

(setq gcmh-mode-line nil)


#+end_src

* org-timesheet
Source: [[https://emacs.stackexchange.com/questions/30280/how-to-conveniently-insert-a-clock-entry][org mode - How to conveniently insert a clock entry? - Emacs Stack Exchange]]

#+begin_src emacs-lisp
(defun timesheet_insert-custom-clock-entry ()
 (interactive)
 (insert "CLOCK: ")
 (org-time-stamp-inactive)
 (insert "--")
 ;; Inserts the current time by default.
 (let ((current-prefix-arg '(4))) (call-interactively 'org-time-stamp-inactive))
 (org-ctrl-c-ctrl-c))

#+end_src


* custom time format
#+begin_src emacs-lisp
;; (setq-default org-display-custom-times nil)
(setq org-time-stamp-custom-formats '("<%A %B %e, %Y>" . "<%01m/%01e %01I:%M %p>"))

(defun insert-date-time-stamp-file-local-variable ()
  "Insert file-local variables to set custom `org-time-stamp-custom-formats` into the current buffer."
  (interactive)
  (let* ((options '(("Short Format (Mon Dec 24)"
                     "eval: (setq-local org-time-stamp-custom-formats '(\"<%a %b %d>\" . \"<%a %b %d %H:%M>\"))")
                    ("Long Format (Monday December 24, 2024)"
                     "eval: (setq-local org-time-stamp-custom-formats '(\"<%A %B %e, %Y>\" . \"<%01m/%01e %01I:%M %p>\"))")))
         (choice (completing-read "Choose a date-time format: " (mapcar 'car options)))
         (format-line (cdr (assoc choice options))))
    (if format-line
        (progn
          (goto-char (point-max)) ;; Move to the end of the buffer
          (insert "\n# Local Variables:\n")
          (insert (format "# %s\n" format-line))
          (insert "# eval: (setq-local org-display-custom-times t)\n")
          (insert "# End:\n")
          (message "Inserted file-local variables for: %s" choice))
      (message "Invalid choice"))))

#+end_src



* clean up tex files
[[https://emacs.stackexchange.com/questions/23982/cleanup-org-mode-export-intermediary-file][Cleanup org-mode export intermediary file - Emacs Stack Exchange]]

#+begin_src emacs-lisp
(setq org-latex-logfiles-extensions (quote ("lof" "lot" "tex" "odt" "aux" "idx" "log" "out" "toc" "nav" "snm" "vrb" "dvi" "fdb_latexmk" "blg" "brf" "fls" "entoc" "ps" "spl" "bbl")))
#+end_src


* Better time-stamps in org-export
#+begin_EXAMPLE emacs-lisp
(add-to-list 'org-export-filter-timestamp-functions
             #'endless/filter-timestamp)
(defun endless/filter-timestamp (trans back _comm)
  "Remove <> around time-stamps."
  (pcase back
    ((or `jekyll `html)
     (replace-regexp-in-string "&[lg]t;" "" trans))
    (`latex
     (replace-regexp-in-string "[<>]" "" trans))))

(setq-default org-display-custom-times t)
;;; Before you ask: No, removing the <> here doesn't work.
(setq org-time-stamp-custom-formats
   '("<%A %b %e, %Y>" . "<%d/%m/%y %a %H:%M>"))

#+END_EXAMPLE


* koma letter
#+begin_src emacs-lisp
(add-to-list 'org-latex-classes
    '("my-letter"
     "\\documentclass\[%
 DIV=14,
 fontsize=12pt,
 parskip=half,
 subject=titled,
 backaddress=false,
 fromalign=left,
 fromemail=true,
 fromphone=true\]\{scrlttr2\}
 \[DEFAULT-PACKAGES]
 \[PACKAGES]
 \[EXTRA]"))

#+end_src

#+BEGIN_SRC emacs-lisp
(defun load-koma-letter ()
 (interactive)
 (load "/Users/jay/emacs/emacs-settings/ox-koma-letter.el")
 (load "/Users/jay/emacs/emacs-settings/fiverr-koma.el")
 )
#+END_SRC

* allow file local custom code
#+begin_src emacs-lisp
(setq enable-local-eval t)
#+end_src

* saveplace
#+begin_src emacs-lisp
(use-package saveplace
  :defer)
(setq-default save-place t)
#+end_src


* org export preserve line breaks
#+begin_src emacs-lisp
(setq org-export-preserve-breaks t)
#+end_src


* calc
#+begin_src emacs-lisp
(define-key key-minor-mode-map (kbd "M-=") 'calc-grab-region)
#+end_src


* delete trailing whitespace
#+begin_src emacs-lisp
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src

* trailing lines
#+begin_src emacs-lisp
(setq delete-trailing-lines nil)
#+end_SRC




* don't lock files
#+begin_src emacs-lisp
(setq create-lockfiles nil)
(run-with-idle-timer 300 t 'org-save-all-org-buffers)
#+end_SRC


* I love you
#+begin_src emacs-lisp
(defun iloveyou (args)
 (interactive "P")
(message "%s" (propertize "I love you! ❤️" 'Face '(:foreground "red")))
 )
#+end_src

* set OpenAI API key
Rewrite this emacs-lisp function to retrieve the API key from an external file: (setq openai-api-key "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")

Here is an example of how you might rewrite the function to retrieve the API key from an external file:

#+begin_src emacs-lisp
(defun get-openai-api-key ()
 "Retrieve the OpenAI API key from an external file."
 (let ((api-key-file "~/.openai-api-key"))
 (when (file-exists-p api-key-file)
  (with-temp-buffer
  (insert-file-contents api-key-file)
  (buffer-string)))))

(setq openai-api-key (get-openai-api-key))
#+end_src

This function will look for a file named ~/.openai/api-key, read the contents of the file, and return the API key as a string. The openai-api-key variable will then be set to this value.

* playing with ChatGTP
#+begin_src emacs-lisp
(defun start-pomodoro ()
 "Starts a 25-minute pomodoro timer and logs the completed pomodoro in a file called `~/pomodori.txt`."
 (interactive)
 (run-at-time "25 min" nil
        (lambda ()
         (with-current-buffer (find-file-noselect "~/pomodori.txt")
          (goto-char (point-max))
          (insert (concat (format-time-string "%Y-%m-%d %H:%M:%S")
                  ": Completed pomodoro\n"))
          (save-buffer))))
 (message "Pomodoro timer started. Will log completed pomodoro in `~/pomodori.txt` at %s"
      (format-time-string "%Y-%m-%d %H:%M:%S" (+ (float-time) (* 60 25)))))
#+end_SRC

* Warnings
#+begin_src emacs-lisp
(use-package warnings
  :defer)
(add-to-list 'warning-suppress-types '(yasnippet backquote-change))
#+end_src

* org 9.6 suppress a weird error message
[[https://github.com/nobiot/org-transclusion/issues/105][Warning (emacs): org-element--cache: Unregistered buffer modifications detected. Resetting · Issue #105 · nobiot/org-transclusion]]

#+begin_src emacs-lisp
(setq warning-suppress-types (append warning-suppress-types '((org-element-cache))))
#+end_src


* Export to .docx
#+begin_src emacs-lisp
(setq org-odt-preferred-output-format "docx")
#+end_src


* Capitalization
** Capitalize level 1 headings use correct rules of capitalizing titles
#+begin_src emacs-lisp
(defun org-titlecase-level-1 ()
 "Convert all Level 1 org-mode headings to title case."
 (interactive)
 (save-excursion
 (goto-char (point-min))
 (while (re-search-forward "^\\* " nil t)
  (titlecase-line))))
#+end_SRC

** Sentencecase-region
#+begin_EXAMPLE emacs-lisp
(defun sentencecase-region (start end)
 "Convert the region to sentence case."
 (interactive "r")
 (let ((end-marker (copy-marker end))) ; Create a marker to remember the end position
  (save-excursion
   (goto-char start)
   (downcase-region start end) ; First, make everything lowercase
   (while (< (point) end-marker)
    (when (or (and (eq (point) start) (bolp)) ; Special case for the start
         (eq (char-before) ?.) ; Period
         (eq (char-before) ?!) ; Exclamation mark
         (eq (char-before) ??)) ; Question mark
     (skip-syntax-forward " ") ; Skip any spaces
     (when (< (point) end-marker) ; Check if still within bounds
      (capitalize-word 1))) ; Capitalize the first word
    (forward-word 1)))))




#+END_EXAMPLE

^ doesn't work

#+begin_src emacs-lisp
(defun sentencecase-region (start end)
 "Convert the region to sentence case."
 (interactive "r")
 (let ((case-fold-search nil)) ; Make search case-sensitive
 (save-excursion
  (goto-char start)
  (downcase-region start end) ; Convert everything to lowercase first
  (while (< (point) end)
  (capitalize-word 1)  ; Capitalize the first word
  (forward-sentence))  ; Move to the next sentence
  (goto-char start)    ; Go back to the start to fix special cases
  (while (re-search-forward "\\bi\\b" end t)
  (replace-match "I"))
  (goto-char start)
  (while (re-search-forward "\\bi'" end t)
  (replace-match "I'"))
  (goto-char start)
  (while (re-search-forward "\\bjay\\b" end t)
  (replace-match "Jay"))
  (goto-char start)
  (while (re-search-forward "\\bsunjay\\b" end t)
  (replace-match "Sunjay"))
  (goto-char start)
  (while (re-search-forward "\\bdixit\\b" end t)
  (replace-match "Dixit")))))

#+end_src

* extract hyperlinks
#+begin_src emacs-lisp
(defun extract-hyperlinks-from-file (file)
 "Extracts all hyperlinks from the text file FILE."
 (interactive "fEnter file to extract hyperlinks from: ")
 (let ((hyperlinks '()))
  (with-temp-buffer
   (insert-file-contents file)
   (goto-char (point-min))
   (while (re-search-forward "\\(http\\|https\\|id\\)://[^[:space:]]+" nil t)
    (push (match-string-no-properties 0) hyperlinks)))
  (message "Hyperlinks extracted: %s" hyperlinks)
  hyperlinks))


(defun extract-hyperlinks-from-buffer ()
 "Extracts all hyperlinks from the current buffer."
 (interactive)
 (let ((hyperlinks '()))
  (save-excursion
   (goto-char (point-min))
   (while (re-search-forward "\\[\\[id:[^]]+\\]\\]" nil t)
    (push (match-string-no-properties 0) hyperlinks)))
  (message "Hyperlinks extracted: %s" hyperlinks)
  hyperlinks))

#+end_src





* Key chords
Use key chord
#+BEGIN_SRC emacs-lisp
(use-package key-chord
  :defer)
(key-chord-mode 1)
#+END_SRC


* Add numbering
Written by ChatGPT 3.5 Worked the first time.

Jay:

Write an Emacs-lisp org-mode function to add numbering to a highlighted region.

ChatGPT:

Here's an Emacs Lisp function that can be used in Org-mode to add numbering to a highlighted region:

#+begin_src emacs-lisp
(defun number-region (beg end)
 "Add numbering to a highlighted region."
 (interactive "r")
 (let ((counter 1)
    (end-marker (copy-marker end)))
  (save-excursion
   (goto-char beg)
   (beginning-of-line)
   (while (< (point) end-marker)
    (insert (format "%d. " counter))
    (setq counter (1+ counter))
    (forward-line 1))
   (set-marker end-marker nil))))

#+end_src

To use this function, highlight the region you want to add numbering to and then call the ~number-region~ function using M-x ~number-region~. This will add a number to the beginning of each line in the highlighted region. The numbering will start from 1 and increment by 1 for each line.

* org-panes
#+begin_EXAMPLE emacs-lisp

(use-package org-panes
:defer
 :ensure nil
 :config (setq org-panes-split-overview-horizontally t)
     (setq org-panes-main-size 70))

; org-panes and olivetti don't play well together
; because they both change window sizes. this function
; turns olivetti-mode off first if it's on, so that
; org-panes doesn't get confused about the window size
(defun org-panes-check-olivetti ()
 (interactive)
 (if (bound-and-true-p olivetti-mode)
   (progn (olivetti-mode -1)
       (org-panes)
       (olivetti-mode))
    (org-panes)))


     #+END_EXAMPLE

* word count
#+begin_src emacs-lisp
(use-package wc-goal-mode
:defer)
#+end_src


* org-roam
#+begin_src emacs-lisp
(load "/Users/jay/emacs/emacs-settings/org-roam-config.el")

 #+end_SRC




* consult
#+begin_src emacs-lisp
;; Example configuration for Consult
(use-package consult
:defer
 :after (consult-eglot)
 ;; Replace bindings. Lazily loaded due by `use-package'.
 :bind (
;; ("C-s s" . consult-line)
;; 	 ("C-s e" . consult-eglot-symbols)
;; 	 ("C-s r" . consult-ripgrep)
;; ("s-G" . consult-ripgrep)
;; 	 ("C-s f" . consult-find)
;; 	 ("C-s l" . consult-flymake)
;; 	 ("C-s n" . consult-focus-lines)
;; 	 ("C-s I" . consult-project-imenu)
;; 	 ("C-s o" . consult-outline)
;; 	 ("C-s b" . consult-bookmark)
;; 	 ("C-s m" . consult-man)


   )

 ;; Enable automatic preview at point in the *Completions* buffer. This nt when you use the default completion UI.
 :hook (completion-list-mode . consult-preview-at-point-mode)

 ;; The :init configuration is always executed (Not lazy)
 :init

 (global-unset-key (kbd "C-s"))

 ;; Optionally configure the register formatting. This improves the register
 ;; preview for `consult-register', `consult-register-load',
 ;; `consult-register-store' and the Emacs built-ins.
 (setq register-preview-delay 0.5
    register-preview-function #'consult-register-format)

 ;; Optionally tweak the register preview window.
 ;; This adds thin lines, sorting and hides the mode line of the window.
 (advice-add #'register-preview :override #'consult-register-window)

 ;; Use Consult to select xref locations with preview
 (setq xref-show-xrefs-function #'consult-xref
    xref-show-definitions-function #'consult-xref)

 ;; Configure other variables and modes in the :config section,
 ;; after lazily loading the package.
 :config

 ;; Optionally configure preview. The default value
 ;; is 'any, such that any key triggers the preview.
 ;; (setq consult-preview-key 'any)
 ;; (setq consult-preview-key (kbd "M-."))
 ;; (setq consult-preview-key (list (kbd "<S-down>") (kbd "<S-up>")))
 ;; For some commands and buffer sources it is useful to configure the
 ;; :preview-key on a per-command basis using the `consult-customize' macro.
 (consult-customize
  consult-theme
  :preview-key '(:debounce 0.2 any)
  consult-ripgrep consult-git-grep consult-grep
  consult-bookmark consult-recent-file consult-xref
  consult--source-bookmark consult--source-recent-file
  consult--source-project-recent-file
  ;; :preview-key (kbd "M-."))

  ;; Optionally configure the narrowing key.
  ;; Both < and C-+ work reasonably well.
  (setq consult-narrow-key "<") ;; (kbd "C-+")

  ;; Optionally make narrowing help available in the minibuffer.
  ;; You may want to use `embark-prefix-help-command' or which-key instead.
  ;; (define-key consult-narrow-map (vconcat consult-narrow-key "?") #'consult-narrow-help)

  ;; By default `consult-project-function' uses `project-root' from project.el.
  ;; Optionally configure a different project root function.
  ;; There are multiple reasonable alternatives to chose from.
 ;;;; 1. project.el (the default)
  ;; (setq consult-project-function #'consult--default-project--function)
 ;;;; 2. projectile.el (projectile-project-root)
  ;; (autoload 'projectile-project-root "projectile")
  ;; (setq consult-project-function (lambda (_) (projectile-project-root)))
 ;;;; 3. vc.el (vc-root-dir)
  ;; (setq consult-project-function (lambda (_) (vc-root-dir)))
 ;;;; 4. locate-dominating-file
  ;; (setq consult-project-function (lambda (_) (locate-dominating-file "." ".git")))
  ))

(key-chord-define-global "SS" 'consult-line)

#+end_src


* org-roam-ui
Pretty knowledge graphs are to knowledge management what speaker lights are to music.

  #+begin_SRC emacs-lisp
(use-package org-roam-ui
:defer
  :after org-roam
;;     normally we'd recommend hooking orui after org-roam, but since org-roam does not have
;;     a hookable mode anymore, you're advised to pick something yourself
;;     if you don't care about startup time, use
;; :hook (after-init . org-roam-ui-mode)

  :config
  (setq org-roam-ui-sync-theme t
     org-roam-ui-follow t
     org-roam-ui-update-on-save t
     org-roam-ui-open-on-start t))
#+end_SRC



* orderless
#+begin_src emacs-lisp
(use-package orderless

 :defer
 :ensure t
 :custom
 (completion-styles '(orderless))
 (completion-category-overrides '((command (styles . (partial-completion))))))
  #+end_SRC


* vertico
#+begin_src emacs-lisp
(use-package marginalia
:defer
:ensure t
 :delight
 :custom
 (marginalia-max-relative-age 0)
 (marginalia-align 'right)
 :init
 (marginalia-mode))

 (use-package vertico
:defer
:ensure t
   :init
 (vertico-mode)

 ;; Different scroll margin
 ;; (setq vertico-scroll-margin 0)

 ;; Show more candidates
 ;; (setq vertico-count 20)

 (setq vertico-resize t)

 ;; Optionally enable cycling for `vertico-next' and `vertico-previous'.
 ;; (setq vertico-cycle t)
 )
#+end_SRC

* embark
#+begin_EXAMPLE emacs-lisp

(use-package embark
:defer
 :ensure t

 :bind
 (("s-e" . embark-act)     ;; pick some comfortable binding
  ("C-;" . embark-dwim)    ;; good alternative: M-.
  ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'

 :init

 ;; Optionally replace the key help with a completing-read interface
 (setq prefix-help-command #'embark-prefix-help-command)

 ;; Show the Embark target at point via Eldoc. You may adjust the Eldoc
 ;; strategy, if you want to see the documentation from multiple providers.
 (add-hook 'eldoc-documentation-functions #'embark-eldoc-first-target)
 ;; (setq eldoc-documentation-strategy #'eldoc-documentation-compose-eagerly)

 :config

 ;; Hide the mode line of the Embark live/completions buffers
 (add-to-list 'display-buffer-alist
        '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
         nil
         (window-parameters (mode-line-format . none)))))

;; Consult users will also want the embark-consult package.
(use-package embark-consult
:defer
 :ensure t ; only need to install it, embark loads it after consult if found
 :hook
 (embark-collect-mode . consult-preview-at-point-mode))
#+END_EXAMPLE


* show duplicate lines
#+begin_src emacs-lisp
(defun show-duplicate-lines ()
 "Display all duplicate lines in the current buffer."
 (interactive)
 (let ((lines (split-string (buffer-string) "\n" t))
    (seen-lines '())
    (dup-lines '()))
  (dolist (line lines)
   (if (member line seen-lines)
     (setq dup-lines (cons line dup-lines))
    (setq seen-lines (cons line seen-lines))))
  (if dup-lines
    (with-output-to-temp-buffer "*Duplicate Lines*"
     (dolist (line (reverse dup-lines))
      (princ (concat line "\n"))))
   (message "No duplicate lines found."))))
#+end_src


* org-ai
#+begin_EXAMPLE emacs-lisp
(use-package org-ai

:defer
:ensure
 :commands (org-ai-mode)
:init
 (add-hook 'org-mode-hook #'org-ai-mode)
 :config
 ;; if you are on the gpt-4 beta:
(setq org-ai-default-chat-model "gpt-4")
;; (setq org-ai-summarize-prompt
;;   "You are a brilliant writer for The New York Times and Harvard Business Review. Write a summary of this text in a fun, fascinating, engaging, conversational style.")

 ;; if you are using yasnippet and want `ai` snippets
(org-ai-install-yasnippets))

(setq org-ai-default-chat-system-prompt "I'm Jay Dixit, a science writer, adjunct professor of creative writing and storytelling, consultant, and corporate trainer. I'm an expert on writing about psychology, and I used to be an editor at Psychology Today Magazine. I've also written for The New York Times. I offer professional workshops and training workshops in business writing and storytelling. I would like to start offering corporate training for companies on how to use ChatGPT, and I'm looking for clients. I work on Mac OS, and I use Emacs org-mode and Bash scripts. You are a helpful assistant inside Emacs.")

(load "/Users/jay/emacs/emacs-secret/openai-key.el")

#+END_EXAMPLE


* org-roam as a personal CRM
#+begin_src emacs-lisp
(defvar spook--org-roam-crm-dir "/Users/jay/Dropbox/roam/notes"
 "Directory where org-roam notes related to people are kept.")

(defun spook--with-org-roam-crm (func &rest args)
 "Evaluate FUNC with ARGS org-roam set for working as CRM."
 (let* ((org-roam-directory spook--org-roam-crm-dir)
     (org-roam-db-location (concat org-roam-directory "/roam.db")))
  (apply func args)))

(defun spook-crm--db-sync ()
 (interactive)
 (spook--with-org-roam-crm #'org-roam-db-sync))

(defun spook-crm--individual-find ()
 (interactive)
 (spook--with-org-roam-crm #'org-roam-node-find))

(defun spook-crm--individual-insert ()
 (interactive)
 (spook--with-org-roam-crm #'org-roam-node-insert))

;; (spook-defkeymap
;;  "spook-people" "a-i"
;;  '("f" . spook-crm--individual-find)
;;  '("i" . spook-crm--individual-insert))
;; (define-key key-minor-mode-map (kbd "s-i f") 'spook-crm--individual-find)
;; (define-key key-minor-mode-map (kbd "s-i i") 'spook-crm--individual-insert)
;; (define-key key-minor-mode-map (kbd "s-i s") 'org-ai-summarize)

#+end_src

* Jay own ai
#+begin_EXAMPLE emacs-lisp

(defun intelligent-summarize ()
 "Run org-ai-summarize on the highlighted region."
 (interactive)
(setq org-ai-summarize-prompt "Writing for readers of The New York Times, write a summary of this text in a fun, fascinating, engaging, conversational style.")
(if (get-buffer "*org-ai-on-region*")
  (kill-buffer "*org-ai-on-region*"))
 (let ((orig-point (point)))
  (when (region-active-p)
   (org-ai-summarize (region-beginning) (region-end)))
  (goto-char orig-point))
 )

(defun funny-summarize ()
 "Run org-ai-summarize on the highlighted region."
 (interactive)
(setq org-ai-summarize-prompt "Writing for readers of The New York Times, write a funny summary of this text in a funny, witty conversational style.")
(if (get-buffer "*org-ai-on-region*")
 (kill-buffer "*org-ai-on-region*"))
 (let ((orig-point (point)))
 (when (region-active-p)
  (org-ai-summarize (region-beginning) (region-end)))
 (goto-char orig-point))
 )
(define-key key-minor-mode-map (kbd "s-i f") 'funny-summarize)
#+END_EXAMPLE


* Eisenhower Matrix :urgent:
#+begin_src emacs-lisp
(setq org-tag-alist '(("important" . ?i)
           ("urgent"  . ?u)))
#+end_src


#+begin_EXAMPLE emacs-lisp
(add-to-list 'load-path "/Users/jay/emacs/external-packages/chatgpt-shell-main")
(use-package chatgpt-shell
  :defer)


#+END_EXAMPLE

* gptel
#+begin_EXAMPLE emacs-lisp
(use-package gptel
:defer
 :init
 (setq gptel-default-mode 'org-mode)
 :config
 (defun gptel-return ()
  (interactive)
  (if (gptel-mode) ; if gptel-mode is active
    (gptel-send)   ; call gptel-send
   (org-return-indent)))  ; else normal org-mode return
 ;; key binding within gptel-mode-map
 (define-key gptel-mode-map (kbd "RET") 'gptel-return)
 ;; bind C-t directly within gptel-mode-map
 (define-key gptel-mode-map (kbd "C-t") 'gptel-send)
)

(defun setup-org-mode-keys ()
 ;; Key binding for org-mode-map
 (define-key org-mode-map (kbd "RET") 'smart-return))

(add-hook 'org-mode-hook 'setup-org-mode-keys)



#+END_EXAMPLE

* gptel extensions
[[https://github.com/kamushadenes/gptel-extensions.el][kamushadenes/gptel-extensions.el: Extra functions for gptel]]

~gptel-ext-send-whole-buffer~

Send the whole buffer to ChatGPT.

~gptel-ext-ask-document~

Load the current buffer into a session so you can ask questions about
it.

~gptel-ext-rewrite-and-replace~

Rewrite the region or sentence at point and replace it with the
response. Extracted from
the [[https://github.com/karthink/gptel/wiki][Wiki]].

~gptel-ext-refactor~

Refactor the region or sentence at point.

#+begin_EXAMPLE emacs-lisp
(load "/Users/jay/emacs/external-packages/gptel-extensions/gptel-extensions.el")
(use-package gptel-extensions
:defer
:ensure t
 :config
 ;; Your configuration comes here
 )

#+end_EXAMPLE

See also: [[https://github.com/kamushadenes/ai-blog.el][kamushadenes/ai-blog.el: Blogging with Emacs and AI]]

* org-superstar
#+begin_SRC emacs-lisp
(require 'org-superstar)
(add-hook 'org-mode-hook (lambda () (org-superstar-mode 1)))
(setq org-superstar-prettify-item-bullets t)

;; additional indentation for sub-items in a list
(setq org-list-indent-offset 1)


;; (setq org-superstar-headline-bullets-list '(""))
;; ;; This is usually the default, but keep in mind it must be nil
;; (setq org-hide-leading-stars nil)
;; ;; This line is necessary.
;; (setq org-superstar-leading-bullet nil)
;; ;; If you use Org Indent you also need to add this, otherwise the
;; ;; above has no effect while Indent is enabled.
;; (setq org-indent-mode-turns-on-hiding-stars nil)
;; (setq org-superstar-remove-leading-stars t)


#+END_SRC

* openwith
#+begin_src emacs-lisp

(use-package openwith
  :defer)
(setq openwith-associations '(("\\.pdf\\'" "open" (file))))
(openwith-mode t)
#+end_src


* load my LaTeX config only when I actually need to export something
Jay: How do I direct Emacs to load a file (containing my org-mode LaTeX
export configuration) the first time I run org Export to LaTeX?

ChatGPT: You can achieve this by using the ~org-export-before-processing-hook~.
This hook allows you to run a custom function before the export process
starts. You can define a custom function to load your Org-mode LaTeX
export configuration file and add this function to the hook.

Jay: Can I make it load this file only the first time I export something to
LaTeX, rather than every time?

ChatGPT: Yes, you can achieve this by modifying your custom function to remove
itself from the ~org-export-before-processing-hook~ after it loads your
configuration file. This way, the function will be executed only once
during the first export:

#+begin_src emacs-lisp
(add-hook 'org-export-before-processing-hook 'my-load-org-latex-export-config)

(defun my-load-org-latex-export-config (&rest args)
  "Load the Org-mode LaTeX export configuration file and remove itself from the hook."
  (jay-load-latex)
  (remove-hook 'org-export-before-processing-hook 'my-load-org-latex-export-config))
#+end_src


* org-autolist
#+begin_EXAMPLE emacs-lisp
(use-package org-autolist
:defer
:hook (org-mode . org-autolist-mode))
(add-hook 'org-mode-hook (lambda () (org-autolist-mode)))

(setq org-autolist-enable-delete nil)
#+END_EXAMPLE

*** org-autolist deleting list items
Suppose we start with:

#+begin_example
- [ ] one
- [ ] two
- [ ] apple
- [ ] |
#+end_example

Pressing "Backspace" will produce:

#+begin_example
- [ ] one
- [ ] two
- [ ] apple|
#+end_example

Similarly, if we instead start from here:

#+begin_example
- [ ] one
- [ ] two
- [ ] |apple
#+end_example

Then pressing "Backspace" will produce:

#+begin_example
- [ ] one
- [ ] two|apple
#+end_example

If you want to disable this behavior, add this to your ~init.el~:

#+begin_SRC
(setq org-autolist-enable-delete nil)
#+END_SRC

*** start at the right number
[[https://www.reddit.com/r/orgmode/comments/10ybf40/how_to_force_orgautolistel_to_start_from_the/][How to force org-autolist.el to start from the number I choose : orgmode]]

* dictionaries
Three different dictionary programs:

irony

** ~define-word~
- its own dictionary. Definitions appear in minibuffer, which is weird.
- But nicely formatted

#+begin_src emacs-lisp
(defun define-word--convert-html-tag-to-face (str)
 "Replace semantical HTML markup in STR with the relevant faces."
 (with-temp-buffer
  (insert str)
  ;; Remove empty <i></i> tags
  (goto-char (point-min))
  (while (re-search-forward "<i></i>" nil t)
   (replace-match ""))
  (cl-loop for (regexp face) in define-word--tag-faces do
     (define-word--regexp-to-face regexp face))
  (buffer-string)))

#+end_src

** dictionary
- dictionary-lookup-definition
- dictionary-search
- via dict.org
- choice of wordnet, websters (gcide)

** sdcv
Gives me all the offline dictionaries I've previously installed! Is great.

#+begin_src emacs-lisp
(use-package sdcv
:defer
:custom
sdcv-popup-function 'showtip)
#+end_SRC

** command line
Lots more options here: [[/Users/jay/Dropbox/apps/bash/dictionary-scripts.sh]]


* consult ripgrep
Avoid recentering errors. Works!
#+begin_src emacs-lisp
(defun consult-recenter-advice (orig-fn &rest args)
 "Advice for `recenter' to avoid errors when the window is not displaying the current buffer."
 (when (eq (window-buffer) (current-buffer))
  (apply orig-fn args)))

(advice-add 'recenter :around #'consult-recenter-advice)
#+end_src


* outdent or promote
Do the same thing whether on a plain text list or an org heading.
#+begin_src emacs-lisp
(defun org-outdent-or-promote ()
 "Run either org-outdent-item-tree or org-promote-subtree,
depending on which one is appropriate based on the context."
 (interactive)
 (cond
 ;; If the cursor is on a plain list item, run org-outdent-item-tree
 ((org-at-item-p) (org-outdent-item-tree))
 ;; If the cursor is on a headline, run org-promote-subtree
 ((org-at-heading-p) (org-promote-subtree))
 ;; Otherwise, do nothing and show a message
 (t (message "Not at an item or a headline"))))

(defun org-indent-or-demote ()
 "Run either org-indent-item-tree or org-demote-subtree,
depending on which one is appropriate based on the context."
 (interactive)
 (cond
  ;; If the cursor is on a plain list item, run org-indent-item-tree
  ((org-at-item-p) (org-indent-item-tree))
  ;; If the cursor is on a headline, run org-demote-subtree
  ((org-at-heading-p) (org-demote-subtree))
  ;; Otherwise, do nothing and show a message
  (t (message "Not at an item or a headline"))))
#+end_src


* Info mode
#+begin_src emacs-lisp
; (define-key Info-mode-map (kbd "s-o") 'copy-region-to-other-window)
; (define-key org-mode-map (kbd "s-o") 'move-region-to-other-window)
(define-key Info-mode-map (kbd "s-[") 'Info-backward-node)
(define-key Info-mode-map (kbd "s-]") 'Info-forward-node)
#+end_src


* toggle between two windows but not the third
#+begin_src emacs-lisp
(defun toggle-window-2-3 ()
 "Toggle between window 2 and window 3 using winum."
 (interactive)
 (let ((current-window (winum-get-number)))
  (cond ((= current-window 2)
      (winum-select-window-by-number 3))
     ((= current-window 3)
      (winum-select-window-by-number 2))
     (t
      (message "Point is not in window 2 or 3.")))))
;; (define-key key-minor-mode-map (kbd "s-`") 'toggle-window-2-3)
#+end_src


* fuzzy open recent file
This is my goto way for navigating. It feels like it is reading your mind.

#+begin_src emacs-lisp
(use-package fasd

:custom
 (fasd-enable-initial-prompt nil)
 :config
 ;; global-fasd-mode records new files in the fasd database,
 ;; even if they haven't been opened from the command line
 (global-fasd-mode 1)
 )
#+end_src

** make fasd work even when not using Ivy
#+begin_src emacs-lisp
(defun fasd-find-file (prefix &optional query)
 "Use fasd to open a file, or a directory with dired.
If PREFIX is positive consider only directories.
If PREFIX is -1 consider only files.
If PREFIX is nil consider files and directories.
QUERY can be passed optionally to avoid the prompt."

 (interactive "P")
 (if (not (executable-find "fasd"))
   (error "Fasd executable cannot be found. It is required by `fasd.el'. Cannot use `fasd-find-file'")
  (unless query (setq query (if fasd-enable-initial-prompt
                 (read-from-minibuffer "Fasd query: ")
                "")))
  (let* ((prompt "Fasd query: ")
      (results
      (split-string
       (shell-command-to-string
       (concat "fasd -t -l -R" ; Add the -t option here
           (pcase (prefix-numeric-value prefix)
            (`-1 " -f ")
            ((pred (< 1)) " -d ")
            (_ (concat " " fasd-standard-search " ")))
           query))
       "\n" t))
      (file (when results
          ;; set `this-command' to `fasd-find-file' is required because
          ;; `read-from-minibuffer' modifies its value, while `ivy-completing-read'
          ;; assumes it to be its caller
          (setq this-command 'fasd-find-file)
          (completing-read prompt results nil t))))
   (if (not file)
     (message "Fasd found nothing for query `%s'" query)
    (fasd-find-file-action file)))))



(defun fasd-find-file (prefix &optional query)
 "Use fasd to open a file, or a directory with dired.
If PREFIX is positive consider only directories.
If PREFIX is -1 consider only files.
If PREFIX is nil consider files and directories.
QUERY can be passed optionally to avoid the prompt."

 (interactive "P")
 (if (not (executable-find "fasd"))
   (error "Fasd executable cannot be found. It is required by 'fasd.el'. Cannot use fasd-find-file'")
  (unless query
   (setq query (if fasd-enable-initial-prompt
           (read-from-minibuffer "Fasd query: ")
          "")))
  (let* ((prompt "Fasd query: ")
      (command (concat "fasd -t -l -R "
              (pcase (prefix-numeric-value prefix)
               (-1 " -f ")
               ((pred (< 1)) " -d ")
               (_ ""))
              " " query))
      (results (split-string
           (shell-command-to-string command)
           "\n" t))
      (file (when results
          ;; Debug: print the command and results
          (message "fasd command: %s" command)
          (message "fasd results: %s" results)
          ;; set this-command to 'fasd-find-file' as required
          ;; because 'read-from-minibuffer' modifies its value
          ;; while 'ivy-completing-read' assumes it to be its caller
          (setq this-command 'fasd-find-file)
          (completing-read prompt results nil t))))
   (if (not file)
     (message "Fasd found nothing for query '%s'" query)
    (fasd-find-file-action file)))))

#+end_src

I added the -t flag above. Ugh, didn't work 🤷🏻‍♂️

The -t flag in fasd stands for "time" and means that the matching will be done based on the recent access time of files or directories. When you use the -t flag, fasd will rank the files or directories according to their access time and present them in that order.

By default, fasd sorts the results based on a combination of frequency (how often a file or directory is accessed) and recency (how recently it was accessed). The -t flag modifies this behavior to consider only the recency of access, giving you a list of files or directories that you accessed most recently, regardless of how often you've accessed them.

For example, to list recently accessed files using the -t flag, you can run:

I also took out the -R flag. I don't know why it was there?

** don't forget to update the fasd database
#+begin_EXAMPLE emacs-lisp
(defun update-fasd-database (&rest _)
 "Update the fasd database with the current buffer's file."
 (when (and (executable-find "fasd") buffer-file-name)
  (start-process "*fasd*" nil "fasd" "--add" buffer-file-name)))

(defun fasd-add-file-to-db ()
 "Add current file or directory to the Fasd database."
  (let ((file (if (string= major-mode "dired-mode")
          dired-directory
         (buffer-file-name))))
   (when (and file
         (stringp file)
         (file-readable-p file))
    (start-process "*fasd*" nil "fasd" "--add" file))))


(add-hook 'find-file-hook 'update-fasd-database)
(add-hook 'find-file-hook 'fasd-add-file-to-db)
(add-hook 'dired-mode-hook 'fasd-add-file-to-db)
#+END_EXAMPLE



* Google things from within emacs
#+begin_SRC emacs-lisp
(use-package google-this
:defer
:custom
(google-this-browse-url-function 'eww-browse-url)
  )


(defun google-word-and-display-in-EWW ()
 "Google the word at point and display the results in the minibuffer using EWW."
 (interactive)
 (let ((word (thing-at-point 'word t)))
  (if word
    (progn
     (eww-browse-url (concat "https://www.google.com/search?q=" word))
     (message "Showing results for %s in EWW" word))
   (message "No word at point"))))

(define-key key-minor-mode-map (kbd "M-g M-g") 'google-this)

(defun er-google ()
 "Google the selected region if any, display a query prompt otherwise."
 (interactive)
 (browse-url
  (concat
  "http://www.google.com/search?ie=utf-8&oe=utf-8&q="
  (url-hexify-string (if mark-active
     (buffer-substring (region-beginning) (region-end))
    (read-string "Google: "))))))

   #+end_SRC

* EWW
o: open in external browser
r: reload
w: copy-page-url
v: view-source

#+begin_src emacs-lisp
(use-package eww
:defer
:bind
  (
   :map eww-mode-map
        ("o" . eww-browse-with-external-browser)
        ("r" . eww-reload)
        ("s-l" . eww)
        ("s-[" . eww-back-url)
        ("s-]" . eww-forward-url)
        ("s-o" . eww-open-file)
   ))
#+end_src

If you want to waste some time, there are some extras here:
https://protesilaos.com/codelog/2021-03-25-emacs-eww/

(set-face-attribute 'org-variable-pitch-face (face-attribute 'default :font))

* consult git grep
#+begin_src emacs-lisp
;; (setq consult-git-grep-args )
#+end_src


* org-mac-link
** edge
#+begin_src emacs-lisp
(use-package org-mac-link
)

(defun org-mac-paste-applescript-links (as-link-list)
 "Paste in a list of links from an applescript handler.
The links are of the form <link>::split::<name>."
 (let* ((noquote-as-link-list
	 (if (string-prefix-p "\"" as-link-list)
	   (substring as-link-list 1 -1)
	  as-link-list))
	 (link-list
	 (mapcar (lambda (x) (if (string-match "\\`\"\\(.*\\)\"\\'" x)
				 (setq x (match-string 1 x)))
		  x)
		 (split-string noquote-as-link-list "[\r\n]+")))
	 split-link URL description orglink orglink-insert rtn orglink-list)
  (while link-list
   (setq split-link (split-string (pop link-list) "::split::"))
   (setq URL (car split-link))
   (setq description (cadr split-link))
   (when (not (string= URL ""))
	(setq orglink (org-make-link-string URL description))
	(push orglink orglink-list)))
  (setq rtn (mapconcat 'identity orglink-list "\n"))
  (kill-new rtn)
  rtn))


(defun org-as-mac-bing-get-frontmost-url ()
 (let ((result
	 (do-applescript
	 (concat
	  "set frontmostApplication to path to frontmost application\n"
	  "tell application \"Bing\"\n"
	  "	set theUrl to get URL of active tab of first window\n"
	  "	set theResult to (get theUrl) & \"::split::\" & (get name of window 1)\n"
	  "end tell\n"
	  "activate application (frontmostApplication as text)\n"
	  "set links to {}\n"
	  "copy theResult to the end of links\n"
	  "return links as string\n"))))
  (replace-regexp-in-string
   "^\"\\|\"$" "" (car (split-string result "[\r\n]+" t)))))

(defun org-mac-bing-get-frontmost-url ()
 (interactive)
 (message "Applescript: Getting Bing url...")
 (org-mac-paste-applescript-links (org-as-mac-bing-get-frontmost-url)))

;;;###autoload
(defun org-mac-bing-insert-frontmost-url ()
 (interactive)
 (insert (org-mac-bing-get-frontmost-url)))

(define-key key-minor-mode-map (kbd "s-6") 'org-mac-bing-insert-frontmost-url)
 #+end_SRC

test

** don't number windows
#+begin_src emacs-lisp
(defun org-mac-link--clean-title (title)
  "Remove unwanted prefixes like '(2) ' from TITLE."
  (replace-regexp-in-string "^([0-9]+)\\s-+" "" title))

(defun org-mac-link-chrome-copy-frontmost-url ()
  "Retrieve the URL and title from the frontmost Google Chrome tab and copy as an Org-mode link."
  (interactive)
  (let* ((as-command
          "tell application \"Google Chrome\"
               if not (exists front window) then return \"NO_ACTIVE_TAB\"
               set theURL to URL of active tab of front window
               set theTitle to title of active tab of front window
               return theURL & \"§§§\" & theTitle
           end tell")
         (as-result (string-trim (shell-command-to-string (concat "osascript -e " (shell-quote-argument as-command))))))
    (if (string-equal as-result "NO_ACTIVE_TAB")
        (message "No active tab found in Google Chrome.")
      (let* ((components (split-string as-result "§§§"))
             (url (string-trim (nth 0 components)))
             (title (org-mac-link--clean-title (string-trim (nth 1 components))))
             (org-link (format "[[%s][%s]]" url title)))
        (kill-new org-link)
(message "Copied Org link to clipboard: %s" org-link)
))))

(defun org-mac-link-chrome-insert-frontmost-url ()
  "Insert the URL and title from the frontmost Google Chrome tab as an Org-mode link."
  (interactive)
  (let* ((as-command
          "tell application \"Google Chrome\"
               set theURL to URL of active tab of front window
               set theTitle to title of active tab of front window
               return theURL & \"§§§\" & theTitle
           end tell")
         (as-result (string-trim (shell-command-to-string (concat "osascript -e " (shell-quote-argument as-command)))))
         (components (split-string as-result "§§§"))
         (url (string-trim (nth 0 components)))
         (title (org-mac-link--clean-title (string-trim (nth 1 components))))
         (org-link (format "[[%s][%s]]" url title)))
    (insert org-link)
;; (message "Inserted Org link: %s" org-link)
))
#+end_src

* org-refile-region-to-org-heading-or-roam-node
wonder if this could help...
https://www.reddit.com/r/emacs/comments/l99xc8/consult_got_support_for_multiple_candidate_sources/

#+begin_EXAMPLE emacs-lisp
(defun org-refile-region-to-org-heading-or-roam-node (beg end &optional copy)
 "Refile the region between BEG and END to an Org mode heading or Org-roam node.
If COPY is non-nil, copy the region instead of cutting it."
 (interactive "r\nP")
 (let* ((target (org-refile-get-location))
     (file (nth 1 target))
     (pos (nth 3 target))
     (text (buffer-substring-no-properties beg end)))
  (if pos
    (progn
     (unless copy
      (kill-region beg end))
     (deactivate-mark)
     (with-current-buffer (find-file-noselect file)
      (save-excursion
       (goto-char pos)
       (if (eql refile-region-position 'bottom)
         (org-end-of-subtree)
        (org-end-of-meta-data))
       (insert (format refile-region-format text)))))
   (progn
    (message "Target: %s" target)
    (user-error "Invalid target location")))))


(defun org-refile-get-location (&optional prompt default-buffer new-nodes)
 "Prompt the user for a refile location, including Org-roam nodes.
PROMPT should not be suffixed with a colon and a space, because
this function appends the default value from
`org-refile-history' automatically, if that is not empty."
 (let ((org-refile-targets org-refile-targets)
    (org-refile-use-outline-path org-refile-use-outline-path))
  (setq org-refile-target-table (org-refile-get-targets default-buffer)))
 (unless org-refile-target-table
  (user-error "No refile targets"))

 (let* ((cbuf (current-buffer))
     (cfn (buffer-file-name (buffer-base-buffer cbuf)))
     (cfunc (if (and org-refile-use-outline-path
             org-outline-path-complete-in-steps)
          #'org-olpath-completing-read
         #'completing-read))
     (extra (if org-refile-use-outline-path "/" ""))
     (cbnex (concat (buffer-name) extra))
     (filename (and cfn (expand-file-name cfn)))
     (org-cands (mapcar
           (lambda (x)
            (if (and (not (member org-refile-use-outline-path
                       '(file full-file-path title)))
                (not (equal filename (nth 1 x))))
              (cons (concat (car x) extra " ("
                     (file-name-nondirectory (nth 1 x)) ")")
                 (cdr x))
             (cons (concat (car x) extra) (cdr x))))
           org-refile-target-table))
     (roam-cands (mapcar (lambda (node)
                (cons (org-roam-node-title node)
                   (list (org-roam-node-file node)
                      (org-roam-node-point node))))
               (org-roam-node-list)))
     (tbl (append org-cands roam-cands))
     (completion-ignore-case t)
     cdef
     (prompt (let ((default (or (car org-refile-history)
                  (and (assoc cbnex tbl) (setq cdef cbnex)
                     cbnex))))
          (org-format-prompt prompt default)))
     answ)
  (setq answ (funcall cfunc prompt tbl nil (not new-nodes)
            nil 'org-refile-history
            (or cdef (car org-refile-history))))
  (if (assoc answ tbl)
    (let ((location-data (cdr (assoc answ tbl))))
     (if (org-roam-node-p (car location-data))
       (list answ (org-roam-node-file (car location-data)) (org-roam-node-point (car location-data)))
      location-data))
   (if (string-match "\\`\\(.*\\)/\\([^/]+\\)\\'" answ)
     (progn
      (setq parent (match-string 1 answ)
         child (match-string 2 answ))
      (setq parent-target (org-refile--get-location parent tbl))
      (when (and parent-target
            (or (eq new-nodes t)
              (and (eq new-nodes 'confirm)
                (y-or-n-p (format "Create new node \"%s\"? "
                         child)))))
       (org-refile-new-child parent-target child)))
    (user-error "Invalid target location")))))

#+END_EXAMPLE


* aliases
#+begin_src emacs-lisp
(defalias 'affe-grep-current-project 'affe-grep)
(defalias 'consult-grep-current-project 'consult-grep)


(defalias 'affe-find-filenames-and-folder-names 'affe-find)
(defalias 'consult-find-filenames-and-folder-names 'consult-find)

(defalias 'counsel-google 'counsel-search)
(defalias 'google-counsel-Google-with-autosuggest 'counsel-search)
#+end_src


* ignore unresolvable links
Instead of canceling export. So that I can export org-roam nodes if I want to.

** my own attempts to fix this. Second one worked
#+begin_SRC emacs-lisp
(use-package org-roam-export
  :defer)

(defun org-export-id-link-removal (backend)
 "Inspired by 'org-attach-expand-links' ，which is in 'org-export-before-parsing-functions' "
 (save-excursion
  (while (re-search-forward "id:" nil t)
   (let ((link (org-element-context)))
    (if (and (eq 'link (org-element-type link))
         (string-equal "id"
                (org-element-property :type link)))
      (let ((description (and (org-element-property :contents-begin link)
                  (buffer-substring-no-properties
                   (org-element-property :contents-begin link)
                   (org-element-property :contents-end link))))
         )
       (goto-char (org-element-property :end link))
       (skip-chars-backward " \t")
       (delete-region (org-element-property :begin link) (point))
       (insert description))
     )))))

(add-to-list 'org-export-before-parsing-functions #'org-export-id-link-removal)
#+END_SRC


* org-agenda
#+begin_src emacs-lisp
;; (setq org-agenda-files '("/Users/jay/dropbox/roam/notes"))
#+end_src

* org-attach
#+begin_src emacs-lisp

(setq org-attach-auto-tag "ATTACHMENTS")
(setq org-attach-id-dir "/Users/jay/dropbox/roam/attachments")
(defun org-roam-show-attachments (node)
  (when-let ((id (org-roam-node-id node))
             (folder (org-attach-dir-from-id id t))
             (attached-files (org-attach-file-list folder)))
    (magit-insert-section (org-roam-show-attachments)
      (magit-insert-heading "Attached Files")
      (dolist (file attached-files)
        (insert (org-roam-fontify-like-in-org-mode
                 (format " - [[file:%s/%s][%s]]\n" folder file file))))
      (insert "\n"))))
#+end_src

** org unique ID method
Source: [[https://taonaw-blog.netlify.app/2022-03-13/][Org ID, Org Attach & Better Folder Names · The Art of Not Asking Why]]


#+begin_src emacs-lisp
(setq org-id-method 'ts)
(setq org-attach-id-to-path-function-list
 '(org-attach-id-ts-folder-format
  org-attach-id-uuid-folder-format))
#+end_src

** Emojify
#+begin_src emacs-lisp
(use-package emojify
:defer
:hook (after-init . global-emojify-mode)
 :bind (:map key-minor-mode-map
     ("C-s-SPC" . emojify-insert-emoji))
 :custom
 (emojify-download-emojis-p t)
 (emojify-emoji-styles '(unicode)))
#+end_SRC


* org-roam browsing history
#+begin_src emacs-lisp
(winner-mode +1)
(define-key winner-mode-map (kbd "s-[") #'winner-undo)
(define-key winner-mode-map (kbd "s-]") #'winner-redo)
#+end_src


* deft
#+begin_EXAMPLE emacs-lisp
(use-package deft
:defer
:after org
 :bind
 ("s-k d e" . deft)
 :custom
 (deft-recursive t)
 (deft-use-filter-string-for-filename t)
 (deft-default-extension "org")
 (deft-directory org-roam-directory))
#+END_EXAMPLE


* rg
#+begin_src emacs-lisp


;; (rg-enable-default-bindings)
#+end_src


* deadgrep
#+begin_src emacs-lisp
(use-package deadgrep
  :defer)
(define-key key-minor-mode-map (kbd "s-k d g") 'deadgrep-current-directory)
#+end_src


* search recently used directories
#+begin_src emacs-lisp

 (defun timu/search-org-files ()
  "Grep for a string in the `~/org' using `rg'."
  (interactive)
(consult-ripgrep "~/org" ""))

 (defun timu/search-project-files ()
  "Grep for a string in the `~/projects' using `rg'."
  (interactive)
(consult-ripgrep "~/projects" ""))

#+end_src

* org headings
#+begin_src emacs-lisp

(defun timu/org-go-to-heading (&optional arg)

"Go to an outline heading with `consult-org-heading'. Also move the heading to the top of the buffer with `evil-scroll-line-to-top'"

  (interactive)

(consult-org-heading)
(evil-scroll-line-to-top arg))

#+end_src


* Dired
Here's an adaptation of dired-create-directory. It works the same way, so as well as a plain filename, you can also specify new parent directories (to be created under the current directory) for the file (e.g. foo/bar/filename).


#+BEGIN_SRC emacs-lisp

; dired Settings
(setq dired-clean-up-buffers-too nil
      dired-kept-versions 8)



;; (use-package dired-details+)



;; (defadvice dired-readin
;;     (after dired-after-updating-hook first () activate)
;;   "Sort dired listings with directories first before adding marks."
;;   (mydired-sort)
;;   (let ((dired-details-internal-overlay-list  ())) (dired-details-hide)))

(defcustom dired-details-hidden-string ""
  "*This string will be shown in place of file details and symbolic links."
  :group 'dired-details
  :type 'string)

(defcustom dired-details-initially-hide t
  "*Hide dired details on entry to dired buffers."
  :group 'dired-details
  :type 'boolean)


       (defun my-dired-create-file (file)
         "Create a file called FILE.
  If FILE already exists, signal an error."
         (interactive
          (list (read-file-name "Create file: " (dired-current-directory))))
         (let* ((expanded (expand-file-name file))
                (try expanded)
                (dir (directory-file-name (file-name-directory expanded)))
                new)
           (if (file-exists-p expanded)
               (error "Cannot create file %s: file exists" expanded))
           ;; Find the topmost nonexistent parent dir (variable `new')
           (while (and try (not (file-exists-p try)) (not (equal new try)))
             (setq new try
                   try (directory-file-name (file-name-directory try))))
           (when (not (file-exists-p dir))
             (make-directory dir t))
           (write-region "" nil expanded t)
           (when new
             (dired-add-file new)
             (dired-move-to-filename))))
#+END_SRC

Although I've specified a user-reserved binding in the code, I've actually bound this to _ which on my keyboard layout is the shifted sequence next to +, meaning the keys for "new directory" and "new file" in dired are right next to one another.

** open current directory in Finder
#+begin_src emacs-lisp

(defun timu-baseline-async-shell-command-no-window (command)

 "Do not display the `async-shell-command' COMMAND output buffer.

Credit: https://stackoverflow.com/a/60333836

Credit: https://stackoverflow.com/a/47910509."

 (interactive)

 (let ((display-buffer-alist

     (list (cons

        "\\*Async Shell Command\\*.*"

        (cons #'display-buffer-no-window nil)))))

  (async-shell-command command)))


(defun shell-open-dir ()
 "Open current directory at point with shell command \"open\".
This will open \"Finder.app\" at current location."
 (interactive)
 (timu-baseline-async-shell-command-no-window "open ./" ))


(defun dired-up-directory ()
 "Go up a directory in `dired'."
 (interactive)
 (find-alternate-file ".."))


(defun dired-copy-path-at-point ()
 "Copy the full path of the at `point' to the `kill-ring'.
Credit: https://emacs.stackexchange.com/a/36851/30874"
 (interactive)
 (dired-copy-filename-as-kill 0))



(defun dired-shell-open-dir ()
 "Open current directory at point with shell command \"open\".
This will open \"Finder.app\" at current location."
 (interactive)
 (timu-baseline-async-shell-command-no-window "open ./" ))

#+end_src

** quicklook
#+begin_src emacs-lisp
(defun quicklook ()
 "Open the files at point with shell command \"qlmanage\".
This will display a Quicklook of the file at point in macOS."
 (interactive)
 (setq file (dired-get-file-for-visit))
 (timu-baseline-async-shell-command-no-window
  (concat "qlmanage -p " (shell-quote-argument file) " > /dev/null 2>&1")))
#+end_src

** use dired for directory links
#+BEGIN_SRC emacs-lisp
(add-to-list 'org-file-apps '(directory . emacs))
#+END_SRC

Alternatively you can modify the link description as follows:


[[file+emacs:~/projects][Projects]]

Use this notation in the org mode to create a link:

[[/path/to/file.php::line][string-to-display]]
If you want the file name to be displayed, use just

[[/path/to/file.php::line]]


It will open the link in Emacs with typing C-c C-o.

** touch-file
#+BEGIN_SRC emacs-lisp

    (defun touch-file (file)
    "Create a file called FILE.
  If FILE already exists, signal an error."
    (interactive
    (list (read-file-name "Create file: " (dired-current-directory))))
    (let* ((expanded (expand-file-name file))
      (try expanded)
      (dir (directory-file-name (file-name-directory expanded)))
      new)
     (if (file-exists-p expanded)
      (error "Cannot create file %s: file exists" expanded))
     ;; Find the topmost nonexistent parent dir (variable `new')
     (while (and try (not (file-exists-p try)) (not (equal new try)))
     (setq new try
       try (directory-file-name (file-name-directory try))))
     (when (not (file-exists-p dir))
     (make-directory dir t))
     (write-region "" nil expanded t)
     (when new
     (dired-add-file new)
     (dired-move-to-filename))))
#+END_SRC



*** open recent directories
#+BEGIN_SRC emacs-lisp
;; open recent directory, rquires ivy (part of swiper)
;; borrows from http://stackoverflow.com/questions/23328037/in-emacs-how-to-maintain-a-list-of-recent-directories
(defun bjm/ivy-dired-recent-dirs ()
 "Present a list of recently used directories and open the selected one in dired"
 (interactive)
 (let ((recent-dirs
     (delete-dups
     (mapcar (lambda (file)
          (if (file-directory-p file) file (file-name-directory file)))
         recentf-list))))

  (let ((dir (ivy-read "Directory: "
             recent-dirs
             :re-builder #'ivy--regex
             :sort nil
             :initial-input nil)))
   (dired dir))))


;; (define-key key-minor-mode-map (kbd "C-x d") 'bjm/ivy-dired-recent-dirs)
;; c-x C-d runs the command ido-list-directory
#+END_SRC

**** dired-quick-sort
#+BEGIN_SRC emacs-lisp
(use-package dired-quick-sort
  :defer)
#+END_SRC


***** dired
#+begin_src emacs-lisp
;; (define-key dired-mode-map (kbd "<return>") 'dired-find-file-other-window)
#+end_src

****** open in external app
#+begin_src emacs-lisp
(defun timu-dired-open-in-external-app (&optional file)

 "Open the current FILE or Dired marked files in external app.

The app is chosen from your OS's preference.

Credit: http://xahlee.info/emacs/emacs/emacs_dired_open_file_in_ext_apps.html."

 (interactive)

 (let (doIt (myFileList

       (cond

        ((eq major-mode 'dired-mode)

        (dired-get-marked-files))

        ((not file) (list (buffer-file-name)))

        (file (list file)))))

  (setq doIt (if (<= (length myFileList) 30) t

         (y-or-n-p "Open more than 30 files? ")))

  (when doIt

   (cond

    ((string-equal system-type "windows-nt")

    (mapc (lambda (fPath)

        (w32-shell-execute

         "open" (replace-regexp-in-string "/" "\\" fPath t t)))

       myFileList))

    ((string-equal system-type "darwin")

    (mapc (lambda (fPath)

        (shell-command (format "open \"%s\"" fPath)))

       myFileList))

    ((string-equal system-type "gnu/linux")

    (mapc (lambda (fPath)

        (let ((process-connection-type nil))

         (start-process "" nil "xdg-open" fPath))) myFileList))))))

#+end_src


******* dired-preview
#+begin_src sh
(add-to-list 'load-path "/Users/jay/emacs/external-packages/dired-preview")
(require 'dired-preview)

#+end_src


** nvalt
#+begin_src emacs-lisp
(defun nvalt ()
 "Open the directory in dired and run dired-preview."
 (interactive)

 (let ((directory "/Users/jay/Library/Mobile Documents/27N4MQEA55~pro~writer/Documents/"))
  (dired directory)
  (dired-preview-mode)))

#+end_src

* counsel-fd
** Usage
~M-x counsel-fd-dired-jump~ to jump to a subdirectory under current
directory

~M-x counsel-fd-file-jump~ to jump to a file under current directory

#+begin_src emacs-lisp
(use-package counsel-found
  :defer)
#+end_src


* consult-locate
Maybe to replace fasd?

#+begin_src emacs-lisp
(setq consult-locate-args "fasd -t -l -R")
(define-key key-minor-mode-map (kbd "C-x C-l") 'consult-locate)
#+end_src


* source current file
Doesn't work

#+begin_src emacs-lisp
(defun source-current-file ()
 "Source the current file in a shell."
 (interactive)
 (let* ((filename (buffer-file-name))
     (cmd (format "source %s" (shell-quote-argument filename)))
     (output (shell-command-to-string cmd)))
  (message "Output: %s" output)))
#+end_src


* fitness.org
#+begin_src emacs-lisp
;; The fitness.org file calls this function to eval the configuration source
;; block. This is the only function that needs to be defined outside of
;; fitness.org.

(defun ap/org-call-src-block (name)
 ;; Based on <http://kitchingroup.cheme.cmu.edu/blog/2014/08/11/Using-org-mode-outside-of-Emacs-sort-of/>
 ;; This works better than the org-sbe (aka sbe) macro, because it
 ;; calls the block upon expansion, making it difficult to bind to
 ;; a command to run later
 ;; TODO: Use `org-babel-goto-named-src-block'! I guess it's new...or not, it's from 2010!
 (org-with-wide-buffer
  (-when-let (src (org-element-map (org-element-parse-buffer) 'src-block
           (lambda (element)
            (when (string= name (org-element-property :name element))
             element))
           nil ;info
           t ))
   (goto-char (org-element-property :begin src))
   (let ((org-confirm-babel-evaluate nil))
    (org-babel-execute-src-block)))))
#+end_src


* ask me whether to move region or copy region
interactive tool for moving or copying text regions to another window in the Emacs environment. It is functionally correct and appears to be well-structured. Here are a few notes on the provided code.

Global variable initialization: At the start of each Emacs session, a global variable move-or-copy-mode is declared and set to nil. This variable is used to store the user's preference for either moving or copying text regions.

Interactive Mode Selection: The switch-between-move-mode-and-copy-mode function allows the user to specify their preference in an interactive manner. If move-or-copy-mode is nil (which will be true at the start of each session), this function is called to populate move-or-copy-mode with the user's choice.

Move or Copy Implementation: The move-or-copy-region-to-other-window function uses the value stored in move-or-copy-mode to determine whether to move or copy the selected region. If the value is "move", the function kills (cuts) the region and displays a message indicating the number of words moved. If the value is "copy", the function copies the region and displays a message indicating the number of words copied.

Region Handling: The code uses use-region-p to check if a region is currently active (selected). If not, a message is displayed to inform the user that no region is selected.

Text Insertion: After the text region has been either moved or copied, it is yanked (pasted) into the other window. The code also adds a newline character both before and after the inserted text for neat formatting.

First:
Set this varable to nil at the start of every Emacs session, so that switch-between-move-mode-and-copy-mode will prompt me about my preference:

#+begin_src emacs-lisp
(defvar move-or-copy-mode nil)
#+end_src

The first time I call move-or-copy-region-to-other-window, the unless statement sees that move-or-copy-mode is nil, so it calls select-copy-mode-or-move-mode.

The next time I call move-or-copy-region-to-other-window within the same Emacs session, move-or-copy-mode is no longer nil, because it now contains my previous choice. So the unless statement doesn't trigger, and select-copy-mode-or-move-mode is not called, hence I'm not prompted for my preference again.

When a new Emacs session starts, move-or-copy-mode is reset to nil, so I will again be prompted for Ir preference the first time I call move-or-copy-region-to-other-window in the new session.

Emacs sessions are independent of each other, so global variables like move-or-copy-mode don't persist across sessions.


#+begin_src emacs-lisp
(defun select-move-mode-or-copy-mode ()
 (interactive)
 (setq move-or-copy-mode
    (completing-read "Would you like to move this region or just copy it? (move or copy): " '("Move" "Copy"))))

(defun move-or-copy-region-to-other-window (start end)
 "Move or copy selected text to other window based on move-or-copy-mode."
 (interactive "r")
 (unless move-or-copy-mode
  (select-move-mode-or-copy-mode))
 (let ((count (count-words-region start end)))
 (save-excursion
  (if (string= move-or-copy-mode "Move")
   (progn
   (kill-region start end)
   (message "Moved %s words" count))
  (progn
   (copy-region-as-kill start end)
   (message "Copied %s words" count)))
  (other-window 1)
  (newline)
  (yank)
  (newline)
  (other-window -1))))

#+end_src



* refile or org-roam-refile
#+begin_src emacs-lisp
(defvar refile-or-roam-refile-mode nil)

(defun select-refile-mode ()
 (interactive)
 (setq refile-or-roam-refile-mode
    (completing-read "Would you like to refile this region or subtree to Org file or Org-roam file? (org-refile or org-roam-refile): " '("org-refile" "org-roam-refile"))))

(defun choose-refile-method-and-refile ()
 "Choose the refile method and refile the current subtree or region based on refile-or-roam-refile-mode."
 (interactive)
 (unless refile-or-roam-refile-mode
  (select-refile-mode))
 (if (use-region-p)
   (save-excursion
    (if (string= refile-or-roam-refile-mode "org-refile")
      (progn
       (refile-region-or-subtree)
       (message "Refiled to Org file"))
     (progn
      (org-roam-refile-region-or-subtree)
      (message "Refiled to Org-roam file"))))
  (let ((current-heading (org-get-heading t t t t)))
   (save-excursion
    (if (string= refile-or-roam-refile-mode "org-refile")
      (progn
       (refile-region-or-subtree)
       (message "Refiled to Org file %s" current-heading))
     (progn
      (org-roam-refile-region-or-subtree)
      (message "Refiled to Org-roam file %s" current-heading)))))))

#+end_src
* disable Olivetti on split
#+begin_SRC emacs-lisp
(defun activate-olivetti-in-split ()
 (when (not (bound-and-true-p disable-olivetti-auto-toggle))
  (if (< (window-width) 80)
    (olivetti-mode -1)
   (olivetti-mode 1))))


(add-hook 'org-mode-hook (lambda ()
              (add-hook 'window-configuration-change-hook 'activate-olivetti-in-split nil t)))

#+END_SRC

* helpful
[[https://github.com/Wilfred/helpful][Wilfred/helpful: A better Emacs *help* buffer]]

replacing Emacs built-in documenation
#+begin_SRC emacs-lisp
;; Note that the built-in `describe-function' includes both functions
;; and macros. `helpful-function' is functions only, so we provide
;; `helpful-callable' as a drop-in replacement.
(global-set-key (kbd "M-h f") #'helpful-callable)

(global-set-key (kbd "M-h v") #'helpful-variable)
;; (global-set-key (kbd "M-h k") #'helpful-key)
(global-set-key (kbd "M-h x") #'helpful-command)

;; Lookup the current symbol at point. C-c C-d is a common keybinding
;; for this in lisp modes.
(global-set-key (kbd "C-c C-d") #'helpful-at-point)

;; Look up *F*unctions (excludes macros).
;;
;; By default, C-h F is bound to `Info-goto-emacs-command-node'. Helpful
;; already links to the manual, if a function is referenced there.
(global-set-key (kbd "M-h F") #'helpful-function)
#+end_SRC


* workgroups
[[https://github.com/pashinin/workgroups2][pashinin/workgroups2: Workgroups2 - Emacs session manager]]

** Usage
Use ~M-x wg-create-workgroup~ to save save window&buffer layout as a
work group.

Use ~M-x wg-open-workgroup~ to open an existing work group.

Use ~M-x wg-kill-workgroup~ to delete an existing work group.

*** Enable minor mode ~workgroups-mode~ (OPTIONAL)
Put below line at the bottom of ~.emacs~,

#+begin_example
(workgroups-mode 1)
#+end_example


* scroll
#+begin_src emacs-lisp
;; (global-yascroll-bar-mode 1)
#+end_src

* CTRLF
[[https://github.com/radian-software/ctrlf#customization][radian-software/ctrlf: ⌨️ Emacs finally learns how to ctrl+F.]]

Disabling because [[https://github.com/radian-software/ctrlf/issues/130][there's no isearch-repeat-forward]]? Update: found it.


#+begin_SRC emacs-lisp
(use-package ctrlf
  :defer)
;; (ctrlf-mode +1)
;; (define-key key-minor-mode-map (kbd "s-f") 'ctrlf-forward-default)
(define-key ctrlf-mode-map (kbd "s-g") 'ctrlf-next-match)
;; (define-key ctrlf-mode-map (kbd "s-g") 'ctrlf-next-match)
#+END_SRC


* ace-link
[[https://github.com/abo-abo/ace-link][abo-abo/ace-link: Quickly follow links in Emacs]]
In Help buffers, single key ~o~ to follow links

** Usage
Just press ~o~ when you're
in ~Info-mode~ or ~help-mode~ or ~woman-mode~ or ~eww-mode~ or ~compilation-mode~.

Here's a screencast of browsing Info using ~ace-link-info~:


#+begin_src emacs-lisp
(ace-link-setup-default)
#+end_src

** mwim
[[https://github.com/alezost/mwim.el][alezost/mwim.el: Move to the beginning/end of line, code or comment]]

Smart jump to beginning / end of lines.

#+begin_src emacs-lisp
(global-set-key (kbd "C-a") 'mwim-beginning)
(global-set-key (kbd "C-e") 'mwim-end)
#+end_src


* delete file
#+begin_src emacs-lisp
(defun delete-visited-file (buffer-name)
 "Delete the file visited by the buffer named BUFFER-NAME."
 (interactive "Delete file visited by buffer ")
 (let* ((buffer (get-buffer buffer-name))
     (filename (buffer-file-name buffer)))
  (when buffer
   (when (and filename
         (file-exists-p filename))
    (delete-file filename))
   (kill-buffer buffer))))
(defalias 'crux-delete-buffer-and-file #'delete-visited-file)

#+end_src

* jinx
#+begin_EXAMPLE emacs-lisp
(use-package jinx
:defer)
(dolist (hook '(text-mode-hook org-mode-hook conf-mode-hook))
 (add-hook hook #'jinx-mode))
#+END_EXAMPLE


* ox-timeline
#+begin_src emacs-lisp
(use-package ox-timeline

:config
 (setq org-timeline-source-url "/Users/jay/Dropbox/github/incandescentman.github.io/timeline/dist"))

(defun org-timeline-export-to-html-and-open ()
 "Export the current Org file to HTML using `org-timeline-export-to-html', then open the HTML file."
 (interactive)
 (let ((html-file (org-timeline-export-to-html)))
  (when html-file
   (browse-url (concat "file://" (expand-file-name html-file))))))

#+end_src


* ox-clip
#+begin_src emacs-lisp
'(ox-clip-osx-cmd
  "pandoc -f html -t markdown - | grep -v \"^:::\" | sed 's/{#.*}//g' | pbcopy")
(defalias 'copy-as-markdown 'ox-clip-formatted-copy)
#+end_src


* debug recentf
#+begin_src emacs-lisp
(defadvice recentf-save-list (around debug-recentf-save-list activate)
 (message "Saving recentf list...")
 ad-do-it
 (message "Saved recentf list"))

(defun my-update-recentf ()
 (copy-file "/Users/jay/emacs/recentf/recentf" "/Users/jay/.emacs.d/.cache/recentf" t))

(defadvice configuration-layer/update-packages
  (before my-update-recentf-before-update-packages activate)
 (copy-file "/Users/jay/emacs/recentf/recentf" "/Users/jay/.emacs.d/.cache/recentf" t))


#+end_src


* unpair <
If all else fails, as a last resort, you could use a keybinding to insert a "<" without triggering the auto-pairing. For instance:

#+begin_example emacs-lisp
(global-set-key (kbd "<") (lambda () (interactive) (insert "<")))
#+end_example

This tells Emacs to simply insert a "<" whenever you press that key, bypassing any other logic that might be attached to it.

* global Olivetti mode
#+begin_src emacs-lisp
(define-globalized-minor-mode olivetti-global-mode olivetti-mode
 (lambda ()
  (unless (minibufferp)
   (olivetti-mode 1))))

(olivetti-global-mode)
#+end_src


* org-mode timestamp format
#+begin_src emacs-lisp
(setq org-time-stamp-custom-formats '("<%a %m/%e/%Y>" . "<%a %B %e %l:%M %p>"))
(setq-default org-display-custom-times nil)
#+end_src

* smartparens
#+begin_src emacs-lisp
(require 'smartparens)
(smartparens-mode 1)
(smartparens-global-mode 1)

(setq sp-escape-quotes-after-insert nil)
#+end_src


* archive tasks based on date
#+begin_src emacs-lisp

;; (setq org-archive-location
;;  (concat "/Users/jay/Dropbox/roam/notes/archive/"
;;   (format-time-string "%Y-%m" (current-time)) "-%s::* "(format-time-string "%Y-%m-%d" (current-time))))

(defun my/org-archive-file ()
 "Dynamically set `org-archive-location' based on the current file directory."
 (let* ((current-file-dir (file-name-directory (buffer-file-name)))
     (archive-dir (concat current-file-dir "archive/"))
     (archive-file (concat archive-dir
                (format-time-string "%Y-%m" (current-time))
                "-%s::"
                (format-time-string "%Y-%m-%d" (current-time)))))
  (setq org-archive-location archive-file)))

;; Run the above function before every org-archive operation
(add-hook 'org-archive-hook 'my/org-archive-file)


#+end_src


* unfill-region-keep-formatting
#+begin_src emacs-lisp
(defun unfill-paragraph-keep-formatting (start end)
 "Unfill the region, but preserve plain-text lists and org-mode SCHEDULED tasks."
 (interactive "*r")
 (let ((fill-column (point-max)))
  (unfill-paragraph start end)))

(defun should-unfill-p (start end)
 "Determine whether the region should be unfilled."
 (save-excursion
  (goto-char start)
  (not (or (looking-at "^\\s-*\\([-*+]\\|[0-9]+[.)]\\)\\s-+") ;; plain-text list
       (looking-at "^\\s-*SCHEDULED:")           ;; org-mode SCHEDULED task
       (looking-at "^\\s-*DEADLINE:")            ;; org-mode DEADLINE
       ))))


(defun unfill-region-smart (start end)
 "Unfill the region, but preserve plain-text lists and org-mode SCHEDULED tasks."
 (interactive "*r")
 (let ((pos start))
  (while (< pos end)
   (let ((next-pos (or (next-single-property-change pos 'hard) end)))
    (when (should-unfill-p pos next-pos)
     (unfill-region-keep-formatting pos next-pos))
    (setq pos next-pos)))))



#+end_src

* string to list
#+begin_src emacs-lisp
(defun region-to-numbered-list (start end)
  "Turn a region into a numbered list."
  (interactive "r")
  (let* ((s (buffer-substring-no-properties start end))
         (split-strings (split-string s "\\([0-9]+\\. \\)" t))
         (trimmed-strings (mapcar 'string-trim split-strings))
         (filtered-strings (cl-remove-if (lambda (x) (string= x "")) trimmed-strings))
         (numbered-strings
          (cl-loop for str in filtered-strings and i from 1
                   collect (concatenate 'string (number-to-string i) ". " str))))
    (delete-region start end)
    (insert (mapconcat 'identity numbered-strings "\n"))))
#+end_src

* indirect buffers

** clone-indirect-buffer-new-window-without-focus
#+begin_src emacs-lisp
(defun clone-indirect-buffer-new-window-without-focus ()
  "Clone the current buffer to another window *but keep focus* in the original window."
  (interactive)
  (let ((original-window (selected-window)))
    ;; This built-in command automatically creates an indirect buffer
    ;; for the current buffer, displays it in another window,
    ;; and SELECTS that new window.
    (clone-indirect-buffer-other-window nil t)

    ;; If you want to narrow in Org mode:
    (when (derived-mode-p 'org-mode)
      (org-narrow-to-subtree))

    ;; Now go back to the original window:
    (select-window original-window)))
#+end_src

** clone-indirect-buffer-new-window-and-focus
#+begin_src emacs-lisp
(defun clone-indirect-buffer-new-window-and-focus ()
  "Clone the current buffer to another window and KEEP focus in the new window."
  (interactive)
  ;; This will automatically create and select the new indirect buffer in another window
  (clone-indirect-buffer-other-window nil t)

  ;; Narrow if you wish:
  (when (derived-mode-p 'org-mode)
    (org-narrow-to-subtree))
  ;; Because clone-indirect-buffer-other-window already selects the new buffer,
  ;; you don't need to do anything else to maintain focus there.
)
#+end_src



* org-inline-tags
#+BEGIN_EXAMPLE emacs-lisp
(defface org-inline-tags-face
 '((t (:foreground "orange" :weight bold)))
 "Face for custom inline tags in plain list items.")

(font-lock-add-keywords 'org-mode
 '(("#\\(\\w+\\(-\\w+\\)*\\)" 0 'org-inline-tags-face)))


;;;***autoload
(defun org-inline-tags-search (tag)
 "Search for TAG in the current org file."
 (org-search-view nil (concat "\\" "#" tag)))

;;;***autoload
(defun org-inline-tags-search-buffer (tag)
 "Search for TAG in the current buffer."
 (consult-line (concat "\\" "#" tag)))

;;;***autoload
(defun org-inline-tags-search-project-wide ()
 "Search for inline TAG project-wide using consult-ripgrep if available, otherwise use occur."
 (interactive)
 (if (fboundp 'consult-ripgrep)
   (progn
    (message "Enter tag to search for (Please go to the beginning of the line and add a \\ before the # sign)")
    (sit-for 0.5) ; pause for 0.5 to 2 seconds, whatever you waaant
    (consult-ripgrep nil))
  (occur (read-string "Enter tag to search for (Please go to the beginning of the line and add a \\ before the # sign): #"))))

(defun org-inline-tags-return (&optional indent)
 "Check if point is on an inline tag, and if so, search for that tag.
Otherwise, call `org-return'."
 (interactive)
 (let ((tag (with-syntax-table (let ((st (make-syntax-table)))
                 (modify-syntax-entry ?# "_" st)
                 st)
        (thing-at-point 'symbol))))
  (if (and tag (string-prefix-p "#" tag))
    (org-inline-tags-search-project-wide)
   (smart-return indent))))



;;;***autoload
(defun org-inline-tags-insert ()
 "Prompt the user to choose a tag and insert it at the current cursor position."
 (interactive)
 (let* ((tag-alist '((?r . "review")
           (?b . "book")
           (?t . "todo")
           (?u . "urgent")
           (?p . "tweet")
           (?i . "insight")
           (?c . "cook-ideas-over-time")))
     (selected-key (read-char "Choose a tag:\n
r: review
b: book
t: todo
u: urgent
p: tweet
i: insight
c: cook-ideas-over-time\n")))
  (setq selected-tag (cdr (assoc selected-key tag-alist)))
  (if selected-tag
    (insert (format " #%s" selected-tag))
   (error "Invalid tag selection"))))


;; for org-html-export
(defun my-org-add-class-to-hash-tags (text backend info)
  "Add class to words starting with a '#' in HTML export."
  (when (org-export-derived-backend-p backend 'html)
    (replace-regexp-in-string "\\<#\\w+\\>"
                              "<span class=\"hash-tag\">\\&</span>"
                              text)))

(add-to-list 'org-export-filter-plain-text-functions
    'my-org-add-class-to-hash-tags)




;; (define-key org-mode-map (kbd "<return>") 'org-inline-tags-return)

;; (define-key key-minor-mode-map (kbd "<return>") 'org-inline-tags-return)

;; (define-key key-minor-mode-map (kbd "s-:") 'insert-inline-tag)
;; (define-key key-minor-mode-map (kbd "s-;") 'search-for-inline-tag-project-wide)

#+END_EXAMPLE


** auto-link notes
Doesn't work.

Development:
https://chat.openai.com/share/255cbba9-238a-4b8c-ae8e-76a2aadf70fe

#+begin_src emacs-lisp
(defun org-roam-auto-link-buffer ()
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (while (not (eobp))
      (let* ((word (thing-at-point 'word 'no-properties))
             (node (car (org-roam-db-query [:select [id] :from nodes :where (= title $s1)] word))))
        (if node
            (progn
              (push-mark)
              (forward-word)
              (let ((region (list (mark) (point))))
                (org-roam-link-set-region (car region) (cadr region) node))))))))
#+end_src


* New org-roam
#+begin_src emacs-lisp
(defun kb/find-node-backlink (arg &optional node choices)
 "Navigate notes by link. With universal ARG try to use only to navigate the tags of the current note. Optionally takes a selected NODE and filepaths CHOICES."
 (interactive "P")
 (let* ((depth (if (numberp arg) arg 1))
     (choices
     (or choices
       (when arg
        (-map #'org-roam-backlink-target-node (org-roam-backlinks-get (org-roam-node-from-id (or (ignore-errors (org-roam-node-id node))
                                                     (org-id-get-create))))))))
     (all-notes (org-roam-node--completions))
     (completions
     (or (--filter (-contains-p choices (cdr it)) all-notes) all-notes))
     (next-node
     ;; taken from org-roam-node-read
     (let* ((nodes completions)
         (node (completing-read
            "Node: "
            (lambda (string pred action)
             (if (eq action 'metadata)
               '(metadata
                (annotation-function . (lambda (title)
                             (funcall org-roam-node-annotation-function
                                 (get-text-property 0 'node title))))
                (category . org-roam-node))
              (complete-with-action action nodes string pred))))))
      (or (cdr (assoc node nodes))
        (org-roam-node-create :title node)))
     )
     )
  (if (equal node next-node)
    (org-roam-node-visit node)
   (kb/find-node-backlink nil next-node (cons next-node (-map #'org-roam-backlink-source-node (org-roam-backlinks-get next-node))))
   )))
#+end_src

* fontify checkboxes on org export to HTML
[[https://emacs.stackexchange.com/questions/33382/replace-checkbox-with-glyph-via-font-lock][org mode - replace checkbox with glyph via font-lock - Emacs Stack Exchange]]
#+begin_src emacs-lisp
(setq org-html-checkbox-type 'unicode)
(setq org-html-checkbox-types
 '((unicode (on . "<span class=\"task-done\">&#x2611;</span>")
   (off . "<span class=\"task-todo\">&#x2610;</span>")
   (trans . "<span class=\"task-in-progress\">&#x25eb;</span>"))))
#+end_src



* Skim PDF: Capture page title correctly
In org-mode for Emacs, we often want to create links to specific resources. One such resource could be a PDF file that is being viewed in Skim.app, a popular PDF reader for macOS. The initial implementation of this functionality allowed for the creation of a link directly to a specific page in a PDF file. However, the link was not easily readable, as it only contained the file path and the page number.

We've updated this functionality to enhance the readability and usability of these links. Now, the link will also display the title of the file (which is generally more readable than a filepath). The link still points to the specific page in the PDF file, but when viewed in org-mode, it will be displayed with the title of the PDF file.

If I encounter more errors, pls refer to this:
https://chat.openai.com/share/84fdc7cc-f6d1-410b-85e8-efffb249ed36

#+begin_SRC emacs-lisp

(defun org-mac-link-skim-insert-page ()
  "Insert the link to the page in the Skim.app. Include the page number.

  This function calls the org-mac-link-skim-get-page function to get
  a formatted org-mode link to the current page in the Skim.app PDF file.
  The resulting link is then inserted at the current point."
  (interactive)
  (insert (org-mac-link-skim-get-page)))




(defun org-mac-link-applescript-get-skim-page-link ()
 "AppleScript to get the link to the page in the Skim.app."
 (org-mac-link-do-applescript
 (concat
 "tell application \"Skim\"\n"
 "set theDoc to front document\n"
 "set theTitle to (name of theDoc) as string\n"
 "set thePath to (path of theDoc) as string\n"
 "set thePage to (get index of current page of theDoc) as string\n"
 "set theSelection to selection of theDoc\n"
 "set theContent to contents of (get text of theSelection) as string\n"
 "if theContent is missing value or theContent is \"\" then\n" ;; Check for missing value or empty string
 " set theContent to theTitle & \", p. \" & thePage\n"
 "end if\n"
 "if theTitle ends with \".pdf\" then\n" ;; Check for .pdf at the end of the title
 " set theTitle to text 1 thru -5 of theTitle\n" ;; Remove the last 4 characters (.pdf)
 "end if\n"
 "set theLink to \"skim://\" & thePath & \"::\" & thePage\n" ;; Removed extra space before ::split::
 "end tell\n"
 "return theLink & \" ::split::\" & theTitle & \", p. \" & thePage as string\n"))) ;; Separated link and content


(defun org-mac-link-skim-get-page ()
 "Get the link to the page in the Skim.app."
 (interactive)
 (message "Applescript: Getting Skim page link...")
 (let* ((result (org-mac-link-applescript-get-skim-page-link))
   (result-parts (split-string result "::split::"))
   (link (car result-parts))
   (description (cadr result-parts)))
 ;; Remove starting and ending quotes from the link
 (when (string-prefix-p "\"" link)
  (setq link (substring link 1)))
 (when (string-suffix-p "\"" link)
  (setq link (substring link 0 -1)))
 ;; Remove leading and trailing whitespace from the link
  (setq link (string-trim link))
 ;; Remove starting and ending quotes from the description
 (when (string-prefix-p "\"" description)
  (setq description (substring description 1)))
 (when (string-suffix-p "\"" description)
  (setq description (substring description 0 -1)))
;; Trim leading and trailing whitespace from the description
 (setq description (string-trim description))
 ;; Remove .pdf from the description
 (when (string-suffix-p ".pdf" description)
  (setq description (substring description 0 -4)))
 ;; Replace underscores with spaces in the description
(setq description (replace-regexp-in-string "_" " " description))

 ;; Format the link
 (format "[[%s][%s]]" link description))) ;; Org-mode link format

(defun org-mac-link-skim-get-document ()
 "Get the link to the document in the Skim.app, without page number."
 (interactive)
 (message "Applescript: Getting Skim document link...")
 (let* ((result (org-mac-link-applescript-get-skim-page-link))
     (result-parts (split-string result "::split::"))
     (link (car result-parts))
     (description (cadr result-parts)))
  ;; Remove starting and ending quotes from the link
  (when (string-prefix-p "\"" link)
   (setq link (substring link 1)))
  (when (string-suffix-p "\"" link)
   (setq link (substring link 0 -1)))
  ;; Remove leading and trailing whitespace from the link
  (setq link (string-trim link))
  ;; Remove starting and ending quotes from the description
  (when (string-prefix-p "\"" description)
   (setq description (substring description 1)))
  (when (string-suffix-p "\"" description)
   (setq description (substring description 0 -1)))
;; Trim leading and trailing whitespace from the description
 (setq description (string-trim description))
  ;; Remove .pdf from the description
  (when (string-suffix-p ".pdf" description)
   (setq description (substring description 0 -4)))
  ;; Replace underscores with spaces in the description
(setq description (replace-regexp-in-string "_" " " description))
  ;; Remove page number from the description
  (when (string-match ", p\\. \\([0-9]+\\)" description)
   (setq description (replace-match "" nil nil description)))
  ;; Format the link
  (format "[[%s][%s]]" link description)))

(defun org-mac-link-skim-insert-document ()
 "Insert the link to the document in the Skim.app, without page number."
 (interactive)
 (insert (org-mac-link-skim-get-document)))

;; Skim insert link to PDF (or with C-u prefix, insert link to PDF including page number)
(defun org-mac-link-skim-insert (&optional arg)
 "Insert a link to the current Skim document or page.
With a universal argument, insert a link to the current page including page number."
 (interactive "P")
 (if arg
   (org-mac-link-skim-insert-page)
  (org-mac-link-skim-insert-document)))

#+END_SRC


Fixed and working:
https://chat.openai.com/share/84fdc7cc-f6d1-410b-85e8-efffb249ed36

* org-timeblocking
#+begin_EXAMPLE emacs-lisp
(add-to-list 'load-path "/users/jay/emacs/external-packages/org-timeblock/")
(use-package org-timeblock
:defer)
#+END_EXAMPLE

* later list
#+begin_src emacs-lisp
(defun later-list ()
 (interactive)
 (find-file "/Users/jay/Dropbox/roam/notes/20230728235900-later_list.org"))
#+end_src

* red bold
#+begin_src emacs-lisp
(defun redbold ()
  (interactive)
  (custom-set-faces
'(bold ((t (:inherit font-lock-warning-face :foreground "red" :weight bold)))))
  )

(add-hook 'org-mode-hook (lambda ()
       (redbold)))

#+end_src


* Claire share
#+begin_src emacs-lisp
(defun claire-share-export-subtree-to-html ()
 (interactive)
 (let* ((title (file-name-sans-extension (buffer-name)))
     (path "/users/jay/dropbox/roam/claire/")
     (export-line (concat "#+EXPORT_FILE_NAME: " path title ".html")))
  (save-excursion
   (goto-char (point-min))
   (forward-line 3)
   (unless (looking-at "#\\+EXPORT_FILE_NAME:")
    (insert (concat export-line "\n"))))
  (org-export-dispatch)))

#+end_src


* embark vertico
#+begin_src emacs-lisp
(with-eval-after-load 'vertico
(define-key key-minor-mode-map (kbd "C-M-S-s-o") 'embark-act)
;; (define-key vertico-map (kbd "M-o") 'embark-act)
)

#+end_src

* copy-region-as-kill-and-push-to-clipboard

#+begin_src emacs-lisp
(defun copy-region-as-kill-and-push-to-clipboard (beg end)
  "Copy the region as kill and push it to the macOS clipboard.
BEG and END define the region to copy."
  (interactive "r")
  (copy-region-as-kill beg end)
  (push-kill-ring-pasteboard-to-MacOS-clipboard))
#+end_src


#+begin_src emacs-lisp
;; Simpler version - directly copies clipboard to kill ring
(defun clipboard-to-kill-ring ()
"Copies clipboard contents directly to kill ring."
(interactive)
(let ((clipboard-content (shell-command-to-string "pbpaste")))
(unless (string-equal clipboard-content "")
(kill-new clipboard-content))))

;; More complex version - strips trailing newline
(defun clipboard-to-kill-ring-and-strip-trailing-newlines ()
"Strips trailing newline from clipboard before copying to kill ring."
(interactive)
(let ((clipboard-content (shell-command-to-string "pbpaste")))
;; Check for non-empty clipboard contents
(when clipboard-content

  ;; Strip trailing newline if present
  (setq clipboard-content
        (if (string-match "\n\\'" clipboard-content)
            (replace-match "" t t clipboard-content)
          clipboard-content))

   ;; Copy to kill ring unless empty
   (unless (string-equal clipboard-content "")
     (kill-new clipboard-content)))))
#+end_src


* switch two classic keybindings
#+begin_src emacs-lisp
(define-key key-minor-mode-map (kbd "M-%") 'eval-expression)
(define-key key-minor-mode-map (kbd "M-:") 'query-replace)
#+end_src


* TOC in org file
[[https://github.com/alphapapa/org-make-toc][alphapapa/org-make-toc: Automatic tables of contents for Org-mode files]]

Usage:
A document may have any number of tables of contents (TOCs), each of
which may list entries in a highly configurable way.

To make a basic TOC, follow these steps:

1. Choose a heading to contain a TOC and move the point to it.
2. Run command ~org-make-toc-insert~, which inserts
   a ~:CONTENTS:~ drawer and sets TOC properties. Set
   the ~include~ property to ~all~.
3. Run the command ~org-make-toc~ to update all TOCs in the document.

Use command ~org-make-toc-set~ to change TOC properties for the entry at
point with completion.

#+begin_EXAMPLE emacs-lisp
(use-package org-make-toc
:defer
:config
 ;; Add 'org-make-toc-mode' to 'org-mode-hook'
 ;; This ensures 'org-make-toc-mode' is enabled every time 'org-mode' is activated
 (add-hook 'org-mode-hook #'org-make-toc-mode))
#+END_EXAMPLE


* display online images
** 1
Display online images in new buffer on return

#+begin_src emacs-lisp
(use-package url
  :defer)

#+end_src

** 2
[[https://emacs.stackexchange.com/questions/42281/org-mode-is-it-possible-to-display-online-images][Org mode: is it possible to display ONLINE images? - Emacs Stack Exchange]]

And again we have a use-case for image data not stored on harddisk. (The other two use-cases are [[https://emacs.stackexchange.com/questions/41544/is-it-possible-to-include-a-base64-image-in-org-file][base64 encoded images in org buffers]] and [[https://emacs.stackexchange.com/q/38098/2370][displaying previews of youtube videos]].)

Get [[https://github.com/TobiasZawada/org-yt][~org-yt~]] and paste the following elisp code into your [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Init-File.html][init-file]].

After evaluating your init-file you can use links analog to the example:

~[[imghttp://tn-home.de/Pic/tn-home.png]]~




#+begin_src emacs-lisp

(load "/Users/jay/emacs/external-packages/org-yt/org-yt.el")
(require 'org-yt)

(defun org-image-link (protocol link _description)
 "Interpret LINK as base64-encoded image data."
 (cl-assert (string-match "\\`img" protocol) nil
       "Expected protocol type starting with img")
 (let ((buf (url-retrieve-synchronously (concat (substring protocol 3) ":" link))))
  (cl-assert buf nil
        "Download of image \"%s\" failed." link)
  (with-current-buffer buf
   (goto-char (point-min))
   (re-search-forward "\r?\n\r?\n")
   (buffer-substring-no-properties (point) (point-max)))))

(org-link-set-parameters
 "imghttp"
 :image-data-fun #'org-image-link)

(org-link-set-parameters
 "imghttps"
 :image-data-fun #'org-image-link)
#+end_src


* Insert image link from clipboard
#+begin_src emacs-lisp
(defun insert-image-link-from-clipboard ()
  "Inserts an org-mode image link using the clipboard content as the image URL."
  (interactive)
  (let* ((mac-clipboard-content (gui-selection-value))
         (clip-content (if mac-clipboard-content
                           (progn
                             (kill-new mac-clipboard-content)
                             mac-clipboard-content)
                         (substring-no-properties (current-kill 0)))))
    (if clip-content
        (if (string-match-p "^http" clip-content)
            (progn
              (insert (format "[[img%s]]" clip-content))
              (org-display-inline-images))
          (message "Clipboard content does not start with 'http'."))
      (message "Clipboard is empty."))))
#+end_src

* Insert local file link from clipboard
#+begin_SRC emacs-lisp
(defun insert-local-file-link-from-clipboard ()
  "Inserts an org-mode link using the clipboard content as the file path."
  (interactive)
  (clipboard-to-kill-ring)
  (let* ((clip-content (substring-no-properties (current-kill 0)))
         (file-name (file-name-nondirectory clip-content))
         (file-name-base (file-name-sans-extension file-name))
         (hyphen-and-underscore-replaced (replace-regexp-in-string "[-_]" " " file-name-base))
         (no-leading-numbers (replace-regexp-in-string "^[0-9]*" "" hyphen-and-underscore-replaced))
         (start-pos (point)))
    (insert (format "[[file+emacs:%s][📄 %s]]" clip-content (string-trim no-leading-numbers)))
    (goto-char start-pos)
    (search-forward "[[" nil t)
    (search-forward "[" nil t)
    (let ((title-start (point)))
      (search-forward "]" nil t)
      (backward-char)
      (capitalize-region title-start (point)))
    (goto-char (+ 2 start-pos))
    (search-forward "[" nil t)
    (search-forward "]" nil t))
  nil)  ; Explicitly return nil
#+END_SRC

* Insert directory link from clipboard
#+begin_SRC emacs-lisp
(defun insert-directory-link-from-clipboard ()
 "Inserts an org-mode directory link using the clipboard content as the directory path."
 (interactive)
 (clipboard-to-kill-ring)
 (let* ((clip-content (substring-no-properties (current-kill 0)))
     (dir-name (file-name-nondirectory (directory-file-name clip-content)))
     (hyphen-and-underscore-replaced (replace-regexp-in-string "[-_]" " " dir-name))
     (start-pos (point)))
  (insert (format "[[%s][📁 %s]]" clip-content (string-trim hyphen-and-underscore-replaced)))
  (goto-char start-pos)
  (search-forward "[[" nil t)
  (search-forward "[" nil t)
  (let ((title-start (point)))
   (search-forward "]" nil t)
   (backward-char)
   (capitalize-region title-start (point)))
  (goto-char (+ 2 start-pos))
  (search-forward "[" nil t)
  (search-forward "]" nil t))
 nil) ; Explicitly return nil
 #+END_SRC

* save frame size and position
#+begin_EXAMPLE emacs-lisp

(defun save-frame-size-and-position ()
 "Save the current frame's size and position."
 (interactive)
 (setq saved-frame-parameters
    (list (cons 'left (frame-parameter nil 'left))
       (cons 'top (frame-parameter nil 'top))
       (cons 'width (frame-parameter nil 'width))
       (cons 'height (frame-parameter nil 'height)))))

(defun restore-frame-size-and-position ()
 "Restore the frame's size and position."
 (interactive)
 (when saved-frame-parameters
  (modify-frame-parameters nil saved-frame-parameters)))

(defun restore-frame-to-external-minotaur-two-thirds-size-and-position ()
  "Restore the frame's size and position to specific values."
  (interactive)
  (let ((specific-frame-parameters '((left . 1280)
                                     (top . 25)
                                     (width . 182)
                                     (height . 68))))
    (modify-frame-parameters nil specific-frame-parameters)))

(defun restore-frame-to-laptop-two-thirds-size-and-position ()
  "Restore the frame's size and position to specific values."
  (interactive)
  (let ((specific-frame-parameters '((left . 685)
                                     (top . 44)
                                     (width . 113)
                                     (height . 47))))
    (modify-frame-parameters nil specific-frame-parameters)))


(define-key key-minor-mode-map (kbd "s-k f e") 'restore-frame-to-external-minotaur-two-thirds-size-and-position)
(define-key key-minor-mode-map (kbd "s-k f l") 'restore-frame-to-laptop-two-thirds-size-and-position)



(define-key key-minor-mode-map (kbd "s-k f e") 'restore-frame-to-external-minotaur-two-thirds-size-and-position)
(define-key key-minor-mode-map (kbd "s-k f l") 'restore-frame-to-laptop-two-thirds-size-and-position)


#+END_EXAMPLE



* indent level
#+begin_src emacs-lisp
(setq org-indent-indentation-per-level 2)
#+end_src

* right-click
[[https://oylenshpeegul.gitlab.io/blog/posts/20230129/][Context menus in Emacs 28! · oylenshpeegul]]

[[http://yummymelon.com/devnull/customizing-the-emacs-context-menu.html][nfdn: Customizing the Emacs Context Menu]]

#+begin_src emacs-lisp
(add-hook 'text-mode-hook 'context-menu-mode)
(add-hook 'shell-mode-hook 'context-menu-mode)
(add-hook 'dired-mode-hook 'context-menu-mode)
(add-hook 'org-mode-hook 'context-menu-mode)

; (add-hook 'context-menu-functions #'my-context-menu)

#+end_src



* garbage collection
[[/Users/jay/Dropbox/roam/emacs/20231030235900-garbage_collection_emacs.or][📄 Garbage Collection Emacs]]

[[https://github.com/doomemacs/doomemacs/issues/3108][org-mode slow but fixed with garbage collection delay on mac · Issue #3108 · doomemacs/doomemacs · GitHub]]
#+begin_src emacs-lisp
#+end_src


* remove filler words
Dev:
https://chat.openai.com/share/a0491b12-f038-4ba7-aa2a-e8a94073d4a8

Philosophy:
[[https://help.descript.com/hc/en-us/articles/10164806394509-Removing-filler-words#h_01H8Y6XQ6N0WYCXKSKZRRDT0QD][Removing filler words – Descript Help]]


"mmm"	"mmm"	"mmm"
"um"	"um"	"um"
"uh"	"uh"	"uh"
"hm"	"hm"	"hm"
 	 	"but you know"
 	 	"I guess"
 	 	"I mean"
 	 	"I suppose"
 	 	"kind of"
 	 	"like"
 	 	"or something"
 	 	"so"
 	 	"sort of"
 	 	"well"
 	 	"you know"
 	 	"you know what I mean"
 	 	"you see"



#+begin_src emacs-lisp
(defun remove-filler-words ()
  "Remove filler words from the text and report what was removed."
  (interactive)
  (let ((counts (make-hash-table :test 'equal))
        (report-string ""))
    (save-excursion
      (dolist (filler '(("kind of like" . "")
                        (", you know, " . ", ")
                        ("you know, " . "")
                        ("you know" . "")
                        (", I mean, " . ", ")
                        ("I mean, " . "")
                        ("I mean" . "")
                        ("kind of" . "")
                        (", like, " . ", ")
                        ("sort of" . "")
                        ("okay" . "OK")
                        ("\\b\\(um\\|umm\\)\\b" . "")
                        ("\\buh\\b" . "")
                        (", right?" . ".")
                        (", right." . ".")))
        (goto-char (point-min))
        (let ((search-func (if (string-match-p "\\\\b" (car filler))
                               're-search-forward
                             'search-forward))
              (count 0))
          (while (funcall search-func (car filler) nil t)
            (setq count (1+ count))
            (if (string= (car filler) "\\buh\\b")
                (unless (looking-at "-huh")
                  (replace-match (cdr filler)))
              (replace-match (cdr filler))))
          (when (> count 0)
            (puthash (car filler) count counts)))))

    (while (cleanup-doubled-punctuation))

    ;; Remove stray commas
    (goto-char (point-min))
    (while (search-forward " , " nil t)
      (replace-match ", "))

    ;; Construct the report string
    (maphash
     (lambda (key value)
       (setq report-string
             (concat report-string
                     (format
                      (cond
                       ((string= key "okay") "Replaced %d instances of \"okay\" with \"OK\". ")
                       ((string= key ", right?") "Replaced %d instances of \", right?\" with \".\". ")
                       ((string= key "\\b\\(um\\|umm\\)\\b") "Removed %d instances of \"um\" or \"umm\". ")
                       ((string= key "\\buh\\b") "Removed %d instances of \"uh\". ")
                       (t "Removed %d instances of \"%s\". "))
                      value key))))
     counts)

    ;; Report the changes
    (if (string= report-string "")
        (message "No changes made.")
      (message report-string))))

(defun cleanup-doubled-punctuation ()
  "Clean up doubled punctuation, returns t if a replacement was made."
  (let ((replaced nil))
    (dolist (pair '((",," . ",")
                    (".," . ".")
                    (" , " . ", ")
                    ("  " . " ")))
      (goto-char (point-min))
      (while (search-forward (car pair) nil t)
        (replace-match (cdr pair))
        (setq replaced t)))
    replaced))
#+end_src


* remove doubled words
#+begin_src emacs-lisp
(defconst duplicate-word-exclusions
  '("that" "go" "no" "yes" "very" "really" "so" "chop" "please" "now" "stop" "sorry" "never" "ever" "more" "ha" "wait" "he" "oh" "help" "hi" "hello" "wow" "yum" "yo" "run" "bravo" "aha" "long" "always" "tap" "knock" "hurry" "bye" "love" "hate" "like" "way" "big" "best" "pretty" "well" "totally" "yeah" "blah"))

(defun remove-duplicated-words ()
  "Remove duplicated words, excluding certain grammatical duplicates."
  (interactive)
  (let ((removed-words (make-hash-table :test 'equal))
        (report-string ""))
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward
              "\\b\\(\\w+\\)\\b\\s-+\\1\\b" nil t)
        (let ((matched-word (match-string 1)))
          (unless (member matched-word duplicate-word-exclusions)
            (puthash matched-word (1+ (gethash matched-word removed-words 0)) removed-words)
            (replace-match matched-word))))
    ;; Constructing the report string
    (maphash (lambda (key value)
               (setq report-string (concat report-string (format "\"%s\" %d times, " key value))))
             removed-words)
    ;; Reporting the changes
    (if (string= report-string "")
        (message "No duplicated words removed.")
      (message (concat "Removed duplicated words: " (substring report-string 0 -2) "."))))))

(defalias 'remove-doubled-words 'remove-duplicated-words)

(defun whittle ()
(interactive)
(remove-filler-words)
(remove-duplicated-words)
(remove-doubled-words)
  )
#+end_src

* remove redundant bold tags from org headings
#+begin_src emacs-lisp
(defun redundant-delete-redundant-asterisks-in-org-headings ()
  "Remove redundant asterisks in Org-mode headings within the current buffer or selected region."
  (interactive)
  (let ((start (if (use-region-p) (region-beginning) (point-min)))
        (end (if (use-region-p) (region-end) (point-max))))
    (save-excursion
      (goto-char start)
      (while (re-search-forward "^\\(*+\\) \\(.*?\\)\\(*+\\)?\\s-*$" end t)
        (let ((stars (match-string 1))
              (heading (match-string 2)))
          (replace-match (concat stars " " (replace-regexp-in-string "\\*+" "" heading))))))))
#+end_src


* weeklies
#+begin_src emacs-lisp
(defun open-weeklies ()
  (interactive)
  (find-file "/Users/jay/Dropbox/roam/accountability/weeklies.txt")
  )
#+end_src



* split window left
#+begin_src emacs-lisp
(defun split-window-left (&optional size)
 "Like split-window-right, with selected window on the right."
 (interactive "P")
 (split-window-right size)
 (other-window 1))

#+end_src


* export to PDF and prepend cover page
#+begin_src emacs-lisp
(defun export-to-pdf-and-prepend-cover-page ()
 "Export the current Org document to PDF and prepend a cover page located in the same directory. Then open the resulting PDF."
 (interactive)
 (let* ((output-pdf (concat (file-name-sans-extension (buffer-file-name)) ".pdf"))
     (cover-page (concat (file-name-directory (buffer-file-name)) "cover-page.pdf"))
     (final-pdf (concat (file-name-sans-extension (buffer-file-name)) "_with-cover.pdf")))
  (org-latex-export-to-pdf)
  (shell-command (format "pdftk %s %s cat output %s"
              (shell-quote-argument cover-page)
              (shell-quote-argument output-pdf)
              (shell-quote-argument final-pdf)))
  (message "PDF exported and combined with cover page: %s" final-pdf)
  ;; Open the resulting PDF
  (cond
   ((string-equal system-type "darwin") ; macOS
   (shell-command (format "open %s" (shell-quote-argument final-pdf))))
   ((string-equal system-type "gnu/linux") ; Linux
   (shell-command (format "xdg-open %s" (shell-quote-argument final-pdf))))
   ((string-equal system-type "windows-nt") ; Windows
   (shell-command (format "start %s" (shell-quote-argument final-pdf)))))))

#+end_src


* org-mode security vulnerability
[[https://list.orgmode.org/87o7b3eczr.fsf@bzg.fr/T/#t][[ANN] Emergency bugfix release: Org mode 9.6.23]]

Only required if Emacs < 29.3.

#+begin_src emacs-lisp
(setq org-preview-latex-default-process 'verbatim)
#+end_src



* detect and open street addresses
#+begin_src emacs-lisp
(defun open-labeled-address-in-google-maps ()
 "Find and open a labeled address in Google Maps while displaying the address in the minibuffer."
 (interactive)
 (save-excursion
  (let (address-bound start end)
   ;; Search backward for the label 'address:' or 'Address:', considering possible extra whitespace
   (if (re-search-backward "^\\s-*\\(?:address:\\|Address:\\)\\s-*" nil t)
     (progn
      ;; Check if the address starts on the same line or the next line
      (if (looking-at "$")
        (forward-line 1)) ; Move to the beginning of the next line if the label line is empty
      (setq start (point))
      ;; Search forward for the first occurrence of a 5-digit ZIP code followed by optional whitespace and a newline
      (if (re-search-forward "\\([0-9]\\{5\\}\\)\\s-*$" nil t)
        (progn
         (setq end (match-end 0)) ; Capture up to the end of the ZIP code
         (setq address-bound (buffer-substring-no-properties start end))
         (setq address-bound (replace-regexp-in-string "\n+" " " (string-trim address-bound)))
         ;; Display the address in the minibuffer
         (message "Opening %s" address-bound)
         ;; Open the address in Google Maps
         (browse-url (concat "https://www.google.com/maps/search/?api=1&query="
                   (url-hexify-string address-bound))))
       (message "ZIP code not found after label!")))
    (message "No address label found!")))))

#+end_src


* server start
#+begin_src emacs-lisp
(add-hook 'after-init-hook 'server-start)
;; (server-start)
#+end_src

* org-transclusion
** org-transclusion-config
#+begin_src emacs-lisp
(use-package org-transclusion
  :config
  (setq org-transclusion-exclude-elements '(property-drawer))
  (setq org-transclusion-include-first-section nil)
  '(org-transclusion-extensions
    '(org-transclusion-src-lines org-transclusion-font-lock org-transclusion-indent-mode))
(custom-set-faces
 '(org-transclusion-fringe ((t (:background "yellow" :foreground "yellow")))))

;; Ensure that load-path to org-transclusion is already added
;; If you installed it with the built-in package.el, this should be already done.
;; (add-to-list 'load-path "path/to/org-transclusion/")
(add-to-list 'org-transclusion-extensions 'org-transclusion-indent-mode)
(require 'org-transclusion-indent-mode)
)

;; Customize the appearance of transclusion fringes
(set-face-attribute
 'org-transclusion-fringe nil
 :foreground "yellow"
 :background "yellow")

#+end_src


* flycheck
#+BEGIN_SRC emacs-lisp
(use-package flycheck
:defer
  :ensure t
  :init (global-flycheck-mode))

#+END_SRC


** flycheck-mode-line
#+begin_src emacs-lisp
(setq flycheck-mode-line nil)

#+end_src



#+begin_src emacs-lisp
(server-start)
#+end_src






* smartparens fix
#+begin_src emacs-lisp
;; smartparens configuration
(require 'smartparens-config)
(smartparens-global-mode t)
(show-smartparens-global-mode t)

;; web-mode configuration
(require 'web-mode)
(add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))

(add-hook 'web-mode-hook
     (lambda ()
      (setq web-mode-enable-auto-pairing nil)
      (setq web-mode-enable-auto-closing nil)))

;; Disable smartparens in web-mode
(add-hook 'web-mode-hook 'turn-off-smartparens-mode)
#+end_src


* pasteboard-copy-large-file
#+begin_src emacs-lisp
(defun pasteboard-copy-large-file ()
 "Copy the current region to the pasteboard using a temporary file."
 (interactive)
 (let* ((txt (buffer-substring (region-beginning) (region-end)))
     (temp-file (make-temp-file "emacs-pasteboard")))
  (with-temp-file temp-file
   (insert txt))
  (shell-command-to-string (format "cat %s | pbcopy" (shell-quote-argument temp-file)))
  (delete-file temp-file)))

(global-set-key (kbd "C-c C-c") 'pasteboard-copy)
#+end_src

* Make Emacs use MacOS Trash instead of rm
When deleting a file, don't use vc-delete-file
#+begin_src emacs-lisp
(defun crux-delete-file-and-buffer ()
 "Kill the current buffer and deletes the file it is visiting."
 (interactive)
 (let ((filename (buffer-file-name)))
  (when filename
   (when (y-or-n-p (format "Are you sure you want to delete %s? " filename))
    (let ((vc-backend (vc-backend filename)))
     (when vc-backend
      (vc-delete-file filename))
     (call-process "/opt/homebrew/bin/trash" nil nil nil filename)
     (message "Moved file %s to your MacOS Trash 🗑️" filename)
     (kill-buffer))))))
#+end_src

* server
#+begin_src emacs-lisp
(require 'server)
(unless (server-running-p)
 (server-start))
#+end_src

* query replace all files in current directory
#+begin_src emacs-lisp
(defun query-replace-all-files-in-current-directory (from-string to-string &optional regexp-flag)
 "Query replace FROM-STRING with TO-STRING in all files in the current directory.
If REGEXP-FLAG is non-nil, treat FROM-STRING as a regular expression."
 (interactive
  (let ((from-string (read-string "Replace: "))
     (to-string (read-string "With: "))
     (regexp-flag (y-or-n-p "Use regular expressions? ")))
   (list from-string to-string regexp-flag)))
 (let ((dir default-directory)
    (files (directory-files-recursively default-directory ".*" nil)))
  (dolist (file files)
   (when (file-regular-p file)
    (find-file file)
    (save-excursion
     (goto-char (point-min))
     (if regexp-flag
       (query-replace-regexp from-string to-string)
      (query-replace from-string to-string)))
    (save-buffer)
    (kill-buffer)))))

;; (define-key dired-mode-map (kbd "s-H") 'query-replace-all-files-in-current-directory)

;; (add-hook 'dired-mode-hook
;;           (lambda ()
;;             (define-key dired-mode-map (kbd "s-H") 'query-replace-all-files-in-current-directory)))
#+end_src


* fix buffers
#+begin_src emacs-lisp
(setq split-height-threshold nil)
(setq split-width-threshold 0)

(defun force-split-window-vertically (&optional window)
 "Force splitting windows vertically."
 (let ((window (or window (selected-window))))
  (or (and (window-splittable-p window t)
       (with-selected-window window
        (split-window-right)))
    (split-window-sensibly window))))

(setq split-window-preferred-function #'force-split-window-vertically)

(setq org-roam-buffer-display-properties '((side . right) (slot . 1) (window-width . 0.3)))

(purpose-mode -1)

(setq max-lisp-eval-depth 10000)



#+end_src


* paste and copy all
#+begin_src emacs-lisp
(defun expand-outreach-snippet ()
 "Expand the yasnippet with key 'outreach'."
 (interactive)
 (yas-expand-snippet (yas-lookup-snippet "outreach")))

(defun expand-outreach-snippet-paste-copy-all ()
 "Expand the 'outreach' snippet, paste clipboard text into the buffer using `pasteboard-paste-spaces-maybe`, and then select the entire buffer and copy it."
 (interactive)
 ;; Expand the snippet
 (expand-outreach-snippet)
 ;; Wait a moment to ensure snippet expansion completes
 (run-at-time "0.1 sec" nil
        (lambda ()
         ;; Paste clipboard text into buffer
         (pasteboard-paste-spaces-maybe)
         ;; Select the entire buffer
         (goto-char (point-min))
         (push-mark (point-max) nil t)
         (activate-mark)
         ;; Copy the entire buffer to clipboard
         (pasteboard-copy))))

(defun expand-outreach-snippet-paste-copy-all-and-submit-ChatGPT ()
 "Expand the 'outreach' snippet, paste clipboard text into the buffer using `pasteboard-paste-spaces-maybe`, and then select the entire buffer and copy it."
 (interactive)
 ;; Expand the snippet
 (expand-outreach-snippet)
 ;; Wait a moment to ensure snippet expansion completes
 (run-at-time "0.1 sec" nil
        (lambda ()
         ;; Paste clipboard text into buffer
         (pasteboard-paste-spaces-maybe)
         ;; Select the entire buffer
         (goto-char (point-min))
         (push-mark (point-max) nil t)
         (activate-mark)
         ;; Copy the entire buffer to clipboard
         (pasteboard-copy)
         ;; Execute AppleScript to paste into ChatGPT
         (do-applescript
         "tell application \"ChatGPT\" to activate
          tell application \"System Events\"
           keystroke \"n\" using command down
           delay 1
           keystroke \"v\" using command down
           delay 1
           keystroke return
          end tell"))))

(define-key key-minor-mode-map (kbd "s-k e m") 'expand-outreach-snippet-paste-copy-all-and-submit-ChatGPT)
#+end_SRC


* suppress warnings
#+begin_src emacs-lisp
(with-eval-after-load 'yasnippet
 (add-to-list 'warning-suppress-types '(yasnippet backquote-change)))

#+end_src

* replace add em dashes
#+begin_src emacs-lisp
(defun replace-dashes-with-em-dashes ()
  "Replace all occurrences of '---' or '--' with em dashes in the current buffer."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    ;; First, replace all occurrences of '---' with em dashes
    (while (search-forward "---" nil t)
      (replace-match "—" nil t))
    ;; Then, replace all occurrences of '--' with em dashes
    (goto-char (point-min))
    (while (search-forward "--" nil t)
      (replace-match "—" nil t))))
#+end_src



* use shell environment
** Set Path environment
I duplicated the below to /Users/jay/emacs/emacs-settings/spacemacs.d/init.el
and now it works. Don't understand why it was getting overwritten before, but whatever, it's working now.

#+begin_src emacs-lisp
;; Define a list of additional paths
(defvar my-additional-paths
  '("/usr/local/bin"
    "/opt/homebrew/bin"
    "/Applications/Firefox.app/Contents/MacOS"))

;; Update PATH environment variable
(setenv "PATH"
        (concat (getenv "PATH") ":"
                (mapconcat 'identity my-additional-paths ":")))

;; Update exec-path
(dolist (path my-additional-paths)
  (add-to-list 'exec-path path))



;; Rest of your configuration
(message "Final PATH: %s" (getenv "PATH"))
#+end_src


* Jay Call
#+begin_src emacs-lisp
(defun org-to-html-to-clipboard-hardcoded ()
  "Convert hardcoded org-mode text to HTML and copy it to the MacOS clipboard as HTML."
  (interactive)
  (let* ((org-content "Feel free to suggest some times that work for you or book time with me directly [[https://calendar.app.google/aSu61Nzz3PmxeYVaA][here]].")
         (html-content (org-export-string-as org-content 'html t))
         (temp-file (make-temp-file "clipboard-html-" nil ".html")))
    ;; Write the HTML content to a temporary file
    (with-temp-file temp-file
      (insert html-content))
    ;; Use AppleScript to read the file and set the clipboard
    (let ((script (format "set the clipboard to (read (POSIX file \"%s\")) as «class HTML»" temp-file)))
      (do-applescript script))
    ;; Delete the temporary file
    (delete-file temp-file)))
#+end_src


* timestamp export format
Remove the remove <> surrounding timestamps

#+BEGIN_SRC emacs-lisp
(add-to-list 'org-export-filter-timestamp-functions
       #'endless/filter-timestamp)
(defun endless/filter-timestamp (trans back _comm)
 "Remove <> around time-stamps."
 (pcase back
  ((or `jekyll `html)
   (replace-regexp-in-string "&[lg]t;" "" trans))
  (`latex
   (replace-regexp-in-string "[<>]" "" trans))))
#+END_SRC

we can still make it better. The YYYY-MM-DD weekday format isn't commonly used in prose, so let's switch that as well.

#+BEGIN_SRC emacs-lisp
(setq-default org-display-custom-times t)
;; Before you ask: No, removing the <> here doesn't work.
(setq org-time-stamp-custom-formats '("%B %d, %Y" . "%d/%m/%Y %a %H:%M"))
#+END_SRC

Source: [[http://endlessparentheses.com/better-time-stamps-in-org-export.html][Better time-stamps in org-export with Emacs - Endless Parentheses]]

Hmm maybe look at this too: [[http://stackoverflow.com/questions/23297422/org-mode-timestamp-format-when-exported][datetime - Org mode timestamp format when exported - Stack Overflow]]




* org element parser error
#+begin_src emacs-lisp
(setq debug-on-message "org-element--cache: Added org-data parent to non-headline element")

(with-eval-after-load 'smartparens
  (sp-local-pair 'org-mode "'" nil :actions nil)  ;; example: disable quote pairing
  (remove-hook 'org-mode-hook #'show-smartparens-mode))


; or more drastically:
; (remove-hook 'post-command-hook 'sp-show--pair-function)
#+end_src


* top level heading
What This Does:
This makes level 1 Org headings (**) export as <h1> instead of <h2>.
The document title (from #+TITLE: or the filename) remains in the <title> tag but is not included as an additional <h1>.

#+begin_src emacs-lisp
(setq org-html-toplevel-hlevel 1)
#+end_src

* org config files mode
#+begin_src emacs-lisp
(define-minor-mode my-org-config-mode
  "Minor mode for my custom Org file config."
  :init-value nil
  :lighter " myOrgCfg"
  (if my-org-config-mode
      (progn
        (define-key org-mode-map (kbd "<SPC>") #'insert-space)
        (make-local-variable 'abbrev-mode)
        (setq abbrev-mode nil)
        (setq-local org-config-files-local-mode t))
    ;; Optionally, unset org-config-files-local-mode when disabling:
    (kill-local-variable 'org-config-files-local-mode)))

(provide 'my-org-config-mode)
#+end_src


* Local Variables & The End
#+BEGIN_SRC
# Local Variables:
# org-config-files-local-mode: t
# enable-local-eval: t
# eval: (org-config-files-local-mode 1)
# End:
#+END_SRC
