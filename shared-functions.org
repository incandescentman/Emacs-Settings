#+auto_tangle: t
;; -*- lexical-binding: t -*-
;;;   Current time:      (current-time-string)
;;;   Last command:      last-command
;;; (abbrev-mode)
;; (user-full-name)

* Basic Emacs Setup
** Package Archives and Initialization
** General Settings
** Minor Modes
* Org-mode Configuration
** Org General Settings
** Org Export Settings

*** ignore

#+begin_src emacs-lisp

(defun my/org-remove-links-and-source-lines (backend)
  "Remove lines starting with 'Links ::' or 'Source ::' before export."
  (save-excursion
    (goto-char (point-min))
    (while (re-search-forward "^\\s-*\\(- Links ::\\|- Source ::\\).*$" nil t)
      (replace-match ""))))

(add-hook 'org-export-before-processing-hook #'my/org-remove-links-and-source-lines)
#+end_src

* Appearance and UI
** Fonts and Frames
* Custom Functions

* Intro / About:ARCHIVE:
#+OPTIONS: f:t

#+TITLE:Jay Dixit's Emacs setup - May 22, 2015.

- System: Mac OSX Sierra version 13.1
- Emacs version: Emacs 28.2 (Carbon Version)
- Spacemacs version 0.999.0
- org-mode version 9.6.1
- Use case: I use this file with GNU Emacs for OSX, using Spacemacs.
- If it matters, the build of GNU Emacs that I use is Mitsuharu Yamamoto's Emacs Mac Port, available here:
- =brew tap railwaycat/emacsmacport=
- [[https://github.com/railwaycat/homebrew-emacsmacport][railwaycat/homebrew-emacsmacport: Emacs mac port formulae for the Homebrew package manager]]
- [[https://bitbucket.org/mituharu/emacs-mac/overview][mituharu / emacs-mac - Bitbucket]]

* Package & Load Paths
** Load the proper repositories (package archives)
#+BEGIN_SRC emacs-lisp
;; Set package archives
(setq package-archives
   '(("gnu" . "https://elpa.gnu.org/packages/")
    ("melpa" . "https://melpa.org/packages/")
    ("nongnu" . "https://elpa.nongnu.org/nongnu/")
    ("tromey" . "https://tromey.com/elpa/")))


(use-package use-package
  :custom

;;(package-native-compile t)
  (warning-minimum-level :emergency))
#+END_SRC

** use-package verbosity
#+begin_src emacs-lisp
(setq use-package-verbose nil) ;; Set to t for debugging
#+end_src

** use-package blocks
#+BEGIN_SRC emacs-lisp
(use-package ox-LaTeX
:defer t
  )
(use-package ox-html
  :defer t)
#+END_SRC

* General Emacs Settings
** Basic variables
*** Setting variables
I should probably eventually break these out of custom-set-variables and organize them according to their function.
#+BEGIN_SRC emacs-lisp
;; -*- lexical-binding: t -*-

;; General Settings
(setq user-full-name "Jay Dixit"
      abbrev-all-caps nil
      blink-cursor-mode -1
      calendar-latitude 40.7
      case-fold-search t
      ccm-recenter-at-end-of-file t
      clean-buffer-list-delay-general 1
      column-number-mode nil
            display-time-mode t
      grep-highlight-matches 'always
      initial-major-mode 'org-mode
      make-backup-files t
      reb-re-syntax 'string
      standard-indent 3
      tooltip-mode nil
      completion-ignored-extensions '(".o" "~" ".bin" ".lbin" ".so" ".a" ".ln"
                                      ".blg" ".bbl" ".elc" ".lof" ".glo" ".idx"
                                      ".lot" ".svn/" ".hg/" ".git/" ".bzr/" "CVS/"
                                      "_darcs/" "_MTN/" ".fmt" ".tfm" ".class"
                                      ".fas" ".lib" ".mem" ".x86f" ".sparcf" ".fasl"
                                      ".ufsl" ".fsl" ".dxl" ".pfsl" ".dfsl" ".p64fsl"
                                      ".d64fsl" ".dx64fsl" ".lo" ".la" ".gmo" ".mo"
                                      ".toc" ".aux" ".cp" ".fn" ".ky" ".pg" ".tp"
                                      ".vr" ".cps" ".fns" ".kys" ".pgs" ".tps"
                                      ".vrs" ".pyc" ".pyo" ".tex" ".mm" "Icon"
                                      ".html" ".zip"))


;; CUA Mode Settings
(setq cua-highlight-region-shift-only t
      cua-mode nil)

;; Deft Settings
(setq deft-directory "~/Dropbox/writing/notationaldata/")


;; Edit Server Settings

(setq edit-server-default-major-mode 'org-mode
      edit-server-new-frame t)

;; Eshell Settings
(setq eshell-load-hook '((lambda () (abbrev-mode -1))))

;; Ido Settings
(setq ido-use-faces t
      ido-use-url-at-point t)

;; Org-Mode Settings
(setq org-M-RET-may-split-line '((item . t))
      org-activate-links '(bracket plain radio tag date footnote)
      org-archive-location "archive/%s_archive::"
      org-ascii-headline-spacing '(1 . 1)
      org-ascii-table-use-ascii-art t
      org-catch-invisible-edits 'smart
      org-ctrl-k-protect-subtree t
      org-custom-properties '(">")
      org-default-notes-file "~/Dropbox/writing/notationaldata/notes.txt"
      org-display-custom-times nil
      org-drawers '("PROPERTIES" "CLOCK" "LOGBOOK" "RESULTS" "SOURCE")
      org-edit-src-content-indentation 4
      org-ellipsis 'org-warning
      org-enforce-todo-checkbox-dependencies t
      org-enforce-todo-dependencies t
      org-extend-today-until 8
      org-fontify-done-headline t
      org-fontify-emphasized-text t
      org-footnote-define-inline t
      org-footnote-section "Footnotes"
      org-footnote-tag-for-non-org-mode-files "Footnotes:"
      org-hide-block-startup nil
      org-hide-emphasis-markers t
      org-html-container-element "div"
      org-html-head-include-scripts nil
      org-html-html5-fancy t
      org-html-postamble nil
      org-html-text-markup-alist '((bold . "<strong>%s</strong>")
                                   (code . "<code>%s</code>")
                                   (italic . "<em>%s</em>")
                                   (strike-through . "<del>%s</del>")
                                   (underline . "<span class=\"underline\">%s</span>")
                                   (verbatim . "<code>%s</code>"))
      org-indent-mode-turns-off-org-adapt-indentation nil
      org-indent-mode-turns-on-hiding-stars nil
      org-insert-mode-line-in-empty-file t
      org-log-done nil
      org-mac-link-skim-highlight-selection-p t
      org-n-level-faces 9
      org-odd-levels-only nil
      org-provide-checkbox-statistics t
      org-replace-disputed-keys nil
      org-special-ctrl-a/e t
      org-src-preserve-indentation t
      org-startup-align-all-tables t
      org-startup-indented t
      org-use-speed-commands t
      org-yank-adjusted-subtrees t
      org2blog/wp-confirm-post nil
      org2blog/wp-default-categories '("inspiration" "personal growth" "miscellany")
      org2blog/wp-keep-new-lines t
      org2blog/wp-show-post-in-browser t
      org2blog/wp-use-tags-as-categories t)

;; OSX Browse Settings
(setq browse-url-browser-function 'browse-url-default-macosx-browser)
(setq osx-browse-prefer-background nil
      osx-browse-prefer-browser "com.google.Chrome"
      osx-browse-prefer-new-window t)

;; Smex Settings
(setq smex-prompt-string "I love you. ")

;; Org Export Settings
(setq org-export-latex-image-default-option "width=20.5cm"
      org-export-time-stamp-file nil
      org-export-with-clocks t
      org-html-head-include-default-style nil
      org-html-toplevel-hlevel 2
      org-indent-indentation-per-level 2
      org-list-allow-alphabetical t
      org-priority-faces nil)

;; Uncomment if needed
;; (setq org-agenda-jump-prefer-future t)
;; (setq org-agenda-skip-scheduled-if-done t)
;; (setq org-agenda-timegrid-use-ampm t)
;; (setq tramp-default-method "ssh")
;; (setq visual-line-mode nil t)
;; (setq org-list-indent-offset 3)
#+END_SRC


** Startup, UI, and appearance


** Appearance
#+begin_src emacs-lisp
;; A. keep the new, cached version -- recommended
(defun jay/adjust-font-size (&optional frame)
  "Resize default font once per frame size."
  (let* ((frame (or frame (selected-frame)))
         (w     (frame-pixel-width frame)))
    (unless (equal w (frame-parameter frame 'sed--last-width))
      (set-frame-parameter frame 'sed--last-width w)
      (set-face-attribute 'default frame
                          :font "Monaco"
                          :height (if (> w 2540) 230 200)))))

(add-hook 'after-make-frame-functions #'jay/adjust-font-size)
(add-hook 'window-size-change-functions #'jay/adjust-font-size)
#+end_src

** fontify item checklists
[[https://fuco1.github.io/2017-05-25-Fontify-done-checkbox-items-in-org-mode.html?utm_source=Sacha+Chua+-+Living+an+Awesome+Life&utm_campaign=4942bceb80-RSS_EMAIL_CAMPAIGN&utm_medium=email&utm_term=0_e4be269acf-4942bceb80-97219941][Fontify done checkbox items in org-mode]]

#+BEGIN_SRC emacs-lisp
;; Highlight completed checklist items in org-mode
(font-lock-add-keywords
 'org-mode
 `(("^[ \t]*\\(?:[-+*]\\|[0-9]+[).]\\)[ \t]+\\(\\(?:\\[@\\(?:start:\\)?[0-9]+\\][ \t]*\\)?\\[\\(?:X\\|\\([0-9]+\\)/\\2\\)\\][^\n]*\n\\)" 1 'org-headline-done prepend))
 'append)
#+END_SRC

** Minor modes

* Org-Specific Config
** Basic org settings
** org setup
** Some favorite ~org~ settings:
#+BEGIN_SRC emacs-lisp
  ; (setq org-use-property-inheritance t)
    (setq org-fontify-quote-and-verse-blocks t)
  ;; blank lines before new headings
  (setq org-blank-before-new-entry
        '((heading . always)
         (plain-list-item . nil)))
  (setq org-return-follows-link t)

  ;; leave an empty line between folded subtrees
  (setq org-cycle-separator-lines 1)

  (setq org-support-shift-select (quote always))

#+END_SRC

** org capture
** org agenda

** org-export
#+BEGIN_SRC emacs-lisp
(setq org-export-with-smart-quotes t)
(setq org-export-exclude-tags (quote ("noexport" "extra")))

;; (setq org-html-head "<link rel='stylesheet' type='text/css' href='/Users/jay/Dropbox/github/incandescentman.github.io/css/neo.css'>")
(setq org-export-time-stamp-file nil)
(setq org-export-with-clocks t)
(setq org-export-with-drawers t)
(setq org-export-with-section-numbers nil)
(setq org-export-with-timestamps (quote active))
(setq org-export-with-toc nil)

 (setq org-export-date-timestamp-format "%Y-%m-%d %I:%M%p")
 (setq org-export-date-timestamp-format "%B %d, %Y")

 (setq org-export-html-inline-image-extensions (quote ("png" "jpeg" "jpg" "gif" "svg" "tif" "gif")))

;; (setq org-latex-inline-image-rules (quote (("file" . "\\.\\(pdf\\|jpeg\\|gif\\|jpg\\|png\\|ps\\|eps\\|tikz\\|pgf\\|svg\\)\\'"))))

(setq org-latex-default-class "elegant")

(setq org-latex-inline-image-rules '(("file" . "\\.\\(pdf\\|jpeg\\|jpg\\|png\\|ps\\|eps\\|tikz\\|pgf\\|svg\\|gif\\)\\'")))


;; (setq org-export-html-style-include-default t)
 (setq org-export-latex-date-format "%d %B %Y.")
 (setq org-export-latex-emphasis-alist (quote (("*" "\\textit{%s}" nil) ("/" "\\textit{%s}" nil) ("_" "\\underline{%s}" nil) ("+" "\\st{%s}" nil) ("=" "\\verb" t) ("~" "\\verb" t))))
;; (setq org-export-latex-emphasis-alist (quote (("*" "\\emph{%s}" nil) ("/" "\\textit{%s}" nil) ("_" "\\underline{%s}" nil) ("+" "\\st{%s}" nil) ("=" "\\verb" t) ("~" "\\verb" t))))
;; (setq org-export-latex-verbatim-wrap (quote ("\\begin{quote}" . "\\end{quote}")))
 (setq org-export-with-clocks t)
 (setq org-export-with-drawers t)
 (setq org-export-with-section-numbers nil)
(setq org-export-with-planning nil)
(setq org-export-allow-bind-keywords t)
;; (setq org-export-blocks-witheld (quote (hidden)) t)
(setq org-export-date-timestamp-format "%Y%m%d %I:%M%p")
(setq org-export-latex-emphasis-alist (quote    (("*" "\\emph{%s}" nil)
     ("/" "\\textit{%s}" nil)
     ("_" "\\underline{%s}" nil)
     ("+" "\\st{%s}" nil)
     ("=" "\\verb" t)
     ("~" "\\verb" t))))

(setq org-html-footnotes-section
   "<div id=\"footnotes\">
<h2 class=\"footnotes\">%s </h2>
<div id=\"footnote\">
%s
</div>
</div>")

(setq org-latex-text-markup-alist (quote    ((bold . "\\textbf{%s}")
     (code . verb)
     (italic . "\\textit{%s}")
     (strike-through . "\\sout{%s}")
     (underline . "\\uline{%s}")
     ;; (verbatim . protectedtext)
     )))

(setq org-latex-toc-command "\\tableofcontents
\\newpage
")

(setq safe-local-variable-values (quote    ((eval when
    (fboundp
     (quote rainbow-mode))
    (rainbow-mode 1)))))

(setq org-html-footnotes-section "<div id=\"footnotes\">
<h2 class=\"footnotes\">%s </h2>
<div id=\"footnote\">
%s
</div>
</div>")

(setq org-html-head-include-default-style nil)
(setq org-html-head-include-scripts nil)
(setq org-html-html5-fancy t)
(setq org-html-doctype "html5")
(setq org-html-metadata-timestamp-format "%m-%d %a %H:%M")
(setq org-html-postamble nil)
(setq org-html-text-markup-alist
   (quote
    ((bold . "<strong>%s</strong>")
     (code . "<code>%s</code>")
     (italic . "<em>%s</em>")
     (strike-through . "<del>%s</del>")
     (underline . "<span class=\"underline\">%s</span>")
     (verbatim . "<code>%s</code>"))))
(setq org-html-toplevel-hlevel 2)


#+END_SRC



*** org-html-export-to-html-and-open
I don't think there's a direct function for this, but you could achieve what you want using `org-export-to-file`, the last argument of which is a "post-processing" step:

 (org-export-to-file BACKEND FILE &optional ASYNC SUBTREEP VISIBLE-ONLY BODY-ONLY EXT-PLIST POST-PROCESS)

The post-processing step is handed the path to your new file; you could use something as straight-forward as `find-file`:

#+BEGIN_SRC emacs-lisp
  (defun org-html-export-to-html-and-open
   (&optional async subtreep visible-only body-only ext-plist)
   (interactive)
(let* ((outfile (org-export-output-file-name ".html" subtreep)))
    (org-export-to-file 'html outfile async subtreep visible-only body-only ext-plist #'find-file)))
#+END_SRC

*** Change section numbering depending on what export format I use
Turn this on if I'm creating documents that I want to export to both HTML and LaTeX. For now I'm turning it off.

Note: disable this when trying to export to org-html-themes!

#+BEGIN_EXAMPLE emacs-lisp
(defun my-org-export-change-options (plist backend)
  (cond
   ((equal backend 'html)
    (plist-put plist :with-toc nil)
    (plist-put plist :section-numbers nil))
   ((equal backend 'latex)
(plist-put plist :with-toc t) ; yes TOC in LaTeX
;; (plist-put plist :with-toc nil); no TOC in latex
    (plist-put plist :section-numbers t)))
  plist)
(add-to-list 'org-export-filter-options-functions 'my-org-export-change-options)
#+END_EXAMPLE

#+begin_EXAMPLE emacs-lisp
(defun my-org-export-change-options (backend)
  (cond
   ((equal backend 'html)
    (setq org-html-with-toc nil)
    (setq org-html-section-numbers nil))
   ((equal backend 'latex)
    (setq org-latex-with-toc nil)
    (setq org-latex-section-numbers t)))
  nil)

(add-to-list 'org-export-before-processing-hook 'my-org-export-change-options)
#+END_EXAMPLE

#+begin_src emacs-lisp
(defun my-org-export-change-options (plist backend)
 (cond
  ((equal backend 'html)
  (plist-put plist :with-toc nil)
  (plist-put plist :section-numbers nil))
  ((equal backend 'latex)
  (plist-put plist :with-toc nil)
  (plist-put plist :section-numbers t)))
 plist)

;; (add-to-list 'org-export-filter-options-functions 'my-org-export-change-options)

#+end_src

*** export with drawers
#+BEGIN_SRC emacs-lisp
(setq org-export-with-drawers t)
(defun jbd-org-export-format-drawer (name content)
  "Export drawers to drawer HTML class."
  (setq content (org-remove-indentation content))
  (format "@<div class=\"drawer\">%s@</div>\n" content))
(setq org-export-format-drawer-function 'jbd-org-export-format-drawer)

#+END_SRC

*** Omit headlines tagged with :ignore: --- but do still export the text in that section
This is so I can do structure headlines, for myself, that aren't part of the actual article text.

Pretty cool actually. Leaving it in.

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'ox
  (require 'ox-extra)
  (ox-extras-activate '(ignore-headlines)))
#+END_SRC

Works!

** Flyspell skip source blocks
** Archiving / hooking

* Writing Environment
** Spellcheck / flyspell
** Visual line, auto-fill
** Typographic replacements
** Misc

* Utility Functions
** my/with-advice
** HTML to Org conversions
** copy/cut region to other window
** advanced replacements
** searching
** etc.



* About

* Packages
** lexical binding
#+begin_SRC emacs-lisp
(setq lexical-binding t)
#+end_SRC

** Load some of my packages:
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/emacs/emacs-settings/")
#+END_SRC

** Control use-package verbosity

** some org packages



* The Writing Environment

* Spellcheck / flyspell

** flyspell setup
#+BEGIN_SRC emacs-lisp
(use-package flyspell
  :ensure nil                    ; built-in
  :hook ((text-mode . flyspell-mode)
         (org-mode  . flyspell-mode))
  :bind (:map flyspell-mode-map
              ("C-." . nil))     ; unbind default
  :init
  ;; --- Hunspell setup ---
;; Add to your :init block *instead* of the previous setq for this var
(add-to-list
 'ispell-dictionary-alist
 '("en_US-large" "[[:alpha:]]" "[^[:alpha:]]" "[']"
   nil ("-d" "en_US-large") nil utf-8))
  (setq ispell-program-name "hunspell"
        ispell-dictionary   "en_US-large"           ; default dict
        ispell-personal-dictionary "~/emacs/Spelling/personal.dic"
        ispell-hunspell-dictionary-paths-alist
        '(("en_US"       "~/emacs/Spelling")
          ("en_US-large" "~/emacs/Spelling")
          ("american"    "~/emacs/Spelling")
          ("english"     "~/emacs/Spelling"))
        ;; teach Flyspell about contractions etc.
        ispell-dictionary-alist
        '(("en_US-large" "[[:alpha:]]" "[^[:alpha:]]" "[']"
           nil ("-d" "en_US-large") nil utf-8))
        flyspell-abbrev-p t
        flyspell-use-global-abbrev-table-p t
        flyspell-mark-duplications-exceptions
        '((nil "that" "had" "really" "very" "much")
          ("\\`francais\\>" "nous" "vous")))
  :config
  ;; Skip #+begin_src ... #+end_src blocks in Org
  (defun my/org-setup-flyspell ()
    (when (derived-mode-p 'org-mode)
      (make-local-variable 'ispell-skip-region-alist)
      (add-to-list 'ispell-skip-region-alist
                   '("^#\\+begin_src" . "^#\\+end_src"))))
  (add-hook 'org-mode-hook #'my/org-setup-flyspell))


(defun add-word-to-personal-dictionary ()
  "Add the misspelled word at point to `ispell-personal-dictionary'."
  (interactive)
  (require 'flyspell)           ; just in case
  (pcase (flyspell-get-word)    ; returns (word start end) *only if* it's an error
    (`(,word ,start ,end)
     (flyspell-do-correct 'save nil word start end nil nil)
     (message "Added "%s" to personal dictionary" word))
    (_ (user-error "Point isn't on a highlighted misspelling"))))


(defun add-word-to-personal-dictionary ()
  "Add the word at point to the personal dictionary (bypassing Flyspell)."
  (interactive)
  (require 'ispell)
  (let ((word (or (thing-at-point 'word t)
                  (user-error "No word at point"))))
    ;; Tell the ispell process to add WORD
    (ispell-send-string (format "*%s\n" word))
    ;; Tell ispell to save the personal dictionary now
    (ispell-send-string "#\n")
    (ispell-pdict-save t)
    (message "Added \"%s\" to personal dictionary" word)))
#+END_SRC

* UI / customization of appearance and editing environment
** mouse
*** Stop accidentally highlighting org-mode links all the time:
#+BEGIN_SRC emacs-lisp
;; Disable mouse highlights globally
(setq mouse-highlight nil)

;; Avoid cursor in non-selected windows
(setq-default cursor-in-non-selected-windows nil)

#+END_SRC

** disable TAB to indent
#+BEGIN_SRC emacs-lisp
(setq org-cycle-emulate-tab nil)
#+END_SRC

** Windows
:PROPERTIES:
:ID:       B02E7409-F743-4FCB-A1D7-E0F3B65BBD67
:END:
*** Split windows vertically, i.e. using a vertical line to split
Source: [[http://stackoverflow.com/questions/2081577/setting-emacs-split-to-horizontal][Setting Emacs Split to Horizontal - Stack Overflow]]

#+BEGIN_SRC emacs-lisp


;; Always split windows vertically (side-by-side)
(setq split-width-threshold 0)
(setq split-height-threshold nil)

;; Minimum size for split windows
(setq window-min-width 20)
(setq window-min-height 5)
#+END_SRC




** quitting emacs
*** Ask before exiting Emacs
#+BEGIN_SRC emacs-lisp
(setq confirm-kill-emacs 'yes-or-no-p)
#+END_SRC

*** System alarms
In some cases, you'd like to reduce the number of warnings or eliminate warnings in certain conditions. The following turns off the alarm bell when you hit C-g in the minibuffer or during an isearch:

#+BEGIN_SRC emacs-lisp

(setq ring-bell-function
      (lambda ()
	(unless (memq this-command
		      '(isearch-abort abort-recursive-edit exit-minibuffer keyboard-quit))
	  (ding))))
#+END_SRC

Also, change the alert sound. Instead of beeping or flashing, Emacs could play a cool sound file, whenever an error occurs:
#+BEGIN_SRC emacs-lisp
;; (setq ring-bell-function (lambda () (play-sound-file "~/sounds/InkSoundStroke3.mp3")))

;; turn off alarms completely
(setq ring-bell-function 'ignore)
#+END_SRC


*** Use visual line mode whenever possible
#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook #'visual-line-mode)
(add-hook 'org-mode-hook  #'visual-line-mode)
#+END_SRC

*** Autofill mode
is this still necessary?

#+BEGIN_SRC emacs-lisp
(auto-fill-mode -1) ; turn off fill mode, which adds random line breaks in my text files:
(add-hook 'text-mode-hook  #'(lambda () (auto-fill-mode -1)))
(add-hook 'markdown-mode-hook  #'(lambda () (auto-fill-mode -1)))
(add-hook 'message-mode-hook  #'(lambda () (auto-fill-mode -1)))
#+END_SRC

*** Disable double spacing between sentences
#+BEGIN_SRC emacs-lisp
(setq-default sentence-end-double-space nil)
#+END_SRC

*** Make typing override text selection
#+BEGIN_SRC emacs-lisp
(delete-selection-mode 1)
#+END_SRC

*** Buffer-save-without-query
#+BEGIN_SRC emacs-lisp
(setq buffer-save-without-query nil)
#+END_SRC

*** Search in Spotlight
#+BEGIN_SRC emacs-lisp
(setq locate-command "mdfind")
#+END_SRC

*** Automatically open files in their correct modes
#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-lisp-mode-hook (lambda () (abbrev-mode -1)))
(add-hook 'css-mode-hook (lambda () (abbrev-mode -1)))
(add-hook 'html-mode-hook (lambda () (abbrev-mode -1)))
(add-hook 'html-helper-mode-hook (lambda () (abbrev-mode -1)))
(add-hook 'eshell-mode-hook (lambda () (abbrev-mode -1)))
(add-hook 'shell-mode-hook (lambda () (abbrev-mode -1)))
(add-hook 'shell-script-mode-hook (lambda () (abbrev-mode -1)))
(add-hook 'term-mode-hook (lambda () (abbrev-mode -1)))
#+END_SRC

*** Typography

*** Indentation
Automatically indenting yanked text if in programming-modes:
#+BEGIN_SRC emacs-lisp
(defvar yank-indent-modes
  '(LaTeX-mode TeX-mode)
  "Modes in which to indent regions that are yanked (or yank-popped).
Only modes that don't derive from `prog-mode' should be listed here.")

(defvar yank-indent-blacklisted-modes
  '(python-mode slim-mode haml-mode)
  "Modes for which auto-indenting is suppressed.")

(defvar yank-advised-indent-threshold 1000
  "Threshold (# chars) over which indentation does not automatically occur.")

(defun yank-advised-indent-function (beg end)
  "Do indentation, as long as the region isn't too large."
  (if (<= (- end beg) yank-advised-indent-threshold)
      (indent-region beg end nil)))
#+END_SRC

* My custom functions/settings
** Buffers
*** Buffer-stack
I use buffer-stack to navigate between buffers using ⌘-left and ⌘-right:
#+BEGIN_SRC emacs-lisp
;;(use-package buffer-stack
;; defer)
#+END_SRC

GNU Emacs:
#+BEGIN_SRC emacs-lisp
(global-set-key [(s-right)] 'buffer-stack-down)
(global-set-key [(s-left)] 'buffer-stack-up)
#+END_SRC

Aquamacs:
#+BEGIN_SRC emacs-lisp
(global-set-key [(A-right)] 'buffer-stack-down)
(global-set-key [(A-left)] 'buffer-stack-up)
#+END_SRC

*** Uniqify buffers
#+BEGIN_SRC emacs-lisp
;; meaningful names for buffers with the same name
;; from prelude
;; http://bit.ly/1Woabxz
(use-package uniquify
:ensure nil
:defer
:init
(setq uniquify-buffer-name-style 'forward)
(setq uniquify-separator "/")
(setq uniquify-after-kill-buffer-p t) ; rename after killing uniquified
(setq uniquify-ignore-buffers-re "^\\*") ; don't muck with special buffers

:config

; Uniqify new buffers
(defvar new-buffer-count 0)

;; open new buffers without prompting me for a filename global counter to ensure every new buffer will be unique:

(defun new-buffer ()
 (interactive)
 (setq new-buffer-count (+ new-buffer-count 1))
 (switch-to-buffer (concat "buffer" (int-to-string new-buffer-count)))
 (org-mode))


(defun new-lisp-buffer ()
 (interactive)
 (setq new-buffer-count (+ new-buffer-count 1))
 (switch-to-buffer (concat "buffer" (int-to-string new-buffer-count)))
 (emacs-lisp-mode))


)
#+END_SRC

*** new scratch buffer
#+BEGIN_EXAMPLE emacs-lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; multiple scratch buffers                                               ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; uses package "scratch"
(autoload 'scratch "scratch" nil t)
(global-set-key (kbd "s-T") 'scratch)

#+END_EXAMPLE

*** Create new buffer as org-mode subtree in current file
#+BEGIN_SRC emacs-lisp
(defun org-new-scratch-buffer ()
  (interactive)
  (insert "* oh hi there! " (format-time-string "%F %l:%M%P\n\n"))
;; (org-tree-to-indirect-buffer 'current-window)
(org-narrow-to-subtree)

  )
#+END_SRC

*** Disable autocorrect in minibuffer
#+BEGIN_SRC emacs-lisp
(defun conditionally-disable-abbrev ()
  ""
  (if (string-match "smex-" (format "%s" this-command))
      (abbrev-mode -1)))

(add-hook 'minibuffer-setup-hook 'conditionally-disable-abbrev)
(add-hook 'minibuffer-exit-hook (lambda () (abbrev-mode 1)))
(add-hook 'minibuffer-setup-hook (lambda ()
                                   (abbrev-mode -1)))
#+END_SRC

*** Ignore case when reading buffer and file names
#+BEGIN_SRC emacs-lisp
(setq
read-buffer-completion-ignore-case t
read-file-name-completion-ignore-case t)
#+END_SRC

** Reveal in finder
#+BEGIN_SRC emacs-lisp
(use-package reveal-in-finder

  :bind)
#+END_SRC

** cycle-hyphenation-or-toggle-item
#+BEGIN_SRC emacs-lisp
(defun cycle-hyphenation-or-toggle-item ()
  (interactive)
  (if (region-active-p)
      (call-interactively 'org-toggle-item)
    (cycle-hyphenation)))

#+END_SRC

* org-mode

** org custom functions
*** archiving
#+BEGIN_SRC emacs-lisp

;; ---------------------------------------------------------------------
;; Around-advice: tweak `org-archive-location`, then run the real command
;; ---------------------------------------------------------------------

(defun sed--org-archive-subtree (orig-fn &rest args)
  "Archive subtree under a heading named after its parent.
Keeps identical behaviour to the old `defadvice', but uses `advice-add'."
  (let ((org-archive-location
         (if (save-excursion
               (org-back-to-heading)
               (> (org-outline-level) 1))
             ;; archive into a drawer under the parent's headline
             (concat (car (split-string org-archive-location "::"))
                     "::* "
                     (car (org-get-outline-path)))
           org-archive-location)))
    (apply orig-fn args)))                 ; run the original command

(advice-add 'org-archive-subtree :around #'sed--org-archive-subtree)
#+END_SRC

*** org-mode speed commands
#+BEGIN_SRC emacs-lisp
(setq org-use-speed-commands t)
(setq org-speed-commands-user (quote (
; ("k" . org-kill-note-or-show-branches)
                                      ("q" . bh/show-org-agenda)
                                      ("h" . org-agenda-schedule)
                                      ("d" . org-deadline)
                                      ("w" . org-refile)
                                      ("y" . org-archive-subtree-default-with-confirmation)
                                      ("a" . org-archive-subtree)
                                      ("s" . org-schedule)
                                      ("x" . org-mark-subtree)
                                      ("z" . org-add-note)
                                      ("m" . (lambda nil (interactive) (org-todo "MISSED")))

                                      ("A" . org-archive-subtree-default-with-confirmation)
                                      ("N" . org-forward-heading-same-level)
                                      ("P" . org-backward-heading-same-level)
                                      ("J" . org-clock-goto)
                                      ("Z" . ignore))))
#+END_SRC

** latex images
#+BEGIN_SRC emacs-lisp

  (setq org-latex-image-default-width "370pt");; new value just for book export
;; (setq org-latex-image-default-width "180pt") good value, works for QIAGEN for exampl
(setq   org-export-allow-bind-keywords t)
#+END_SRC

** Highlight latex text in org mode
Ben Maughan
Here is a tiny tweak for org-mode. So that inline latex like $y=mx+c$ will appear in a different colour in an org-mode file to help it stand out.

#+BEGIN_SRC emacs-lisp
(setq org-highlight-latex-and-related '(latex))
#+END_SRC

** org-mode key bindings:
#+BEGIN_SRC emacs-lisp
(define-key global-map "\C-cc" 'org-capture)
(global-set-key "\C-cc" 'org-capture)
(global-set-key "\C-cl" 'org-store-link)
(global-set-key "\C-ca" 'org-agenda)
#+END_SRC

** org agenda
*** agenda display settings
#+BEGIN_SRC emacs-lisp
(setq org-agenda-prefix-format
   (quote
    ((agenda . " %?-12t% s")
     (timeline . "  % s")
     (todo . " %i %-12:c")
     (tags . " %i %-12:c")
     (search . " %i %-12:c"))))

;; (setq org-agenda-prefix-format "%t %s")
#+END_SRC

** org settings
#+BEGIN_SRC emacs-lisp
;; (add-hook 'after-init-hook 'org-agenda-list)
(use-package org-inlinetask
  :ensure nil ;; <- don't try to install it
  :defer)
;; Overwrite the current window with the agenda
;; (setq org-agenda-window-setup 'current-window)

;; Delete IDs When Cloning
(setq org-clone-delete-id t)

;; start org in folded mode
(setq org-startup-folded nil)

;; allow alphabetical list entries, i.e. "a. this b. that c. another"
(setq org-alphabetical-lists t)

;; fast TODO selection
(setq org-use-fast-todo-selection t)

;; more org settings
(setq org-treat-S-cursor-todo-selection-as-state-change nil)

(setq org-src-fontify-natively t)

;; (add-to-list 'load-path (expand-file-name "~/git/org-mode/lisp"))
#+END_SRC

** org todo keywords
#+BEGIN_SRC emacs-lisp
(setq org-todo-keywords
   '((sequence "TODO" "STARTED" "|" "DONE")
    ;; (sequence "|" "SKIPPING")
(sequence "MISSED" "|" "DONE")
(sequence "MISSED ❌" "|" "DONE")
(sequence "STARTED" "|" "DONE ✅")
(sequence "STARTED 🏁" "|" "DONE ✅")
(sequence "Example:" "|")
    (sequence "NEED TO INVOICE" "INVOICED" "|" "PAID")
    (sequence "|" "CANCELED")
    ;; (sequence "EXPOSURE ACTIVITY" "|")
    ;; (sequence "MSG" "MESSAGE" "|" "CALLED")
    ;; (sequence "COMMITTED" "RESULTS" "|")
    ;; (sequence "WAITING" "DAILIES" "WEEKLIES" "MONTHLIES" "QUARTERLIES" "YEARLIES" "GOALS" "SOMEDAY" "|")
    ;; (sequence "QUESTION" "|" "ANSWERED")
    ;; (sequence "QUESTIONS" "|" "ANSWERS")
(sequence "Original:" "|" "Revised:")
    ;; (sequence "STRATEGY" "|")
    ;; (sequence "TIP" "|")
(sequence "REWARD" "|" "REWARDED")
    ;; (sequence "NOTES" "RESEARCH" "POINT" "NARRATIVE" "ANECDOTE" "WRITING" "|")
    ;; (sequence "PART" "HED" "HEDTK" "|")
    ;; (sequence "IF" "THEN" "|")
    ;; (sequence "COWRITE" "|" "DONE")
(sequence "TO PROCESS" "|" "PROCESSED")
;; (sequence "GOAL" "PLAN" "NOTE" "|" "DONE")
    ))

;; Set todo keyword colors
(setq org-todo-keyword-faces
 '(
   ("PROCESSED" :foreground "LavenderBlush" :background "darkgrey" :weight bold)
   ("NEXT" :background "medium sea green" :foreground "white" :weight bold)
  ("ACTION" :foreground "medium sea green" :weight bold)
  ("WAITING" :background "yellow" :foreground "purple" :weight bold)
  ("EVENT" :background "gray25" :foreground "white" :weight bold)
    ("PROJECT" :background "firebrick" :foreground "white" :weight bold)
  ("STARTED" :background "dodger blue" :foreground "white" :weight bold)
  ("DONE" :background "white" :foreground "black" :weight bold)))

#+END_SRC

**  hl-todo
#+begin_src emacs-lisp
(use-package hl-todo
:defer t
; ensure t
:hook (org-mode . hl-todo-mode)
 :config

 (setq hl-todo-include-modes '(org-mode))
 (setq hl-todo-keyword-faces
    '(("HOLD" . "#d0bf8f")
     ("TODO" . "#cc9393")
     ("NEXT" . "#dca3a3")
     ("IMPORTANT" . "#dc8cc3")
     ("CONCLUSION" . "#dc8cc3")
     ("SENT" . "#dc8cc3")
     ("REJECTED" . "Red")
     ("TK" . "Red")
     ("tktk" . "Red")
     ("xyz" . "Red")
     ("tk" . "Red")
     ("tktks" . "Red")
   ("Q " . (:foreground "white" :background "#C92228"))
("QUESTION" . (:foreground "white" :background "#C92228"))
     ("GOAL" . "DarkGreen")
     ("PROG" . "#7cb8bb")
     ("OKAY" . "#7cb8bb")
     ("DONT" . "#5f7f5f")
     ("FAIL" . "#8c5353")
     ("DONE" . "#afd8af")
     ("ADMITTED" . "DarkGreen")
     ("NOTE" . "#d0bf8f")
     ("STARTED" . "#d0bf8f")
     ("HACK" . "#d0bf8f")
     ("FIXME" . "#cc9393")
     ("MAYBE" . "#cc9393")
     ("ACTION" . "#cc9393")
     ("PROJECT" . "#cc9393")
     ("XXX" . "#cc9393")
     ("XXXX" . "#cc9393")
     ("\\?\\?\\?" . "#cc9393"))))
#+end_SRC

** org priorities
Make it so that the command =org-priority-up= goes straight to #A
#+BEGIN_SRC emacs-lisp
(setq org-priority-start-cycle-with-default nil)
#+END_SRC

** Protect org headings from accidental demotion
Don't delete headings unless I specifically say so. So i.e. when I hit delete, don't delete stars, only content.
#+BEGIN_SRC emacs-lisp
(defun new-org-delete-backward-char (N)
  (interactive "p")
  (cond ((region-active-p)
         (delete-region
          (region-beginning)
          (region-end)))
        ((looking-back "^\\*+[ ]*") ;; one or more stars
         (previous-line)
         (end-of-line))

;; this is to "don't delete the hyphen markers for plain-text lists"
;; I didn't like it so I turned it off
; (
; (looking-back "^[ ]*- ")
; (previous-line)
; (end-of-line))
(t
(org-delete-backward-char N)
)))

#+END_SRC

** Org-mode hooks and other org settings
#+BEGIN_SRC emacs-lisp
'(initial-major-mode (quote org-mode))
'(org-replace-disputed-keys t)
'(org-use-extra-keys nil)
'(org-adapt-indentation nil)
'(org-edit-src-content-indentation 4)
'(org-ellipsis (quote org-warning))
'(org-enforce-todo-checkbox-dependencies t)
'(org-enforce-todo-dependencies t)
'(org-html-postamble nil)
'(org-fontify-emphasized-text t)
'(org-src-preserve-indentation t)
'(org-startup-align-all-tables t)
'(org-startup-folded showeverything)
'(org-startup-indented nil)

'(org-indent-mode-turns-off-org-adapt-indentation nil)
'(org-indent-mode-turns-on-hiding-stars nil)
'(org-insert-mode-line-in-empty-file t)
'(org-list-indent-offset 3)
'(org-log-done (quote time))
'(org-n-level-faces 9)
'(org-odd-levels-only nil)
'(org-indent-mode 1)
'(org-priority-faces nil)
'(org-provide-checkbox-statistics t)

(defvar my-org-directory "~/Dropbox/writing/notationaldata/")
(defvar my-org-default-notes-file (concat my-org-directory "notes.txt"))

(setq org-directory my-org-directory)
(setq org-default-notes-file my-org-default-notes-file)

#+END_SRC

** Org refile settings
*** Exclude ~DONE~ state tasks from refile targets:
#+BEGIN_EXAMPLE emacs-lisp
(defun bh/verify-refile-target ()
  "Exclude todo keywords with a done state from refile targets"
  (not (member (nth 2 (org-heading-components)) org-done-keywords)))
(setq org-refile-target-verify-function 'bh/verify-refile-target)
#+END_EXAMPLE

** org-capture setup
#+BEGIN_EXAMPLE emacs-lisp
(setq org-capture-templates
      (quote
       (

        ("L" "Later" checkitem (file+headline "fearless.org" "Later") "\n\n [ ] %?\n\n" :prepend t :kill-buffer t)

        ("n" "note" entry (file org-default-notes-file)
	       "* %? :NOTE:\n%U\n%a\n  %i" :prepend t :kill-buffer t :clock-in t :clock-resume t)

        ("b" "book" entry (file "~/Dropbox/writing/book/book-capture.txt")
	       "\n\n\n\n* %U\n\n%?\n\n\n" :prepend t :kill-buffer t)

	      ("v" "visualness and visual actions" entry (file "visual-actions.txt")
	       "\n\n\n\n*  %? %i\n \n" :prepend t :kill-buffer t)

        ("i" "article ideas" entry (file "article-ideas.txt")
	       "\n\n\n\n* %? %i\n \n" :prepend t :kill-buffer t)

        ("e" "expression" entry (file "expression.txt")
	       "\n\n* %U\n  %i\n %?\n" :prepend t :kill-buffer t)

        ("W" "Wise Mind" entry (file "wisemind.txt")
	       "\n\n* wm%?\n" :prepend t :kill-buffer t)

	      ("h" "historical interest" entry (file "historical-lifestream.txt")
	       "\n\n* %U\n  %i\n %?\n" :prepend t :kill-buffer t)

	      ("P" "pages" entry (file "~/Dropbox/writing/notationaldata/pages.txt")
	       "\n\n\n\n* %U\n\n%?\n\n\n" :prepend t :kill-buffer t)

	      ("s" "storytelling and writing" entry (file "/Users/jay/Dropbox/writing/writing-teacher/writing-teacher-stuff/teaching-writing-and-storytelling.txt")
	       "\n\n\n\n* %U\n\n%?" :prepend t :kill-buffer t)

	      ("F" "Funny" entry (file "~/Dropbox/writing/notationaldata/funny.txt")
	       "\n\n\n\n* %U\n\n%?\n" :prepend t :kill-buffer t)

        ("M" "Memorize" entry
         (file+headline (concat org-directory "org-drill-jays-decks.org")
                        "Vocabulary")
         "* Word :drill:\n%^ \n** Answer \n%^")

("f" "Fitness")
("fw" "Weight" table-line
  (id "7c721aac-eafa-4a42-9354-fbc151402510")
  "| | %U | %^{Weight} | %^{Comment}" :immediate-finish t)

        )))
#+END_EXAMPLE

This is working correctly:

** org custom functions
*** update parent cookie
I think this is to make parent ~DONE~ states automatically update:
#+BEGIN_SRC emacs-lisp
(defun myorg-update-parent-cookie ()
  (when (equal major-mode 'org-mode)
    (save-excursion
      (ignore-errors
	(org-back-to-heading)
	(org-update-parent-todo-statistics)))))
;;; -----------------------------------------------------------
;;; Keep parent TODO cookies in sync after killing a line
;;; -----------------------------------------------------------

(defun sed--update-parent-cookie (&rest _)
  "Refresh parent checkbox / todo statistics after editing."
  (myorg-update-parent-cookie))   ; your existing helper

(advice-add 'org-kill-line   :after #'sed--update-parent-cookie)
(advice-add 'kill-whole-line :after #'sed--update-parent-cookie)
#+END_SRC

*** checkbox-list-complete
Mark heading done when all checkboxes are checked. See [[http://thread.gmane.org/gmane.emacs.orgmode/42715][here]]. An item consists of a list with checkboxes. When all of the checkboxes are checked, the item should be considered complete and its ~TODO~ state should be automatically changed to ~DONE~. The code below does that. This version is slightly enhanced over the one in the mailing list (see [[http://thread.gmane.org/gmane.emacs.orgmode/42715/focus=42721][here]]) to reset the state back to TODO if a checkbox is unchecked. Note that the code requires that a checkbox statistics cookie (the [/] or [%] thingie in the headline - see the Checkboxes section in the manual) be present in order for it to work. Note also that it is too dumb to figure out whether the item has a ~TODO~ state in the first place: if there is a statistics cookie, a ~TODO~ / ~DONE~ state will be added willy-nilly any time that the statistics cookie is changed.

#+BEGIN_SRC emacs-lisp
(eval-after-load 'org-list
  '(add-hook 'org-checkbox-statistics-hook (function ndk/checkbox-list-complete)))

(defun ndk/checkbox-list-complete ()
  (save-excursion
    (org-back-to-heading t)
    (let ((beg (point)) end)
      (end-of-line)
      (setq end (point))
      (goto-char beg)
      (if (re-search-forward "\\[\\([0-9]*%\\)\\]\\|\\[\\([0-9]*\\)/\\([0-9]*\\)\\]" end t)
          (if (match-end 1)
              (if (equal (match-string 1) "100%")
                  ;; all done - do the state change
                  (org-todo 'done)
                (org-todo 'todo))
            (if (and (> (match-end 2) (match-beginning 2))
                     (equal (match-string 2) (match-string 3)))
                (org-todo 'done)
              (org-todo 'todo)))))))
#+END_SRC

*** org align tables
#+BEGIN_SRC emacs-lisp
(defun my-align-all-tables ()
  (interactive)
  (org-table-map-tables 'org-table-align 'quietly))
#+END_SRC

*** org extract link
#+BEGIN_SRC emacs-lisp
(defun my-org-extract-link ()
  "Extract the link location at point and put it on the killring."
  (interactive)
  (when (org-in-regexp org-bracket-link-regexp 1)
    (kill-new (org-link-unescape (org-match-string-no-properties 1)))))
#+END_SRC

*** org insert link
Insert link with HTML title as default description. When using `org-insert-link' (`C-c C-l') it might be useful to extract contents from HTML <title> tag and use it as a default link description. Here is a way to accomplish this:

#+BEGIN_SRC emacs-lisp
;; (use-package mm-url) ; to include mm-url-decode-entities-string

;; (defun org-insert-link ()
;;   "Insert org link where default description is set to html title."
;;   (interactive)
;;   (let* ((url (read-string "URL: "))
;;          (title (get-html-title-from-url url)))
;;     (org-insert-link nil url title)))

(defun get-html-title-from-url (url)
  "Return content in <title> tag."
  (let (x1 x2 (download-buffer (url-retrieve-synchronously url)))
    (save-excursion
      (set-buffer download-buffer)
      (beginning-of-buffer)
      (setq x1 (search-forward "<title>"))
      (search-forward "</title>")
      (setq x2 (search-backward "<"))
      (mm-url-decode-entities-string (buffer-substring-no-properties x1 x2)))))
#+END_SRC

*** org insert subtask
#+BEGIN_SRC emacs-lisp
(defun my-org-insert-sub-task ()
  (interactive)
  (let ((parent-deadline (org-get-deadline-time nil)))
    (org-goto-sibling)
    (org-insert-todo-subheading t)
    (when parent-deadline
      (org-deadline nil parent-deadline))))
#+END_SRC

*** reschedule agenda items to today with a single command
#+BEGIN_SRC emacs-lisp
(defun org-agenda-reschedule-to-today ()
  (interactive)
  (cl-flet ((org-read-date (&rest rest) (current-time)))
	   (call-interactively 'org-agenda-schedule)))
#+END_SRC

*** org archive done
Source: [[http://stackoverflow.com/questions/6997387/how-to-archive-all-the-done-tasks-using-a-single-command][link]]
#+BEGIN_SRC emacs-lisp
(defun my-org-archive-done-tasks ()
  (interactive)
  (org-map-entries 'org-archive-subtree "/DONE" 'file))
#+END_SRC

** org-levels
#+BEGIN_SRC emacs-lisp
 (defun org-show-level-1 ()
  (interactive)
 (org-content 1))

 (defun org-show-level-2 ()
  (interactive)
 (org-content 2))

 (defun org-show-level-3 ()
  (interactive)
 (org-content 3))

 (defun org-show-level-4 ()
  (interactive)
 (org-content 4))

 (defun org-show-level-5 ()
  (interactive)
 (org-content 5))

 (defun org-show-level-6 ()
  (interactive)
 (org-content 6))

 (defun org-show-level-7 ()
  (interactive)
 (org-content 7))

 (defun org-show-level-8 ()
  (interactive)
 (org-content 8))

 (define-key key-minor-mode-map (kbd "C-s-1") 'org-show-level-1)

 (define-key key-minor-mode-map (kbd "C-s-2") 'org-show-level-2)

 (define-key key-minor-mode-map (kbd "C-s-3") 'org-show-level-3)

 (define-key key-minor-mode-map (kbd "C-s-4") 'org-show-level-4)

 (define-key key-minor-mode-map (kbd "C-s-5") 'org-show-level-5)

 (define-key key-minor-mode-map (kbd "C-s-6") 'org-show-level-6)

 (define-key key-minor-mode-map (kbd "C-s-7") 'org-show-level-7)

 (define-key key-minor-mode-map (kbd "C-s-8") 'org-show-level-8)

(define-key key-minor-mode-map (kbd "C-s-0") 'show-all)
(define-key key-minor-mode-map (kbd "C-s-a") 'show-all)


#+END_SRC


** org-mode inline tasks
#+BEGIN_SRC emacs-lisp
(define-key key-minor-mode-map (kbd "<M-s-return>") 'org-inlinetask-insert-task)
#+END_SRC

** no autorevert
#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode -1)
#+END_SRC

** globally enable palimpsest-mode
#+BEGIN_SRC emacs-lisp
(add-hook 'find-file-hook (lambda () (palimpsest-mode 1)))
#+END_SRC

* org-mode other packages
** org-pomodoro
#+BEGIN_SRC emacs-lisp
;; (setq org-pomodoro-format "Pomodoro: %s")
;; (setq org-pomodoro-killed-sound "~/sounds/autodestructsequencearmed_ep.mp3")
(setq org-pomodoro-length 25)
(setq org-pomodoro-short-break-length 0.5)
(setq org-pomodoro-long-break-length 30)
(setq org-pomodoro-long-break-sound "/Users/jay/Dropbox/audio/sounds/InkSoundStroke3.mp3")
 (setq org-pomodoro-play-ticking-sounds nil)
;; (setq org-pomodoro-short-break-format "Short Break: %s")
(setq org-pomodoro-short-break-sound "/Users/jay/Dropbox/audio/sounds/Metal_Gong-Dianakc-109711828.mp3")

;; (setq org-pomodoro-finished-sound "/Users/jay/Dropbox/audio/sounds/InkSoundStroke3.mp3")

(setq org-pomodoro-finished-sound "/Users/jay/Dropbox/audio/sounds/Horse-Gallop.mp3")

;; (setq org-pomodoro-ticking-sound "~/Music/iTunes/iTunes Media/Music/Unknown Artist/Unknown Album/com.taptanium.thunderstorm.DreamQuest_preview.m4a")


(defun pomodoro-start ()
  (interactive)
(org-todo 'done)
(previous-line)
(condition-case nil
(org-pomodoro)
 (error nil))
)


(add-hook 'org-pomodoro-finished-hook #'(lambda ()

(do-applescript (format "
ignoring application responses
	tell application \"System Events\"
keystroke \"B\" using {command down, shift down, option down, control down} -- start Pomodoro One
key code {118}
end tell
end ignoring


set now to current date
set nowTime to (hours of now) & \":\" & (minutes of now)
set pomodoroStart to (current date) - 25 * minutes
set pStartTime to (hours of pomodoroStart) & \":\" & (minutes of pomodoroStart)
set achieved to text returned of (display dialog \"What did you achieve in this Pomodoro?\" default answer \"\")
set entry_text to \"# Bookwriting:\" & pStartTime & \" - \" & time string of now & \"

\" & achieved & \"

#pomodoro \"

"))
))

#+END_SRC



From this site ([[https://gist.github.com/judismith/3315418][AppleScript to create Day One entry for hours logged in TaskPaper - Based on the AppleScript from Brett Terpstra to log TaskPaper completed tasks to Day One. This script does both]])

do shell script "echo " & (quoted form of archivedTasks) & "|tr -d \"\\t\"|/usr/local/bin/dayone new"


** org-mac-link
#+BEGIN_SRC emacs-lisp
(use-package org-mac-link
:defer t
  )
#+END_SRC


* Browsing
** Make URLs in comments/strings clickable
#+BEGIN_SRC emacs-lisp
(add-hook 'find-file-hooks 'goto-address-prog-mode)
#+END_SRC

** Set the default browser
#+BEGIN_SRC emacs-lisp
(setq browse-url-browser-function 'browse-url-default-macosx-browser)
#+END_SRC

* Miscellaneous/unsorted settings
#+BEGIN_SRC emacs-lisp
'(cua-enable-cua-keys (quote shift))
'(cua-highlight-region-shift-only t)
'(cua-mode nil nil (cua-base))
'(send-mail-function (quote sendmail-send-it))
'(shift-select-mode nil)
'(transient-mark-mode t)


'(message-send-mail-function (quote message-send-mail-with-sendmail))
'(mail-send-mail-function (quote message-send-mail-with-sendmail))
'(setq mail-user-agent 'message-user-agent)
'(global-set-key [(A-W)]  'buffer-stack-bury-and-kill)
'(ns-right-command-modifier (quote meta))
'(ns-tool-bar-display-mode (quote both) t)
'(ns-tool-bar-size-mode nil t)
;; '(standard-indent 3)
'(ns-function-modifier (quote meta))
(transient-mark-mode t)
(tooltip-mode -1)
(setq ns-function-modifier 'hyper)
;; open files in an existing frame instead of a new frame
(setq ns-pop-up-frames nil)
#+END_SRC

** Open everything in its right mode; use ~org-mode~ whenever possible
#+BEGIN_SRC emacs-lisp
;; ------------------------------------------------------------------
;; File-extension → major-mode rules  (prepend to keep highest priority)
;; ------------------------------------------------------------------
(setq auto-mode-alist
      (append
       '(("\\.txt\\'"                       . org-mode)
         ("\\.calca\\'"                     . org-mode)
         ("\\.tmode\\'"                     . text-mode)
         ("\\.msg\\'"                       . message-mode)
         ("\\.org\\'"                       . org-mode)
         ("\\.org_archive\\'"               . org-mode)
         ("\\.txt_archive\\'"               . org-mode)
         ("README\\'"                       . org-mode)
         ("shared-functions\\'"             . emacs-lisp-mode)
         ("gnu-emacs-startup\\'"            . emacs-lisp-mode)
         ("\\.css\\'"                       . css-mode)
         ("\\.rb\\'"                        . ruby-mode)
         ("Rakefile\\'"                     . ruby-mode)
         ("\\.js\\(?:on\\)?\\'"             . js2-mode)
         ("\\.xml\\'"                       . nxml-mode)
         ("\\.fountain\\'"                  . fountain-mode)
         ("COMMIT_EDITMSG\\'"               . diff-mode)
         ("\\.md\\'"                        . markdown-mode)
         ("\\.mdx\\'"                        . markdown-mode)
         ("\\.abbrev_defs\\'"               . emacs-lisp-mode)
         ("\\.html?\\'"                     . web-mode)
         ("\\.astro?\\'"                    . web-mode)
)
       auto-mode-alist))                    ; keep earlier rules, too

#+END_SRC

** Enable highlighting of text similar to standard word processors
#+BEGIN_SRC emacs-lisp
'(org-support-shift-select (quote always))
#+END_SRC

** Define my default directory:
#+BEGIN_SRC emacs-lisp
(setq default-directory "~/Dropbox/writing/" )
#+END_SRC

* Backups
Sources: [[http://stackoverflow.com/questions/151945/how-do-i-control-how-emacs-makes-backup-files][How do I control how Emacs makes backup files? - Stack Overflow]]

** Make backups:
#+BEGIN_SRC emacs-lisp
;; Default and per-save backups go here:
(setq backup-directory-alist '(("" . "~/emacs/backup/per-save")))

(setq make-backup-files t        ; backup of a file the first time it is saved.
   backup-by-copying t        ; don't clobber symlinks
   version-control t         ; version numbers for backup files
   delete-old-versions t       ; delete excess backup files silently
   delete-by-moving-to-trash t
   kept-old-versions 6        ; oldest versions to keep when a new numbered backup is made (default: 2)
   kept-new-versions 9        ; newest versions to keep when a new numbered backup is made (default: 2)
   auto-save-default t        ; auto-save every buffer that visits a file
   auto-save-timeout 20       ; number of seconds idle time before auto-save (default: 30)
   auto-save-interval 200      ; number of keystrokes between auto-saves (default: 300)
vc-make-backup-files t ; Make backups of files, even when they're in version control
   )
#+END_SRC

** backing up on every save and backing up versioned files.
#+BEGIN_SRC emacs-lisp

(defun force-backup-of-buffer ()
 ;; Make a special "per session" backup at the first save of each
 ;; emacs session.
 (when (not buffer-backed-up)
  ;; Override the default parameters for per-session backups.
  (let ((backup-directory-alist '(("" . "~/.emacs.d/backup/per-session")))
     (kept-new-versions 3))
   (backup-buffer)))
 ;; Make a "per save" backup on each save. The first save results in
 ;; both a per-session and a per-save backup, to keep the numbering
 ;; of per-save backups consistent.
 (let ((buffer-backed-up nil))
  (backup-buffer)))

(add-hook 'before-save-hook 'force-backup-of-buffer)

#+END_SRC

* ~eshell~
#+BEGIN_SRC emacs-lisp

;; (setenv "PATH" (shell-command-to-string "source ~/.profile; echo -n $PATH"))

(setenv "PATH"
        (mapconcat
         #'identity
         '("/opt/homebrew/bin" "/opt/homebrew/sbin"
;; "/Users/jay/work/bin"
;; "/Users/jay/Dropbox/GitHub/terminal_velocity/bin"
;; "/Users/jay/.pyenv/shims" "/Users/jay/.pyenv/bin"
           "/usr/local/bin"                ; Homebrew Intel fallback
           "/usr/bin" "/bin" "/usr/sbin" "/sbin"
           "/Library/TeX/texbin"
           "/Applications/iTerm.app/Contents/Resources/utilities"
           "/Users/jay/Dropbox/apps/bash-scripts"
;; "/Users/jay/.rvm/bin"
)
         ":"))

;; (use-package eshell-autojump)
#+END_SRC

* ~ibuffer~
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-b") 'ibuffer)
(autoload 'ibuffer "ibuffer" "List buffers." t)
#+END_SRC

Defines ~ibuffer-do-replace-string~:
#+BEGIN_SRC emacs-lisp
(define-ibuffer-op replace-string (from-str to-str)
  "Perform a `replace-string' in marked buffers."
  (:interactive
   (let* ((from-str (read-from-minibuffer "Replace string: "))
          (to-str (read-from-minibuffer (concat "Replace " from-str
                                                " with: "))))
     (list from-str to-str))
   :opstring "replaced in"
   :complex t
   :modifier-p :maybe)
  (save-window-excursion
    (switch-to-buffer buf)
    (save-excursion
      (goto-char (point-min))
      (let ((case-fold-search ibuffer-case-fold-search))
        (while (search-forward from-str nil t)
          (replace-match to-str nil t))))
    t))
#+END_SRC

* savefile
** file current locations
#+BEGIN_SRC emacs-lisp
(setq ido-save-directory-list-file "~/emacs/.savefile/ido.hist")
(setq projectile-known-projects-file "~/emacs/.savefile/projectile-bookmarks.eld")
#+END_SRC

** recentf
#+BEGIN_SRC emacs-lisp
(use-package recentf
:defer t
:config
(setq recentf-save-file "/Users/jay/emacs/recentf/recentf")
(setq recentf-max-menu-items 100)
(setq recentf-max-saved-items 100)
(run-with-idle-timer 60 t 'recentf-save-list) ; save recentf automatically so recent files are stored even in the case of abnormal exit
)
#+END_SRC

* Ignore / Exclude Uninteresting Things
** buffer-stack untrack / ignore uninteresting buffers
#+BEGIN_SRC emacs-lisp
(setq buffer-stack-show-position nil)

(setq buffer-stack-untracked (quote ("KILL" "*Compile-Log*" "*Compile-Log-Show*" "*Group*" "*Completions*" "*Messages*" "*Help*" "*Archive*" "*Agenda*" "*fontification*" "*Warnings*" "Calendar" "*Tree:*" "*spacemacs*" "*scratch*" "*Backtrace*" "todo" "TODO" "*org-roam*")))
;; the above I don't think works or at least I don't know how to add to it


;; The below definitely works.
(defun buffer-stack-filter-regexp (buffer)
  "Non-nil if buffer is in buffer-stack-tracked."
  (not (or (string-match "April\\|Help\\|helpful\\|minibuf\\|echo\\|conversion\\|converting\\|agenda\\|server\\|Messages\\|tex\\|Output\\|autoload\\|Customize\\|address\\|clock\\|Backtrace\\|Completions\\|grep\\|Calendar\\|archive\\|Compile-Log\\|tramp\\|helm\\|Alerts\\|Minibuf\\|Agenda\\|Echo\\|gnugol\\|RNC\\|ediff\\|widget\\|melpa\\|git\\|hydra\\|which\\|fontification\\|Helm\\|popwin\\|Custom\\|Warnings\\|tags\\|hours\\|gnugol\\|guide-key\\|scratch\\|vc\\|Compile\\|mm\\|nntpd\\|spacemacs\\|Gnorb\\|quelpa\\|eldoc\\|tar\\|wordnik\\|escape\\|trace\\|debug\\|emacs\\|Re-Builder\\|Ilist\\|orgmode\\|todo\\|loaddefs\\|gnu\\|elpa\\|version\\|alert\\|counsel\\|consult\\|*info*\\|*affe*\\|pixel\\|org-roam\\|width\\|jka\\|123244\\|ediff\\|Org parse\\|EGLOT" (buffer-name buffer))
     (member buffer buffer-stack-untracked))))
(setq buffer-stack-filter 'buffer-stack-filter-regexp)

#+END_SRC

** recentf-exclude
- [[id:8AB9478C-67B4-4DA5-9329-71DE9C03F595][Escape special characters]]
- Use ~*~ for wildcard? Doesn't seem to be necessary

Make it so that recentf does not record the following uninteresting file types:
#+BEGIN_SRC emacs-lisp
;; ------------------------------------------------------------------
;; recentf — paths & patterns we never want to record
;; ------------------------------------------------------------------
(setq recentf-exclude
      '(
        ;; folders / globs
        "/var/"          "elpa"          "cache"          "archive"
        "contacts"       "gnugol"        "helm"           "ido\\.hist"
        "ido\\.last"     "koma"          "message"        "mu2"
        "org-clock-save\\.el" "paths"    "persp-auto"     "recent-addresses"
        "recentf"        "roam/notes"    "rollback-info"  "ssh:"  "shared"
        "agenda"         "bookmark"      "bookmarks"      "Applications"
        "Before"         "Calendar"      "LaTeX"          "Shared"
        "System"         "cache"         "*Org tags*"     "*emacs-settings*"
        "*sent mail*"

        ;; VCS / config dirs
        "\\.git" "\\.emacs\\.d"

        ;; binary or bulky file types
        "\\.\\(?:avi\\|bmk\\|bmp\\|flv\\|gif\\|gz\\|ics\\|jabber\\|jpe?g\\|mkv\\|mov\\|mp[34g]\\|mpeg\\|ogg\\|ogm\\|pdf\\|png\\|pptx?\\|tif\\|wav\\|wmv\\|xls[x]?\\)\\'"
        ;; office / markup you never reopen from recentf
        "\\.\\(?:docx?\\|od[tspg]\\|tex\\|html?\\)\\'"
        ;; src you skip
        "\\.Icon" "\\.css" "\\.xml"
        ))
#+END_SRC

** grep-ignore
#+BEGIN_SRC emacs-lisp
(setq grep-find-ignored-directories
   '("SCCS" "RCS" "CVS" "MCVS" ".svn" ".git" ".hg" ".bzr" "_MTN" "_darcs" "{arch}" "devonthink"))

(setq grep-find-ignored-files
   '(".#*" "*.o" "*~" "*.bin" "*.lbin" "*.so" "*.a" "*.ln" "*.blg" "*.bbl" "*.elc" "*.lof" "*.glo" "*.idx" "*.lot"
    "*.fmt" "*.tfm" "*.class" "*.fas" "*.lib" "*.mem" "*.x86f" "*.sparcf" "*.fasl" "*.ufsl" "*.fsl" "*.dxl" "*.pfsl"
    "*.dfsl" "*.p64fsl" "*.d64fsl" "*.dx64fsl" "*.lo" "*.la" "*.gmo" "*.mo" "*.toc" "*.aux" "*.cp" "*.fn" "*.ky" "*.pg"
    "*.tp" "*.vr" "*.cps" "*.fns" "*.kys" "*.pgs" "*.tps" "*.vrs" "*.pyc" "*.pyo" "*.pdf" "*.tex" "*.html" "*.mm" "*.js"
    "*.doc" "*.pdf" "*.docx" "*.xls" "*.jpg" "*.png" "*.xlsx" "*devonthink*" "*.gif" "#*"))

#+END_SRC

** dired-omit
#+BEGIN_SRC emacs-lisp
(setq dired-omit-files "^\\.[^.]\\|\\.tex$\\|Icon*"

dired-omit-extensions
  (quote
  (".o" "~" ".bin" ".lbin" ".so" ".a" ".ln" ".blg" ".bbl" ".elc" ".lof" ".glo" ".idx" ".lot" ".svn/" ".hg/" ".git/" ".bzr/" "CVS/" "_darcs/" "_MTN/" ".fmt" ".tfm" ".class" ".fas" ".lib" ".mem" ".x86f" ".sparcf" ".dfsl" ".pfsl" ".d64fsl" ".p64fsl" ".lx64fsl" ".lx32fsl" ".dx64fsl" ".dx32fsl" ".fx64fsl" ".fx32fsl" ".sx64fsl" ".sx32fsl" ".wx64fsl" ".wx32fsl" ".fasl" ".ufsl" ".fsl" ".dxl" ".lo" ".la" ".gmo" ".mo" ".toc" ".aux" ".cp" ".fn" ".ky" ".pg" ".tp" ".vr" ".cps" ".fns" ".kys" ".pgs" ".tps" ".vrs" ".pyc" ".pyo" ".idx" ".lof" ".lot" ".glo" ".blg" ".bbl" ".cp" ".cps" ".fn" ".fns" ".ky" ".kys" ".pg" ".pgs" ".tp" ".tps" ".vr" ".vrs" ".html" ".tex" ".git" ".skim" "docx" "mp4" "pptx" "jpeg"))
)


;; (setq dired-omit-files "^\\.[^.]\\|\\.pdf$\\|\\.tex$\\|\\.DS_Store$\\|\\.doc$\\|\\.docx$\\|\\.ini$\\|\\.rtf$\\|\\Icon*\\|\\*.html")

#+END_SRC


* Word count
#+begin_src emacs-lisp
(use-package wc-mode
:defer t
:config
(add-hook 'org-mode-hook 'wc-mode)

(defun word-count (arg)
(interactive "r")
(count-words arg)
 )

(setq wc-modeline-format "[Words: %tw")

(defun count-characters ()
(interactive)
(setq wc-modeline-format "[Words: %tw, Chars: %tc]")
 )
  )

#+end_src

* web research functions
** Sourcing / Citing / Attributing
*** Copy link from Chrome
#+BEGIN_SRC emacs-lisp
(defun org-mac-link-chrome-insert-frontmost-url-with-quotes ()
  "with quotes"
  (interactive)
  (insert "\"")
  (org-mac-link-chrome-insert-frontmost-url)
  (insert ",\"")
  )
#+END_SRC

** Paste notes with attribution
#+BEGIN_SRC emacs-lisp
(defun web-research ()
  (interactive)
  (insert "#+BEGIN_QUOTE\n")
  (let ((p (point)))
    (insert "\n#+END_QUOTE\nSource: ")
    (org-mac-link-chrome-insert-frontmost-url)
    (goto-char p))
  (pasteboard-paste)
  (next-line)
  (next-line)
  (next-line)
    (insert "\n"))
#+END_SRC

** Paste notes with attribution in quotes
#+BEGIN_SRC emacs-lisp
(defun web-research-quotes ()
  (interactive)
  (insert "\"")
    (org-mac-link-chrome-insert-frontmost-url)
       (insert "\,\" "))
#+END_SRC

** html2org
Aliasing this instead now that I'm putting in on Github
#+begin_src emacs-lisp
(defalias 'html2org-clipboard 'chatgpt2org)
#+end_src

Paste HTML using proper org-mode format
Source: [[http://emacs.stackexchange.com/questions/12121/org-mode-parsing-rich-html-directly-when-pasting][source]]
#+BEGIN_EXAMPLE emacs-lisp
(defun html2org-clipboard ()
 "Convert clipboard contents from HTML to Org, remove base64-encoded images, and then paste (yank)."
 (interactive)
(let* ((cmd "osascript -e 'the clipboard as \"HTML\"' | perl -ne 'print chr foreach unpack(\"C*\",pack(\"H*\",substr($_,11,-3)))' | pandoc -f html -t json | pandoc -f json -t org")
    (org-content (shell-command-to-string cmd)))
  (setq org-content (replace-regexp-in-string "\\[\\[data:image[^]]*\\]\\]" "" org-content :fixedcase :literal))

 (setq org-content (replace-regexp-in-string "^\\[\\[https://chat.openai.com.*$" "" org-content))
 (setq org-content (replace-regexp-in-string "^\\[\\[https://lh3.googleusercontent.*$" "" org-content))
 (setq org-content (replace-regexp-in-string "\\n\\n\\n\\n\\n\\n\\n" "\\n\\n" org-content))
 (setq org-content (replace-regexp-in-string "\\n\\n\\n\\n" "\\n\\n" org-content))
(setq org-content (replace-regexp-in-string "^<<.*\n" "" org-content))
(setq org-content (replace-regexp-in-string "" "" org-content))
 (setq org-content (replace-regexp-in-string " " " " org-content))
 (setq org-content (replace-regexp-in-string "\\\\\\\\" "" org-content))
(setq org-content (replace-regexp-in-string ":PROPERTIES:\n\\(.*\n\\)*?:END:" "" org-content))
(setq org-content (replace-regexp-in-string ":PROPERTIES:\\([^\000]*?\\):END:" "" org-content)) ;; somehow leaves stray square brackets in the output

;; Fix the bug
(setq org-content (replace-regexp-in-string "\\(#\\+begin_example\\)\n\\s-*\\([a-zA-Z]*\\)Copy code" "\\1 \\2\n" org-content))

;; Add two line breaks before #+begin for both src and example, and one line break before #+end, and remove leading spaces
  (setq org-content (replace-regexp-in-string "\\(\n\\)?\\s-+\\(#\\+begin_\\(src\\|example\\)\\)" "\n\n\\2" org-content))
  (setq org-content (replace-regexp-in-string "\\(\n\\)?\\s-+\\(#\\+end_\\(src\\|example\\)\\)" "\n\\2" org-content))

;; Add the following line to replace "=" enclosed text with "~" enclosed text
 (setq org-content (replace-regexp-in-string "\\(\\W\\|=\\|^\\)=\\([^=]*\\)=\\(\\W\\|=\\|$\\)" "\\1~\\2~\\3" org-content))

(kill-new org-content)
 (yank)))

#+END_EXAMPLE

** html2org and unfill new version
#+begin_EXAMPLE emacs-lisp
(defun html2org-clipboard-and-unfill-paragraph ()
 "Convert clipboard contents from HTML to Org, remove base64-encoded images, unfill paragraph and then paste (yank)."
 (interactive)
 (html2org-clipboard)
 (let* ((org-content (car kill-ring))) ;; get the most recent item in the kill ring, which is the result of html2org-clipboard

 ;; Unfill paragraph
  (with-temp-buffer
  (insert org-content)
  (goto-char (point-min))
  (while (not (eobp))
   (unfill-paragraph)
   (forward-paragraph))
  (setq org-content (buffer-string)))

  (kill-new org-content)
  (yank)))

#+END_EXAMPLE

** html2org and unfill paragraph. Old version. works
Paste HTML using proper org-mode format
Source: [[http://emacs.stackexchange.com/questions/12121/org-mode-parsing-rich-html-directly-when-pasting][source]]
#+BEGIN_EXAMPLE emacs-lisp
(defun html2org-clipboard-and-unfill-paragraph ()
 "Convert clipboard contents from HTML to Org, remove base64-encoded images, and then paste (yank)."
 (interactive)
(let* ((cmd "osascript -e 'the clipboard as \"HTML\"' | perl -ne 'print chr foreach unpack(\"C*\",pack(\"H*\",substr($_,11,-3)))' | pandoc -f html -t json | pandoc -f json -t org")
    (org-content (shell-command-to-string cmd)))
  (setq org-content (replace-regexp-in-string "\\[\\[data:image[^]]*\\]\\]" "" org-content :fixedcase :literal))

 (setq org-content (replace-regexp-in-string "^\\[\\[https://chat.openai.com.*$" "" org-content))
 (setq org-content (replace-regexp-in-string "^\\[\\[https://lh3.googleusercontent.*$" "" org-content))
 (setq org-content (replace-regexp-in-string "\\n\\n\\n\\n\\n\\n\\n" "\\n\\n" org-content))
 (setq org-content (replace-regexp-in-string "\\n\\n\\n\\n" "\\n\\n" org-content))
(setq org-content (replace-regexp-in-string "^<<.*\n" "" org-content))
(setq org-content (replace-regexp-in-string "" "" org-content))
 (setq org-content (replace-regexp-in-string " " " " org-content))
 (setq org-content (replace-regexp-in-string "\\\\\\\\" "" org-content))
(setq org-content (replace-regexp-in-string ":PROPERTIES:\n\\(.*\n\\)*?:END:" "" org-content))
(setq org-content (replace-regexp-in-string ":PROPERTIES:\\([^\000]*?\\):END:" "" org-content)) ;; somehow leaves stray square brackets in the output

;; Add the following line to replace "=" enclosed text with "~" enclosed text
 (setq org-content (replace-regexp-in-string "\\(\\W\\|=\\|^\\)=\\([^=]*\\)=\\(\\W\\|=\\|$\\)" "\\1~\\2~\\3" org-content))


;; Unfill paragraph
  (with-temp-buffer
   (insert org-content)
   (goto-char (point-min))
   (while (not (eobp))
    (unfill-paragraph)
    (forward-paragraph))
   (setq org-content (buffer-string)))

  (kill-new org-content)
  (yank)))

#+END_EXAMPLE

** html2text-clipboard
#+begin_src emacs-lisp
(defun html2text-clipboard ()
 "Convert clipboard contents from HTML to plain text and paste."
 (interactive)
 (setq cmd "osascript -e 'the clipboard as \"HTML\"' | perl -ne 'print chr foreach unpack(\"C*\",pack(\"H*\",substr($_,11,-3)))' | pandoc -f html -t json | pandoc -f json -t plain")
 (kill-new (shell-command-to-string cmd))
 (yank))

#+end_src


* My custom functions for working with dates and times
#+BEGIN_SRC emacs-lisp
(defun jd-org-current-time ()
  "foo"
  (interactive)
(insert (format-time-string "[%H:%M]"))
  )


(defun jd-org-today ()
  "insert a new heading with today's date"
  (interactive)
(smart-org-meta-return-dwim)
  (org-insert-time-stamp (current-time))
(insert "\n")
)


(defun jd-org-approach ()
 "insert a new heading with today's date"
 (interactive)
(insert "\n** ")
 (org-insert-time-stamp (current-time))
(insert "\n")
(insert "*** TODO morning pages\n")
(insert "*** TODO meditate\n")
(insert "*** TODO work on book\n")
(insert "**** TODO pomodoro #1\n")
(insert "**** TODO pomodoro #2\n")
(insert "*** TODO an approach\n")
)


(defun jd-org-today-and-accountability ()
  "insert a new heading with today's date"
  (interactive)
(insert "\n** committed actions: ")
  (org-insert-time-stamp (current-time))
  (insert " [0%]\n")

(insert "*** TODO wake up by 8:30am\n")
(insert "*** TODO blue light\n")

(insert "*** TODO morning pages\n")
(insert "*** TODO bookwriting [0/8]\n")
(insert "**** TODO bookwriting #1\n")
(insert "**** TODO bookwriting #2\n")
(insert "**** TODO bookwriting #3\n")
(insert "**** TODO bookwriting #4\n")
(insert "**** TODO bookwriting #5\n")
(insert "**** TODO bookwriting #6\n")
(insert "**** TODO bookwriting #7\n")
(insert "**** TODO bookwriting #8\n")
(insert "*** TODO ")
; (left-char)
  )


(defun jd-org-2-book-and-accountability ()
 "insert a new heading with today's date"
 (interactive)
(insert "\n** ")
 (org-insert-time-stamp (current-time))
(insert "\n")
(insert "*** TODO bookwriting [0/2]\n")
(insert "**** TODO bookwriting #1\n")
(insert "**** TODO bookwriting #2\n")
(left-char)
 )


(defun jd-org-today-and-book ()
 "insert a new heading with today's date"
 (interactive)
(insert "\n** ")
 (org-insert-time-stamp (current-time))
(insert "\n")
(insert "*** TODO bookwriting\n")
(pomodoro-start)
(pomidor)
 )


(defun org-book-pomodoro ()
 "Insert a new heading with TODO bookwriting and start a pomodoro timer."
 (interactive)

 (insert "*** TODO bookwriting\n")
(pomidor)
 (pomodoro-start))



(defun jd-clock-in ()
 "Insert a new heading with current time and clock in."
 (interactive)
 (org-insert-heading)
 (org-insert-time-stamp (current-time))
 (org-clock-in)
 (next-line 2))





#+END_SRC

* Prose editing settings
** lowercase
#+begin_src emacs-lisp
(defalias 'lowercase-region 'downcase-region)
#+end_src


** Capitalization
*** Intelligently change punctuation of sentences when I change the capitalization
([[http://endlessparentheses.com/super-smart-capitalization.html][source]]):
#+BEGIN_SRC emacs-lisp

#+END_SRC

** Reconfigure shift-select
For prose editing tasks, make m-s-right and m-s-left behave as they do in
traditional word processors, highlighting whole words at a time:
#+BEGIN_SRC emacs-lisp
(defvar lawlist-movement-syntax-table
  (let ((st (make-syntax-table)))
    (modify-syntax-entry ?{ "." st)  ;; { = punctuation
    (modify-syntax-entry ?} "." st)  ;; } = punctuation
    (modify-syntax-entry ?\" "." st) ;; " = punctuation
    (modify-syntax-entry ?\\ "_" st) ;; \ = symbol
    (modify-syntax-entry ?\$ "_" st) ;; $ = symbol
    (modify-syntax-entry ?\% "_" st) ;; % = symbol
    st)
  "Syntax table used while executing custom movement functions.")

(defun lawlist-forward-entity ()
"http://stackoverflow.com/q/18675201/2112489"
(interactive "^")
  (with-syntax-table lawlist-movement-syntax-table
    (cond
      ((eolp)
        (forward-char))
      ((and
          (save-excursion (< 0 (skip-chars-forward " \t")))
          (not (region-active-p)))
        (skip-chars-forward " \t"))
      ((and
          (save-excursion (< 0 (skip-chars-forward " \t")))
          (region-active-p))
        (skip-chars-forward " \t")
        (cond
          ((save-excursion (< 0 (skip-syntax-forward "w")))
            (skip-syntax-forward "w"))
          ((save-excursion (< 0 (skip-syntax-forward ".")))
            (skip-syntax-forward "."))
          ((save-excursion (< 0 (skip-syntax-forward "_()")))
            (skip-syntax-forward "_()"))))
      ((save-excursion (< 0 (skip-syntax-forward "w")))
        (skip-syntax-forward "w")
        (if (and
              (not (region-active-p))
              (save-excursion (< 0 (skip-chars-forward " \t"))))
          (skip-chars-forward " \t")))
      ((save-excursion (< 0 (skip-syntax-forward ".")))
        (skip-syntax-forward ".")
        (if (and
              (not (region-active-p))
              (save-excursion (< 0 (skip-chars-forward " \t"))))
          (skip-chars-forward " \t")))
      ((save-excursion (< 0 (skip-syntax-forward "_()")))
        (skip-syntax-forward "_()")
        (if (and
              (not (region-active-p))
              (save-excursion (< 0 (skip-chars-forward " \t"))))
          (skip-chars-forward " \t"))))))

(defun lawlist-backward-entity ()
"http://stackoverflow.com/q/18675201/2112489"
(interactive "^")
  (with-syntax-table lawlist-movement-syntax-table
    (cond
      ((bolp)
        (backward-char))
      ((save-excursion (> 0 (skip-chars-backward " \t")) (bolp))
        (skip-chars-backward " \t"))
      ((save-excursion (> 0 (skip-chars-backward " \t")) (> 0 (skip-syntax-backward "w")))
        (skip-chars-backward " \t")
        (skip-syntax-backward "w"))
      ((save-excursion (> 0 (skip-syntax-backward "w")))
        (skip-syntax-backward "w"))
      ((save-excursion (> 0 (skip-syntax-backward ".")))
        (skip-syntax-backward "."))
      ((save-excursion (> 0 (skip-chars-backward " \t")) (> 0 (skip-syntax-backward ".")))
        (skip-chars-backward " \t")
        (skip-syntax-backward "."))
      ((save-excursion (> 0 (skip-syntax-backward "_()")))
        (skip-syntax-backward "_()"))
      ((save-excursion (> 0 (skip-chars-backward " \t")) (> 0 (skip-syntax-backward "_()")))
        (skip-chars-backward " \t")
        (skip-syntax-backward "_()")))))

(define-key global-map [M-s-right] 'lawlist-forward-entity)
(define-key global-map [M-s-left] 'lawlist-backward-entity)
#+END_SRC

** Working with windows
Transpose windows, useful:
#+BEGIN_SRC emacs-lisp
(defun transpose-windows (arg)
  "Transpose the buffers shown in two windows."
  (interactive "p")
  (let ((selector (if (>= arg 0) 'next-window 'previous-window)))
    (while (/= arg 0)
      (let ((this-win (window-buffer))
	    (next-win (window-buffer (funcall selector))))
	(set-window-buffer (selected-window) next-win)
	(set-window-buffer (funcall selector) this-win)
	(select-window (funcall selector)))
      (setq arg (if (plusp arg) (1-arg) (1+ arg))))))
#+END_SRC

* move stuff around
** org-refile
#+BEGIN_SRC emacs-lisp
(setq org-outline-path-complete-in-steps nil) ; Refile in a single go
(setq org-completion-use-ido nil)
(setq org-refile-use-outline-path t) ; Show full paths for refiling



(defun my-org-files-list ()
 (delq nil
  (mapc (lambda (buffer)
   (buffer-file-name buffer))
   (org-buffer-list 'files t))))

(setq org-refile-targets '((my-org-files-list :maxlevel . 4)))


;; allow refile to create parent tasks with confirmation:
(setq org-refile-allow-creating-parent-nodes (quote confirm))

; (setq org-goto-interface 'outline-path-completion org-goto-max-level 3)



#+END_SRC

** Refile region
Refile highlighted to a particular heading ([[http://stackoverflow.com/questions/25256304/in-emacs-org-mode-how-to-refile-highlighted-text-under-an-org-heading/25262538?iemail=1&noredirect=1#25262538][Source]]):

#+BEGIN_SRC emacs-lisp
(defvar refile-region-format "\n%s\n")

(defvar refile-region-position 'top
  "Where to refile a region. Use 'bottom to refile at the
end of the subtree. ")

(defun jay-refile-region (beg end copy)
  "Refile the active region.
If no region is active, refile the current paragraph.
With prefix arg C-u, copy region instad of killing it."
  (interactive "r\nP")
  ;; mark paragraph if no region is set
  (unless (use-region-p)
    (setq beg (save-excursion
                (backward-paragraph)
                (skip-chars-forward "\n\t ")
                (point))
          end (save-excursion
                (forward-paragraph)
                (skip-chars-backward "\n\t ")
                (point))))
  (let* ((target (save-excursion (org-refile-get-location)))
         (file (nth 1 target))
         (pos (nth 3 target))
         (text (buffer-substring-no-properties beg end)))
    (unless copy (kill-region beg end))
    (deactivate-mark)
    (with-current-buffer (find-file-noselect file)
      (save-excursion
        (goto-char pos)
        (if (eql refile-region-position 'bottom)
            (org-end-of-subtree)
          (org-end-of-meta-data))
        (insert (format refile-region-format text))))))


#+END_SRC


** move-region-or-subtree-to-other-window
#+BEGIN_SRC emacs-lisp
(defun move-region-or-subtree-to-other-window ()
 (interactive)
 (when (and (eq 'org-mode major-mode)
       (not (region-active-p)))
  (org-mark-subtree))
 (let ((text (buffer-substring (region-beginning) (region-end))))
  (delete-region (region-beginning) (region-end))
  (other-window 1)
  (insert text)))
#+END_SRC

** copy-region
#+begin_src emacs-lisp
(defun copy-region-to-other-window ()
 (interactive)
 (when (region-active-p)
  (let ((text (buffer-substring (region-beginning) (region-end))))
   (other-window 1)
   (insert text)
   (other-window -1))))
#+end_src

* Remove hyperlink
A useful function: remove a hyperlink but leave the link description:

** new
#+begin_src emacs-lisp
(defun remove-link-at-point ()
  "Replace an org link by its description or if empty its address"
 (interactive)
 (if (org-in-regexp org-link-bracket-re 1)
   (save-excursion
    (let ((remove (list (match-beginning 0) (match-end 0)))
       (description
        (if (match-end 2)
          (org-match-string-no-properties 2)
         (org-match-string-no-properties 1))))
     (apply 'delete-region remove)
     (insert description)))))
#+end_src
Source: [[https://emacs.stackexchange.com/questions/10707/in-org-mode-how-to-remove-a-link][in org-mode, how to remove a link? - Emacs Stack Exchange]]

** remove hyperlinks in buffer
#+begin_src emacs-lisp
(defun remove-hyperlinks ()
  "Remove Org bracket links depending on context:
- If region is active, remove only links in the region.
- Else if point is on a link, remove just that link.
- Otherwise, prompt to remove all links in the buffer."
  (interactive)
;;  (require 'org)  ; Make sure org functions/variables are loaded
  (cond
   ;; 1) If region is highlighted, remove links only in that region:
   ((use-region-p)
    (save-restriction
      (narrow-to-region (region-beginning) (region-end))
      (goto-char (point-min))
      (while (re-search-forward org-bracket-link-regexp nil t)
        (replace-match (match-string 2) t t))))

   ;; 2) Else, if point is on a link, remove just that link:
   ((org-in-regexp org-bracket-link-regexp 1)
    (let ((visible-text (match-string-no-properties 2)))
      (replace-match visible-text t t)))

   ;; 3) Otherwise, prompt and remove all links in buffer:
   (t
    (when (y-or-n-p "Remove all hyperlinks in the buffer? ")
      (goto-char (point-min))
      (while (re-search-forward org-bracket-link-regexp nil t)
        (replace-match (match-string 2) t t))))))

(defun remove-org-links-and-newlines ()
 "Remove all Org mode style links from the current buffer, also removing any newlines from the description."
 (interactive)
 (save-excursion
  (goto-char (point-min))
  (while (re-search-forward "\\[\\[\\([^]]+\\)\\]\\[\\([^]]+\\)\\]\\]" nil t)
   (let ((description (match-string 2)))
    ;; Replace newline characters with a space in the description
    (setq description (replace-regexp-in-string "\n" " " description))
    (replace-match description)))))

#+end_src


* Working with files
** Reopen last closed file, very useful:
#+BEGIN_SRC emacs-lisp
(defun recentf-open-files-compl ()
  (interactive)
  (let* ((all-files recentf-list)
	 (tocpl (mapcar (function
			 (lambda (x) (cons (file-name-nondirectory x) x))) all-files))
	 (prompt (append '("File name: ") tocpl))
	 (fname (completing-read (car prompt) (cdr prompt) nil nil)))
    (find-file (cdr (assoc-string fname tocpl)))))

(global-set-key [(control x)(control r)] 'recentf-open-files-compl)

(defun visit-most-recent-file ()
  "Visits the most recently open file in `recentf-list' that is not already being visited."
  (interactive)
  (let ((buffer-file-name-list
         (mapcar 'file-truename
                 (remove nil (mapcar 'buffer-file-name (buffer-list)))))
        (recent-files-names (delete-dups (mapcar 'file-truename recentf-list)))
        most-recent-filename)
    (dolist (filename recent-files-names)
      (unless (member filename buffer-file-name-list)
        (setq most-recent-filename filename)
        (cl-return)))
    (ignore-errors (find-file most-recent-filename))))

#+END_SRC

** Copy path
Useful for working with files and references:

Add 'filename' to the kill ring *without duplicating it* if it's already there.
#+BEGIN_SRC emacs-lisp




(defun path-copy-path-to-clipboard ()
 "Copy the full current filename and path to the clipboard."
 (interactive)
 ;; Define a local variable 'filename' to store the path of the current file or directory.
 (let ((filename (if (equal major-mode 'dired-mode)
           default-directory ; If in 'dired-mode', use the current directory.
          (buffer-file-name)))) ; Otherwise, use the file path of the current buffer.
  ;; Check if 'filename' is non-nil and is not the latest entry in the kill ring.
  (when (and filename (not (equal filename (car kill-ring))))
   ;; Add 'filename' to the kill ring without duplicating it if it's already there.
   (kill-new filename)
   ;; Use a temporary buffer to copy 'filename' to the system clipboard.
   (with-temp-buffer
    (insert filename)
    (clipboard-kill-region (point-min) (point-max))))
  ;; Provide feedback to the user.
  (when filename
   (message "Copied to clipboard: %s" filename)))
 ;; Use custom function to ensure the clipboard content is also in the kill ring.
 (push-kill-ring-pasteboard-to-MacOS-clipboard))

#+END_SRC

** Copy path with quotes
Useful for working with files and references:
#+BEGIN_SRC emacs-lisp
(defun path-copy-path-to-clipboard-with-quotes ()
  "Copy the full current filename and path to the clipboard"
  (interactive)
  (let ((filename (if (equal major-mode 'dired-mode)
                      default-directory
                    (buffer-file-name))))
    (when filename
      (with-temp-buffer
        (insert filename)
        (clipboard-kill-region (point-min) (point-max)))
      (message filename)))
  (push-kill-ring-pasteboard-to-MacOS-clipboard)
)
#+END_SRC

* save some buffers
#+BEGIN_SRC emacs-lisp
;; -*- lexical-binding: t; -*-

(defun jay/save-all-buffers ()
  "Silently save every buffer that is visiting a file.
If the file does not yet exist on disk, create it without
confirmation.  Non–file‑visiting buffers are ignored."
  (interactive)
  (let ((confirm-nonexistent-file-or-buffer nil)) ; suppress “create file?” prompt
    (dolist (buf (buffer-list))
      (with-current-buffer buf
        (when buffer-file-name
          (when (or (buffer-modified-p)
                    (not (file-exists-p buffer-file-name)))
            (save-buffer)))))))
#+END_SRC

* Keybindings
Best guide to [[http://www.nongnu.org/emacs-tiny-tools/keybindings/][keybindings]].

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-C-N") 'outline-next-visible-heading)
(global-set-key (kbd "M-C-P") 'outline-previous-visible-heading)
(define-key key-minor-mode-map (kbd "M-C-N") 'outline-next-visible-heading)
(define-key key-minor-mode-map (kbd "M-C-P") 'outline-previous-visible-heading)

(global-set-key (kbd "M-N") 'org-forward-heading-same-level)
(global-set-key (kbd "M-n") 'org-next-visible-heading)
(global-set-key (kbd "M-P") 'org-backward-heading-same-level)
(global-set-key (kbd "M-p") 'org-previous-visible-heading)
(define-key key-minor-mode-map (kbd "M-N") 'org-forward-heading-same-level)
(define-key key-minor-mode-map (kbd "M-P") 'org-backward-heading-same-level)


(define-key key-minor-mode-map (kbd "M-{") 'org-backward-heading-same-level)
(define-key key-minor-mode-map (kbd "M-}") 'org-forward-heading-same-level)
(define-key key-minor-mode-map (kbd "M-[") 'org-backward-heading-same-level)
(define-key key-minor-mode-map (kbd "M-]") 'org-forward-heading-same-level)

(global-set-key (kbd "s-p") 'org-export-dispatch)
(define-key key-minor-mode-map (kbd "s-p") 'org-export-dispatch)

(define-key global-map (kbd "<C-wheel-up>") (lambda ()
                                              (interactive)
                                              (scroll-up-command)))
(define-key global-map (kbd "<C-wheel-down>") (lambda ()
                                               (interactive)
                                               (scroll-down-command)))

(global-set-key "\C-f" 'forward-word)
(global-set-key "\C-b" 'backward-word)

(global-set-key '[(f5)] 'point-stack-push)
(global-set-key '[(f6)] 'point-stack-pop)
(global-set-key '[(f7)] 'point-stack-forward-stack-pop)
(global-set-key '[(f8)] 'search-open-buffers)

(define-key key-minor-mode-map (kbd "<M-S-backspace>") 'backward-kill-sexp)
(define-key key-minor-mode-map (kbd "<M-S-backspace>") 'backward-kill-sexp)
(define-key key-minor-mode-map (kbd "<M-S-backspace>") 'backward-kill-sexp)
(define-key key-minor-mode-map (kbd "<M-S-backspace>") 'backward-kill-sexp)
#+END_SRC

Make ^H delete rather than help:
#+BEGIN_SRC emacs-lisp
;; (global-set-key (kbd "C-h") 'delete-backward-char)
#+END_SRC

Redefine help shortcut:
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-h") 'help-command)
#+END_SRC


** flyspell-correct-space
#+begin_src emacs-lisp
(defun flyspell-auto-correct-word-correct-space ()
  (interactive)
  (when (looking-back " " nil)
    (left-char 1))
  (flyspell-auto-correct-word)
  )

#+end_src

#+BEGIN_SRC emacs-lisp
(global-set-key "\C-ce" 'eval-buffer)
(global-set-key "\C-cr" 'eval-region)
;; (define-key org-mode-map (kbd "`") 'flyspell-auto-correct-word)
(define-key org-mode-map (kbd "`") 'flyspell-auto-correct-word-correct-space)
;; (define-key org-mode-map (kbd "`") 'flyspell-auto-correct-previous-word)
(global-set-key (kbd "s-z") 'undo)
(global-set-key (kbd "s-y") 'redo)
#+END_SRC

** cut-subtree
   :PROPERTIES:
   :ID:       D283A971-F9C3-4683-A419-82F7D9816F72
   :END:

#+BEGIN_SRC emacs-lisp
(define-key key-minor-mode-map (kbd "M-s-k") 'org-cut-subtree)
(define-key key-minor-mode-map (kbd "C-s-k") 'org-cut-subtree)
#+END_SRC

* Searching for things
** isearch
*** isearch settings
#+BEGIN_SRC emacs-lisp
(defun my-isearch-word-at-point ()
  (interactive)
  (call-interactively 'isearch-forward-regexp))

(defun my-isearch-yank-word-hook ()
  (when (equal this-command 'my-isearch-word-at-point)
    (let ((string (concat "\\<"
			  (buffer-substring-no-properties
			   (progn (skip-syntax-backward "w_") (point))
			   (progn (skip-syntax-forward "w_") (point)))
			  "\\>")))
      (if (and isearch-case-fold-search
	       (eq 'not-yanks search-upper-case))
	  (setq string (downcase string)))
      (setq isearch-string string
	    isearch-message
	    (concat isearch-message
		    (mapconcat 'isearch-text-char-description
			       string ""))
	    isearch-yank-flag t)
      (isearch-search-and-update))))

(add-hook 'isearch-mode-hook 'my-isearch-yank-word-hook)

;; (global-set-key "\C-cw" 'my-isearch-word-at-point)
#+END_SRC

*** Position of the Cursor after Searching
Note that when you type ‘C-r’, isearch goes backwards. When you search
backwards, find something, and then end the search, for example by hitting
‘RET’, point is at the beginning of the string you searched. When you search
forwards, point is not necessarily at the end of the string you were searching
for, but only after the last character that you typed – bad usability! That
means that you cannot predict point based on the string you are searching for
(and thinking about). You must predict point based on the numbers of characters
you typed. Here is how to change that in your InitFile, courtesy of
AdrianKubala:

#+BEGIN_SRC emacs-lisp
(add-hook 'isearch-mode-end-hook 'my-goto-match-beginning)

(defun my-goto-match-beginning ()
  (when (and isearch-forward isearch-other-end)
    (goto-char isearch-other-end)))

(defadvice isearch-exit (after my-goto-match-beginning activate)
  "Go to beginning of match."
  (when (and isearch-forward isearch-other-end)
    (goto-char isearch-other-end))
(recenter-top-bottom)
)

(defun isearch-from-buffer-start ()
  (interactive)
  (push-mark)
  (goto-char (point-min))
  (isearch-forward))
#+END_SRC


** projectile
#+BEGIN_SRC emacs-lisp
(use-package vertico
  :init
  (vertico-mode))

(use-package projectile
:defer t
  :diminish projectile-mode
  :init
  (projectile-mode +1)

  :custom
  (projectile-completion-system 'default) ;; Vertico integrates via default
  (projectile-enable-caching t)

  (projectile-globally-ignored-file-suffixes '("docx" "jpg" "png" "tmp" "tex" "html" "pdf" "pptx" "tmp"))

  (projectile-globally-ignored-directories
   '(".idea" ".eunit" ".git" ".hg" ".fslckout" ".bzr" "_darcs" ".tox" ".svn" ".tmp" "archived-work" "images" "excel-mindnode-omni" "archive"))

  (projectile-globally-ignored-files '("TAGS" ".DS_Store" ".projectile" ".dropbox"))

  :bind-keymap
  ("C-c p" . projectile-command-map)

  :bind
  (:map projectile-mode-map
        ("s-o" . nil)))
#+END_SRC

** isearch

*** isearch arrow keys
  Here's very convenient keys for isearch. Put it in your emacs init.


#+BEGIN_SRC emacs-lisp

(progn
  ;; set arrow keys in isearch. left/right is backward/forward, up/down is history. press Return to exit
;;  (define-key isearch-mode-map (kbd "<up>") 'isearch-ring-retreat )
;; (define-key isearch-mode-map (kbd "<down>") 'isearch-ring-advance )
  (define-key isearch-mode-map (kbd "<tab>") 'isearch-ring-advance )
  (define-key isearch-mode-map (kbd "<S-tab>") 'isearch-repeat-backward) ; single key, useful

;  (define-key isearch-mode-map (kbd "<right>") 'isearch-repeat-forward) ; single key, useful
 )

#+END_SRC


  when in isearch, the arrow keys will:

  → next occurrence.
  ← previous occurrence.
  ↑ previous search term.
  ↓ next search term.
  Enter ↵ exit isearch.

  This way, searching forward/backward is just one single key press, no key combination.

  This is especially useful with a command that searches current word. See: Emacs: isearch Current Word.



** searching

*** swiper
**** ivy
#+BEGIN_EXAMPLE emacs-lisp
(use-package ivy


 :config
 (ivy-add-actions t
    '(("W" kill-new "save to kill ring")
     ("I" insert "insert in buffer")))
(define-key ivy-minibuffer-map (kbd "SPC") 'insert-space)
(define-key ivy-minibuffer-map (kbd "s-v") 'pasteboard-paste-raw)
(setq ivy-height 25)
(setq ivy-display-style 'fancy)

)
#+END_EXAMPLE

**** swiper
#+BEGIN_EXAMPLE emacs-lisp
;; (global-set-key (kbd "C-s") 'swiper)
(setq ivy-re-builders-alist
 '((t . ivy--regex-plus)))

(define-key key-minor-mode-map (kbd "C-7") 'swiper-mc)

#+END_EXAMPLE

**** swiper hydra
#+BEGIN_EXAMPLE emacs-lisp
(defun ivy-dired-mark (arg)
 (interactive "p")
 (dotimes (_i arg)
  (with-selected-window swiper--window
   (dired-mark 1))
  (ivy-next-line 1)
  (ivy--exhibit)))

(defun ivy-dired-unmark (arg)
 (interactive "p")
 (dotimes (_i arg)
  (with-selected-window swiper--window
   (dired-unmark 1))
  (ivy-next-line 1)
  (ivy--exhibit)))

(defun ivy-replace ()
 (interactive)
 (let ((from (with-selected-window swiper--window
        (move-beginning-of-line nil)
        (when (re-search-forward
            (ivy--regex ivy-text) (line-end-position) t)
         (match-string 0)))))
  (if (null from)
    (user-error "No match")
   (let ((rep (read-string (format "Replace [%s] with: " from))))
    (with-selected-window swiper--window
     (undo-boundary)
     (replace-match rep t t))))))

(defun ivy-undo ()
 (interactive)
 (with-selected-window swiper--window
  (undo)))


(defhydra hydra-ivy (:hint nil
           :color pink)
 "
^^^^^^     ^Actions^  ^Dired^   ^Quit^
^^^^^^--------------------------------------------
^ ^ _l_ ^ ^   _._ repeat  _m_ark   _i_: cancel
_j_ ^✜^ _;_   _r_eplace  _,_ unmark _o_: quit
^ ^ _k_ ^ ^   _u_ndo
"
 ;; arrows
 ("j" ivy-beginning-of-buffer)
 ("k" ivy-next-line)
 ("l" ivy-previous-line)
 (";" ivy-end-of-buffer)
 ;; actions
 ("." hydra-repeat)
 ("r" ivy-replace)
 ("u" ivy-undo)
 ;; dired
 ("m" ivy-dired-mark)
 ("," ivy-dired-unmark)
 ;; exit
 ("o" keyboard-escape-quit :exit t)
 ("i" nil))

(define-key ivy-minibuffer-map (kbd "C-o") 'hydra-ivy/body)

#+END_EXAMPLE

** searching

*** Tell isearch that curly apostrophes are the same as straight ones
 Source: [[http://endlessparentheses.com/ispell-and-apostrophes.html][Ispell and Apostrophes in Emacs]]

#+BEGIN_SRC emacs-lisp
 ;;; Tell ispell.el that ’ can be part of a word.
(setq ispell-local-dictionary-alist
      `((nil "[[:alpha:]]" "[^[:alpha:]]"
             "['\x2019]" nil ("-B") nil utf-8)))

;;; Don't send ’ to the subprocess.
(defun endless/replace-apostrophe (args)
  (cons (replace-regexp-in-string
         "’" "'" (car args))
        (cdr args)))
(advice-add #'ispell-send-string :filter-args
            #'endless/replace-apostrophe)

;;; Convert ' back to ’ from the subprocess.
(defun endless/replace-quote (args)
  (if (not (derived-mode-p 'org-mode))
      args
    (cons (replace-regexp-in-string
           "'" "’" (car args))
          (cdr args))))
(advice-add #'ispell-parse-output :filter-args
            #'endless/replace-quote)
#+END_SRC




* these seem to need to go at the end
** Palimpsest - best ever
#+BEGIN_SRC emacs-lisp
;; (use-package palimpsest)
(add-hook 'after-init-hook
          (lambda ()
            (palimpsest-mode 1)
            (global-hl-todo-mode 1)
            (projectile-mode  1)))
(define-key org-mode-map (kbd "C-c C-r") 'palimpsest-move-region-to-bottom)
#+END_SRC

C-C C-R to move text to the bottom of the buffer

** Make block quotes appear nicely in buffer, displaying > instead of :
This doesn't seem to be working.

http://thread.gmane.org/gmane.emacs.orgmode/64980/focus=65987
#+BEGIN_SRC emacs-lisp
(font-lock-add-keywords
 'org-mode '(("^\\(:+\\) " 1 (compose-region (match-beginning 1) (match-end 1) ?❱) nil)))
#+END_SRC

* replace word
#+BEGIN_SRC emacs-lisp
(defun replace-word (tosearch toreplace)
  (interactive "sSearch for word: \nsReplace with: ")
  (save-excursion
    (goto-char (point-min))
    (let ((case-fold-search nil)
          (count 0))
      (while (re-search-forward (concat "\\b" tosearch "\\b") nil t)
        (setq count (1+ count))
        (replace-match toreplace 'fixedcase 'literal))
      (message "Replaced %s match(es)" count))))
#+END_SRC


* org-links
* update packages
 (run-with-idle-timer 6000 t 'endless/upgrade)

* pop to mark
Handy way of getting back to previous places.

#+BEGIN_SRC emacs-lisp
;(setq set-mark-command-repeat-pop t)
#+END_SRC

* Treat all themes as safe
#+BEGIN_SRC emacs-lisp
(setq custom-safe-themes t)
#+END_SRC


* org-toggle-heading-same-level
#+BEGIN_SRC emacs-lisp
(defun org-toggle-heading-same-level ()
  "Toggles the current line between a non-heading and TODO heading."
  (interactive)
  (let ((is-heading))
    (save-excursion
      (forward-line 0)
      (when (looking-at "^\\*")
        (setq is-heading t)))
    (if is-heading
        (progn
          (org-todo 'none) ; remove TODO
          (org-toggle-heading)) ; remove heading
      (progn
        (org-toggle-heading) ; convert to heading
(org-do-promote)
;        (org-todo 'nextset)
)))) ; add TODO#+END_SRC
#+END_SRC

* org-toggle-todo-heading
#+BEGIN_SRC emacs-lisp
(defun org-toggle-todo-heading ()
  "Toggles the current line between a non-heading and TODO heading."
  (interactive)
  (let ((is-heading))
    (save-excursion
      (forward-line 0)
      (when (looking-at "^\\*")
        (setq is-heading t)))
    (if is-heading
        (progn
          (org-todo 'none) ; remove TODO
          (org-toggle-heading)) ; remove heading
      (progn
        (org-toggle-heading) ; convert to heading
(org-do-promote)
        (org-todo 'nextset))))) ; add TODO#+END_SRC
#+END_SRC

* delete-extra-whitespace-region
#+BEGIN_SRC emacs-lisp
(defun delete-extra-whitespace-region (beg end)
  "replace all whitespace in the region with single spaces"
  (interactive "r")
  (save-excursion
    (save-restriction
      (narrow-to-region beg end)
      (goto-char (point-min))
      (while (re-search-forward "^\\s-+" nil t)
        (replace-match "")))))
#+END_SRC

* double-line-breaks-in-region
#+BEGIN_SRC emacs-lisp
(defun double-line-breaks-in-region (begin end)
  (interactive "r")
  (xah-replace-pairs-region begin end
 '(
 ["\r" "\n\n"]
["\n" "\n\n"]
)))
#+END_SRC

* xah-replace-pairs
(use-package xah-replace-pairs
:defer
)
#+BEGIN_SRC emacs-lisp

(defun xah-convert-entities-to-html-chars-region (begin end)
  (interactive "r")
  (xah-replace-pairs-region begin end
 '(
 ["&" "&amp;"]
 ["<" "&lt;"]
 [">" "&gt;"]
 )))


(defun xah-convert-html-chars-to-entities-region (begin end)
 (interactive "r")
 (xah-replace-pairs-region begin end
 '(
 ["&amp;" "&"]
 ["&lt;" "<"]
 ["&gt;" ">"]
 )))

#+END_SRC

* Monochrome rainbows are the best way to reveal unbalanced delimiters
I rely and paredit and formatting to keep my parenthesis honest, and for the most part that works out great. Occasionally I need to go outside the box. Emacs defaults are terrible for finding unbalanced forms when things go wrong. This setting makes it obvious that there is an error when I have fallen out with my grouping delimiters.

The trick is to not use different colored delimiters! The reason I need the rainbow delimiters package is only to highlight unbalanced delimiters, which it does quickly and accurately. For those cases where I really want to differentiate a group, placing the cursor on the delimiter causes Emacs to highlight the other delimiter.

#+BEGIN_EXAMPLE emacs-lisp
(add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
(add-hook 'emacs-lisp-mode-hook #'rainbow-delimiters-mode)
(use-package rainbow-delimiters
:defer t)
(set-face-attribute 'rainbow-delimiters-unmatched-face nil
                    :foreground 'unspecified
                    :inherit 'error)
#+END_EXAMPLE


* contract-contractions
#+BEGIN_SRC emacs-lisp

(defun contract-contractions (begin end)
(interactive "r")
  (xah-replace-pairs-region begin end
 '(
 ["I have" "I've"]
["I am" "I'm"]
)))

#+END_SRC

* fix double capitals
Source: [[http://endlessparentheses.com/fixing-double-capitals-as-you-type.html?source%3Drss][Fixing DOuble CApitals as you type · Endless Parentheses]]

#+BEGIN_SRC emacs-lisp
(defun dcaps-to-scaps ()
  "Convert word in DOuble CApitals to Single Capitals."
  (interactive)
  (and (= ?w (char-syntax (char-before)))
       (save-excursion
         (and (if (called-interactively-p)
                  (skip-syntax-backward "w")
                (= -3 (skip-syntax-backward "w")))
              (let (case-fold-search)
                (looking-at "\\b[[:upper:]]\\{2\\}[[:lower:]]"))
              (capitalize-word 1)))))

(add-hook 'post-self-insert-hook #'dcaps-to-scaps nil 'local)

(define-minor-mode dubcaps-mode
  "Toggle `dubcaps-mode'.  Converts words in DOuble CApitals to
Single Capitals as you type."
  :init-value nil
  :lighter (" DC")
  (if dubcaps-mode
      (add-hook 'post-self-insert-hook #'dcaps-to-scaps nil 'local)
    (remove-hook 'post-self-insert-hook #'dcaps-to-scaps 'local)))

#+END_SRC

* yasnippets
** yasnippets
#+BEGIN_SRC emacs-lisp
(defun yas-expand-and-copy-to-clipboard (&optional field)
  "Expand snippet at point and copy the expansion to the clipboard.

Optional argument FIELD is for non-interactive use and is an
object satisfying `yas--field-p' to restrict the expansion to."
  (interactive)
  (let ((yas-triggers-in-field t)
        (yas-fallback-behavior nil))
    (setq field (yas-expand-from-trigger-key field))
    (when field
      (when (eq field t)
        (let ((snippet (car (yas-active-snippets))))
          (setq field (yas--snippet-exit snippet))))
      (gui-select-text (yas--field-start field)
                       (yas--field-end field))
      (clipboard-kill-ring-save (yas--field-start field)
                                (yas--field-end field)))))

(use-package yasnippet
  :defer t
  :ensure t
  :bind
  (("C-c e" . yas-load-snippet-buffer)
   ("." . insert-period))
  :hook ((org-mode . yas-minor-mode)
         (text-mode . yas-minor-mode))
  :config
  ;; Load yasnippet directories
  (setq yas-snippet-dirs '("~/emacs/interesting-snippets" "~/emacs/snippets"))

  ;; Add hooks
  (add-hook 'yas-before-expand-snippet-hook (lambda () (key-minor-mode nil)))
  (add-hook 'yas-after-exit-snippet-hook (lambda () (key-minor-mode 1)))

  ;; Don't insert random spaces in my prose
  (setq yas-indent-line 'none)

  ;; Take input word including hyphen
  (setq yas/key-syntaxes '("w_" "w_." "^ ")) ; default is '("w" "w_" "w_." "^ ")

  ;; Suppress backquote warnings
  (defun suppress-backquote-warnings ()
    (interactive)
    (add-to-list 'warning-suppress-types '(yasnippet backquote-change))))

(add-to-list 'warning-suppress-types '(yasnippet backquote-change))

;; after installing yasnippet but before you open any files
(with-eval-after-load 'yasnippet
  (yas-global-mode 1))

(with-eval-after-load 'org
  (add-hook 'org-tab-first-hook #'yas-org-very-safe-expand))

#+END_SRC

** fix yasnippet org-mode conflict
#+BEGIN_SRC emacs-lisp
(defun yas-org-very-safe-expand ()
 "Expand the snippet at point and copy the expansion to the clipboard safely in org-mode."
 (let ((yas-fallback-behavior 'return-nil))
  (yas-expand)))

;; put this near the top of your yas config, outside any hook
(setq yas-trigger-key "<tab>")   ; string form is what yas expects

#+END_SRC

** create new yasnippet
#+begin_src emacs-lisp
(defun new-yasnippet ()
  "Create a new Org-mode snippet file."
  (interactive)
  (let ((snippet-dir "/Users/jay/emacs/interesting-snippets/org-mode/")
        (snippet-name (read-string "Snippet name: "))
        (snippet-key (read-string "Snippet key: "))
        full-path)

    ;; Construct the full file path
    (setq full-path (concat snippet-dir snippet-name ".yasnippet"))

    ;; Ensure the snippet directory exists
    (unless (file-exists-p snippet-dir)
      (make-directory snippet-dir t))

    ;; Check if the file already exists
    (if (file-exists-p full-path)
        (if (yes-or-no-p "Snippet file already exists. Overwrite? ")
            (create-and-insert-snippet full-path snippet-name snippet-key)
          (message "Snippet creation canceled."))
      (create-and-insert-snippet full-path snippet-name snippet-key))))

(defun create-and-insert-snippet (full-path snippet-name snippet-key)
  "Helper function to create and insert snippet content."
  ;; Create and open the new snippet file
  (find-file full-path)
  ;; Insert the snippet structure
  (insert "# -*- mode: snippet -*-\n")
  (insert "# name: " snippet-name "\n")
  (insert "# key: " snippet-key "\n")
  (insert "# --\n")
  (insert "$0\n"))

(define-key key-minor-mode-map (kbd "s-k y a") 'new-yasnippet)
#+end_src

* tiny-expand
#+BEGIN_SRC emacs-lisp
(use-package tiny
  :defer t
:config
(tiny-setup-default)
)
(defun new-week ()
  (interactive)
(tiny-expand "m0\n7|*** committed actions:  <%(date "mon" x)>\n**** TODO \n")
  )

#+END_SRC


* outline mode
#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-lisp-mode-hook
          (lambda ()
            (make-local-variable 'outline-regexp)
            (setq outline-regexp "^;;; ")
            (make-local-variable 'outline-heading-end-regexp)
            (setq outline-heading-end-regexp ":\n")
            (outline-minor-mode 1)
))
#+END_SRC

* poetry
(define-key key-minor-mode-map (kbd "s-}") 'poetry-rhyme-word)


* Treat all new files as modified
#+BEGIN_SRC emacs-lisp
(add-hook 'find-file-hooks 'assume-new-is-modified)
(defun assume-new-is-modified ()
  (when (not (file-exists-p (buffer-file-name)))
    (set-buffer-modified-p t)))
#+END_SRC



* olivetti
#+BEGIN_SRC emacs-lisp
;; --------------------------------------------------------------------
;; 2) Olivetti for a centered text area
;; --------------------------------------------------------------------
(use-package olivetti
  :ensure t
  :hook
  (org-mode        . olivetti-mode)
  (markdown-mode   . olivetti-mode)
  (text-mode       . olivetti-mode)
  (message-mode    . olivetti-mode)
  (emacs-lisp-mode . olivetti-mode)
  (css-mode        . olivetti-mode)
  (Custom-mode     . olivetti-mode)
    (sh-mode         . olivetti-mode)
  (web-mode        . olivetti-mode)
  (fundamental-mode . olivetti-mode)
  (help-mode       . olivetti-mode)
  (prog-mode       . olivetti-mode)
  (magit-status-mode . olivetti-mode)
  (dired-mode      . olivetti-mode)
  (Info-mode       . olivetti-mode)
  (eww-mode        . olivetti-mode)
  ;; Turn on visual-line-mode whenever we enter olivetti-mode:
  (olivetti-mode   . turn-on-visual-line-mode)
  :config
  ;; Set your desired body width here:
  (setq olivetti-body-width 80)

  ;; Unbind these if you like:
  (unbind-key (kbd "C-c [") olivetti-mode-map)
  (unbind-key (kbd "C-c ]") olivetti-mode-map)

  ;; Optional: keep org-tags aligned
  (setq org-tags-column 40))
#+END_SRC


* Functions to quickly access config files
#+BEGIN_SRC emacs-lisp
(defun load-shared-functions ()
  (interactive)
(find-file "/Users/jay/emacs/emacs-settings/shared-functions.org"))

(defun load-gnu-startup ()
  (interactive)
(find-file "/Users/jay/emacs/emacs-settings/gnu-emacs-startup.org"))

(defun load-spacecraft-mode ()
 (interactive)
(find-file "~/emacs/emacs-settings/spacecraft-mode.org"))


(defun load-spacemacs-config ()
 (interactive)
(find-file "/Users/jay/emacs/emacs-settings/spacemacs-new-config.el"))

(defun load-roam-config ()
 (interactive)
(find-file "/Users/jay/emacs/emacs-settings/org-roam-config.el"))

(defun load-search-config ()
 (interactive)
(find-file "/Users/jay/emacs/emacs-settings/search-commands.org"))


(defun open-abbrevs ()
  (interactive)
(find-file "/Users/jay/emacs/aquamacs-jay/.abbrev_defs")
;; (olivetti-mode 1)
)
#+END_SRC


M-p
C-x y
C-x x
C-x w
C-x t
C-x j
C-c z
C-c x
C-c q


* embolden-region-or-point
#+BEGIN_SRC emacs-lisp
(defun embolden-region-or-point ()
  (interactive)
  (if (region-active-p)
      (progn
        (goto-char (region-end))
        (insert "*")
        (goto-char (region-beginning))
        (insert "*"))
    (insert "**")
    (backward-char)))

(define-key key-minor-mode-map (kbd "M-s-b") 'embolden-region-or-point)
#+END_SRC


* italicize-region-or-point
#+BEGIN_SRC emacs-lisp
(defun italicize-region-or-point ()
  (interactive)
  (if (region-active-p)
      (progn
        (goto-char (region-end))
        (insert "/")
        (goto-char (region-beginning))
        (insert "/"))
(insert "//")
    (backward-char)))

(define-key key-minor-mode-map (kbd "<C-i>") 'italicize-region-or-point)
#+END_SRC


* org todo stuff
** move point to next TODO heading upon DONE state change
#+BEGIN_SRC emacs-lisp
(defun bb/next-heading (&rest args)
(when

(or
(org-entry-is-done-p)
(string= (org-get-todo-state) "MISSED")
)
(outline-next-visible-heading 1)))



(advice-add 'org-todo :after 'bb/next-heading)
#+END_SRC


** Check checkbox then automatically move to next item in list ([[http://superuser.com/questions/568482/org-mode-function-to-check-checkbox-and-move-to-next-in-list#][Source]]):
#+BEGIN_SRC emacs-lisp
(defmacro my/with-advice (adlist &rest body)
  "Execute BODY with temporary advice in ADLIST.
Each element of ADLIST should look like:
  (FUNCTION WHERE AD-FN)
which is suitable for passing to `advice-add'."
  (declare (debug ((&rest (&rest form)) body))
           (indent 1))
  `(progn
     ;; Generate the (advice-add ...) calls
     ,@(mapcar (lambda (adform)
                 (let ((fn    (car  adform))
                       (where (cadr adform))
                       (afn   (caddr adform)))
                   `(advice-add ',fn ,where ,afn)))
               adlist)
     ;; Wrap BODY in unwind-protect so advice is always removed
     (unwind-protect (progn ,@body)
       ;; Generate the (advice-remove ...) calls
       ,@(mapcar (lambda (adform)
                   (let ((fn  (car adform))
                         (afn (caddr adform)))
                     `(advice-remove ',fn ,afn)))
                 adlist))))

(defun my/org-checkbox-toggle-advice (orig-fn &rest args)
  "Advice to move to next list item on checkbox toggle."
  (my/with-advice
   ((org-update-checkbox-count-maybe
     :after (lambda () (ignore-errors (progn (org-next-item) (end-of-line))))))
   (apply orig-fn args)))

(advice-add #'org-ctrl-c-ctrl-c   :around #'my/org-checkbox-toggle-advice)
(advice-add #'org-toggle-checkbox :around #'my/org-checkbox-toggle-advice)

#+END_SRC

*** an alternative approach, probably not needed
#+BEGIN_EXAMPLE emacs-lisp
;; a temporary hack
(defun zin/org-checkbox-next ()
 (interactive)
 (when (org-at-item-checkbox-p)
 (org-toggle-checkbox))
 (org-next-item))
#+END_EXAMPLE

* wrap region
#+BEGIN_SRC emacs-lisp
;; wrap-region
(use-package wrap-region
  :defer
  :ensure t
  :config
  ;; Fix cl deprecation warning
  (require 'cl-lib)

  ;; Add your custom wrapper
  (wrap-region-add-wrapper "\n#+BEGIN_QUOTE\n" "\n#+END_QUOTE\n" ";")

  ;; Define your wrapper function
  (defun wrap-region-define-wrappers ()
    "Defines defaults wrappers."
    (mapc
     (lambda (pair)
       (apply 'wrap-region-add-wrapper pair))
     '(
       ;; ("\"" "\"")
       ;; ("'"  "'")
       ;; ("("  ")")
       ("{"  "}")
       ;; ("["  "]")
       ;; ("<"  ">")
       ;; ("<"  ">")
       )))

  ;; Add mode-specific wrappers
  (wrap-region-add-wrappers
   '(
     ;;     ("*" "*" nil org-mode)
     ;;     ("/" "/" nil org-mode)
     ;; ("\"" "\"" nil org-mode)
     ("~" "~" nil org-mode)
     ("_" "_" nil org-mode)
     ("*" "*" nil (org-mode message-mode))
     ("/" "/" nil (org-mode message-mode))
     ("$" "$" nil (org-mode latex-mode))
     )))


#+END_SRC
Source: [[http://pragmaticemacs.com/emacs/wrap-text-in-custom-characters/][Wrap text in custom characters | Pragmatic Emacs]]


* faces
** bold
#+BEGIN_SRC emacs-lisp
(custom-set-faces
 ;; custom-set-faces was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 '(bold ((t (:inherit font-lock-warning-face :weight bold))))
)
#+END_SRC

** C-c C-c to exit source code blocks
#+BEGIN_SRC emacs-lisp
(eval-after-load 'org-src
  '(define-key org-src-mode-map
     "\C-c\C-c" #'org-edit-src-exit))
#+END_SRC


** narrow or widen
#+BEGIN_SRC emacs-lisp
;; Smart DWIM narrowing/widening command for Org, LaTeX, and code buffers.
;; No package boilerplate — just the function and helpers.

;;; Code:

(defgroup narrow-or-widen-dwim nil
  "Smart narrowing/widening helper."
  :group 'editing)

(defcustom narrow-or-widen-dwim-single-window t
  "If non-nil, close other windows when entering `org-edit-src-code'."
  :type 'boolean
  :group 'narrow-or-widen-dwim)

(defun narrow-or-widen-dwim--maybe-widen (prefix)
  "If the buffer is narrowed and PREFIX is nil, widen it.
Return non-nil when widening happened."
  (when (and (buffer-narrowed-p) (not prefix))
    (widen)
    t))

(defun narrow-or-widen-dwim--in-subtree-p ()
  "Return non-nil when point is inside an Org subtree (heading or its body)."
  (save-excursion
    (condition-case nil
        (progn (org-back-to-heading t) t)
      (error nil))))

;;;###autoload
(defun narrow-or-widen-dwim (p)
  "Do‑what‑I‑mean narrowing or widening.

Without a prefix argument, widen if the buffer is already narrowed.
Otherwise narrow intelligently to:
  • the active region,
  • the current Org src block (opening an indirect edit buffer),
  • the current Org block (quote/example/etc.),
  • the current Org subtree,
  • the Org element at point (drawer, property drawer, table, footnote),
  • the current LaTeX environment, or
  • the current defun in programming modes.

With a prefix argument P (\[universal-argument]), *always* narrow even if the
buffer is already narrowed; never widen."
  (interactive "P")
  (declare (interactive-only))
  ;; First, widen if appropriate. If we did, we're done.
  (unless (narrow-or-widen-dwim--maybe-widen p)
    (cond
     ;; 1) Inside an *Org src editing* indirect buffer – exit it.
     ((bound-and-true-p org-src-mode)
      (org-edit-src-exit))

     ;; 2) In Org mode – choose the right narrowing target.
     ((derived-mode-p 'org-mode)
      (cond
       ;; Active region ⇒ narrow to that region.
       ((region-active-p)
        (narrow-to-region (region-beginning) (region-end)))

       ;; Inside a src block ⇒ open indirect edit buffer.
       ((org-in-src-block-p)
        (org-edit-src-code)
        (when narrow-or-widen-dwim-single-window
          (delete-other-windows)))

       ;; Inside any Org block (quote/example/etc.) ⇒ narrow to block.
       ((org-in-block-p nil)
        (org-narrow-to-block))

       ;; Within a subtree ⇒ narrow to subtree.
       ((narrow-or-widen-dwim--in-subtree-p)
        (save-excursion
          (org-back-to-heading t)
          (org-narrow-to-subtree)))

       ;; Other Org element at point (drawer, table, footnote) ⇒ element.
       ((let* ((elem (org-element-at-point)))
          (when (memq (org-element-type elem)
                      '(table footnote-definition property-drawer drawer))
            elem))
        (org-narrow-to-element))

       (t (user-error "Point is not in a narrowable Org context"))))

     ;; 3) LaTeX mode ⇒ narrow to current environment.
     ((derived-mode-p 'latex-mode)
      (LaTeX-narrow-to-environment))

     ;; 4) Fallback ⇒ defun.
     (t
      (narrow-to-defun)))))

;; Optional: bind globally
;; (global-set-key (kbd "C-c n") #'narrow-or-widen-dwim)

(provide 'narrow-or-widen-dwim)
;;; narrow-or-widen-dwim.el ends here
#+END_SRC


** org insert easy template source blocks
#+BEGIN_SRC emacs-lisp
;; ------------------------------------------------------------------
;; Org structure templates ­– <sr TAB> etc.
;; ------------------------------------------------------------------
(use-package org ; pulls in org-tempo automatically in modern Org
  :init
  ;; org-tempo must load *before* we touch the alist
  (require 'org-tempo)
  :config
  ;; Prepend our shortcuts once, not 5×
  (setq org-structure-template-alist
        (append
         '(("sr" . "src")                 ; generic <sr
           ("sh" . "src sh")              ; shell
           ("el" . "src emacs-lisp")      ; elisp
           ("le" . "example")             ; example block
           ("v"  . "verse"))              ; verse block
         org-structure-template-alist)))
#+END_SRC

Source: [[http://emacs.stackexchange.com/questions/12841/quickly-insert-source-blocks-in-org-mode][org babel - Quickly insert source blocks in org mode - Emacs Stack Exchange]]

#+begin_src emacs-lisp
(setq org-structure-template-alist
 '(("a" . "export ascii")
  ("c" . "center")
  ("C" . "comment")
  ("e" . "example")
  ("x" . "example")
  ("le" . "example")
  ("E" . "export")
  ("h" . "export html")
  ("l" . "src emacs-lisp")
  ("el" . "src emacs-lisp")
  ("la" . "export latex")
  ("q" . "quote")
  ("s" . "src")
  ("sh" . "src sh")
  ("f" . "example fountain")
  ("v" . "example verse")))
#+end_src




* if then else indentation
#+BEGIN_SRC emacs-lisp
(put 'if 'lisp-indent-function nil)
#+END_SRC


* Create org file and insert path of screen shot
#+BEGIN_SRC emacs-lisp
(defun insert-file-link-from-clipboard ()
  "Make sure the full path of file exist in clipboard. This command will convert
The full path into relative path and insert it as a local file link in org-mode"
  (interactive)
  (let (str)
    (with-temp-buffer
      (shell-command
       (cond
        ((eq system-type 'cygwin) "getclip")
        ((eq system-type 'darwin) "pbpaste")
        (t "xsel -ob"))
       1)
      (setq str (buffer-string)))

    ;; convert to relative path (relative to current buffer) if possible
    (let ((m (string-match (file-name-directory (buffer-file-name)) str) ))
      (when m
        (if (= 0 m )
            (setq str (substring str (length (file-name-directory (buffer-file-name)))))
          ))
        (insert (format "[[file:%s]]" str)))
    ))
#+END_SRC


* unbind meta-number
This unbinds M-1, M-2, ..., M-0, which I very rarely used (I use C-u for count arguments) and I suddenly found myself with 10 new shortcuts that are easy to type (especially M-1, M-2 and M-3). You can also use them as prefixes, so for example M-1 r could be ivy-recentf and M-1 s could be swiper.

I hope this is somewhat helpful to someone else, happy hacking! Source: [[https://www.reddit.com/r/emacs/comments/3ricev/tip_for_when_you_are_running_out_of_easytopress/][Tip for when you are running out of easy-to-press key shortcuts : emacs]]

#+BEGIN_SRC emacs-lisp
(dotimes (n 10)
  (global-unset-key (kbd (format "M-%d" n))))
#+END_SRC



* fontify list titles
#+BEGIN_SRC emacs-lisp

;; define list-title face
(defface list-title-face
  '((t (:foreground "red" :weight bold)))
  "fontify list titles")

;; define heading-title face
(defface heading-title-face
  '((t (:foreground "red" :weight bold)))
  "fontify heading titles")


;; define anki-clozure face
(defface anki-clozure-face
  '((t (:foreground "red" :weight bold)))
  "fontify anki clozures")


(font-lock-add-keywords 'org-mode
                        '(
			  ;; ("^.*:[ ]*$" . 'list-title-face) ; fontify any line that ends with a colon
                          ("^Q\\(UESTION\\|uestion\\):" . 'list-title-face) ; fontify "Question:" and "QUESTION:"

			  ("^[A-Za-z]+:" . 'list-title-face); fontify any word followed by a colon if it begins the line

			  ;; ("^\\*+[ ]*[a-Za-z]+:" . 'heading-title-face); fontify any heading that starts with a word followed by a colon. But how to make this face supersede the other one?
                          )
                        )



#+END_SRC

** and on export
#+BEGIN_SRC emacs-lisp

;; old code (works for HTML export, breaks http links)
;; (add-hook 'org-export-before-parsing-hook (lambda (backend) (replace-regexp "^[A-Za-z]+:" "*\\&*")))

(add-hook 'org-export-before-parsing-hook (lambda (backend) (replace-regexp "^\\([A-Za-z]+:\\)\\([^/]\\|/[^/]\\|$\\)" "*\\1*\\2")))

;; (add-hook 'org-export-before-parsing-hook (lambda (backend) (replace-regexp "^\\(.*:\\)[ ]*$" "*\\1*")))
 ;; any line that ends with a colon


#+END_SRC


* sort lines case insensitive
#+BEGIN_SRC emacs-lisp
(defun sort-lines-case-insensitive ()
  (interactive)
  (let ((sort-fold-case t))
    (call-interactively 'sort-lines)))
#+END_SRC

* typewriter mode
#+BEGIN_SRC emacs-lisp
(defun typewriter-mode ()
  (interactive)
  (setq centered-cursor-mode t)
  (setq global-centered-cursor-mode t)
  )
#+END_SRC

* Save file as new
#+BEGIN_SRC emacs-lisp
(defun save-file-as-new ()
  "Force modification of current file, unless already modified."
  (interactive)
  (if (and (verify-visited-file-modtime (current-buffer))
           (not (buffer-modified-p)))
      (progn
        (set-buffer-modified-p t)
        (save-buffer 0))))
#+END_SRC

* touch-file
#+BEGIN_SRC emacs-lisp

    (defun touch-file (file)
    "Create a file called FILE.
  If FILE already exists, signal an error."
    (interactive
    (list (read-file-name "Create file: " (dired-current-directory))))
    (let* ((expanded (expand-file-name file))
      (try expanded)
      (dir (directory-file-name (file-name-directory expanded)))
      new)
     (if (file-exists-p expanded)
      (error "Cannot create file %s: file exists" expanded))
     ;; Find the topmost nonexistent parent dir (variable `new')
     (while (and try (not (file-exists-p try)) (not (equal new try)))
     (setq new try
       try (directory-file-name (file-name-directory try))))
     (when (not (file-exists-p dir))
     (make-directory dir t))
     (write-region "" nil expanded t)
     (when new
     (dired-add-file new)
     (dired-move-to-filename))))
#+END_SRC

* exporting
** org-twbs
#+BEGIN_SRC emacs-lisp
(use-package ox-twbs)
; '(org-twbs-head-include-default-style nil)
;; '(org-twbs-htmlize-output-type (quote inline-css))
; '(org-twbs-indent t)

#+END_SRC


** LaTeX
*** Find LaTeX on my system
#+BEGIN_SRC emacs-lisp
(if (eq window-system 'mac)
    (add-to-list 'exec-path "/usr/local/texlive/2025/bin/universal-darwin")
  )
#+END_SRC

*** XeLaTeX customisations
 ~org~ to LaTeX customisations, ~-shell-escape~ needed for ~minted~:
#+BEGIN_SRC emacs-lisp
(setq  ; org-export-dispatch-use-expert-ui t non-intrusive export dispatch
 org-latex-pdf-process               ; for regular export

 '("xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"))

;; don't add extra lines to numbered lists and bulleted lists (set to nil)

;; add padding to numbered lists and bulleted lists (set to t)
#+END_SRC

*** load my custom latex templates
#+BEGIN_SRC emacs-lisp

(defun jay-load-latex ()
  (interactive)
  (let ((base "/Users/jay/emacs/emacs-settings/latex-templates/")
        (files '("elegant.el"
                 "beautiful-racket.el"
                 "elegant-garamond.el"
                 "blue-invoice.el"
                 "blue-invoice-with-letterhead.el"
                 "jay-latex-yosemite-setup.el")))
    (dolist (file files)
      (let ((full-path (expand-file-name file base)))
        (when (file-exists-p full-path)
          (load full-path))))))

;; (load "/Users/jay/emacs/emacs-settings/latex-templates/blue-ruin.el")
;; (load "/Users/jay/emacs/emacs-settings/latex-templates/modest-ruin.el")

;; (load "/Users/jay/emacs/emacs-settings/latex-templates/inelegant.el")
;; (load "/Users/jay/emacs/emacs-settings/latex-templates/elegant-wider.el")

;; (load "/Users/jay/emacs/emacs-settings/latex-templates/resonate.el")

;; (load "/Users/jay/emacs/emacs-settings/latex-templates/blue-ruin_no_cover.el")

;; (use-package blue-ruin)
;; (use-package blue-invoice)
;; (use-package blue-ruin-no-cover)

#+END_SRC

*** fix latex verbatim
  You can use a filter function that will replace default "verbatim" with
  whatever you want.

  Here's my fancyvrb filter for when such a place is created.

  Source: [[https://lists.gnu.org/archive/html/emacs-orgmode/2013-04/msg01035.html][Re: {O} {patch} ox-latex.el to allow customization of verbatim environment]]
#+BEGIN_SRC emacs-lisp

 (defun org-latex-filter-fancyvrb (text backend info)
  "Convert begin/end{verbatim} to begin/end{Verbatim}.
 Allows use of the fancyvrb latex package."
  (when
    (org-export-derived-backend-p backend 'latex)
  (replace-regexp-in-string
   "\\\\\\(begin\\|end\\){verbatim}"
   "\\\\\\1{quote}"
   text)))

 (add-to-list 'org-export-filter-final-output-functions
     'org-latex-filter-fancyvrb)
#+END_SRC

* no inline images
#+BEGIN_SRC emacs-lisp
(setq org-startup-with-inline-images nil)
#+END_SRC


* query-replace-duplicate-lines-keep-blanks
Source: [[http://emacs.stackexchange.com/questions/20344/how-to-query-delete-duplicate-lines/20384?noredirect=1#comment31370_20384][replace - how to query-delete-duplicate-lines? - Emacs Stack Exchange]]

#+BEGIN_SRC emacs-lisp
(defun delete-duplicate-lines-keep-blanks ()
 (interactive)
 (delete-duplicate-lines (region-beginning) (region-end) nil nil t))
#+END_SRC

* display
** recenter top bottom
#+BEGIN_SRC emacs-lisp
(setq scroll-margin 25)
;; (setq recenter-positions (quote (top middle bottom)))
#+END_SRC



* org-clock
#+BEGIN_SRC emacs-lisp
(setq org-clock-auto-clock-resolution t)
 (setq org-clock-idle-time 30)
 (setq org-clock-in-resume t)
 (setq org-clock-persist-query-resume nil)
 (setq org-clock-report-include-clocking-task t)
(setq org-clock-persist 'history)
(org-clock-persistence-insinuate)
(setq org-clock-persist t)
(setq org-clock-into-drawer nil)
(setq org-clocktable-defaults
 (quote
 (:maxlevel 3 :lang "en" :scope file :block nil :wstart 1 :mstart 1 :tstart nil :tend nil :step nil :stepskip0 nil :fileskip0 nil :tags nil :emphasize nil :link nil :narrow 40! :indent t :formula nil :timestamp nil :level nil :tcolumns nil :formatter nil)))

(setq org-time-clocksum-format
 (quote
 (:hours "%d" :require-hours t :minutes ":%02d" :require-minutes t)))
#+END_SRC



* sensible defaults
Source: [[https://github.com/hrs/sensible-defaults.el/blob/master/sensible-defaults.el][sensible-defaults.el/sensible-defaults.el at master · hrs/sensible-defaults.el 🔊]]

#+BEGIN_SRC emacs-lisp

;; Utility functions:

(defun sensible-defaults/comment-or-uncomment-region-or-line ()
 "Comments or uncomments the region or the current line if there's no active region."
 (interactive)
 (let (beg end)
  (if (region-active-p)
    (setq beg (region-beginning) end (region-end))
   (setq beg (line-beginning-position) end (line-end-position)))
  (comment-or-uncomment-region beg end)))

(global-set-key (kbd "M-;")
         'sensible-defaults/comment-or-uncomment-region-or-line)



(setq vc-follow-symlinks t)

"When saving a file that starts with `#!', make it executable."
 (add-hook 'after-save-hook
      'executable-make-buffer-file-executable-if-script-p)
#+END_SRC


* repeat-last-command
#+BEGIN_SRC emacs-lisp
(defun repeat-last-command ()
"repeats the last command called via M-x"
(interactive)
(let ((history extended-command-history)
cmd)
;; remove any occurence of this-command at the head of `history'.
(while (string= this-command (setq cmd (pop history))))
(message "Running cmd: %s" cmd)
(call-interactively (intern cmd))))
#+END_SRC

* org
** editing
*** lines
**** org-copy-line
#+BEGIN_SRC emacs-lisp
(defun org-select-line ()
 "Select the current line"
 (interactive)
 (org-beginning-of-line) ; move to end of line
 (set-mark (line-end-position)))

(defun org-copy-line ()
 (interactive)
(org-select-line)
(pasteboard-copy)
(set-mark nil))
#+END_SRC


*** paragraphs
**** kill whole paragraph
     :PROPERTIES:
     :ID:       4DCE53D0-0D37-464B-B398-BD5B4BE18492
     :END:
#+BEGIN_SRC emacs-lisp
(defun kill-paragraph-from-beginning (b e)
  (interactive)
  (mark-paragraph)
  (kill-region)
  )
#+END_SRC


*** subtrees
**** eval-subtree
     :PROPERTIES:
     :ID:       A97FDEB2-CB0D-4B17-9A73-FB737A5F030F
     :END:
#+BEGIN_SRC emacs-lisp
(defun eval-subtree ()
 (interactive)
 (org-edit-src-code)
 (eval-buffer)
 (org-edit-src-exit)
 )

(defun eval-adaptive ()
  "Smart eval:
- If region is active, eval the region.
- If in an Org-mode Emacs Lisp source block, eval the block.
- If in a Yasnippet buffer, load the snippet buffer as an org-mode snippet.
- If in an Emacs Lisp buffer, eval the buffer.
- Otherwise, notify the user."
  (interactive)
  (cond
   ;; If region is active, eval the region
   ((use-region-p)
    (eval-region (region-beginning) (region-end))
    (message "✅ Evaluated region"))

   ;; If in an Org-mode Emacs Lisp src block, eval that block
   ((and (derived-mode-p 'org-mode)
         (org-in-src-block-p))
    (let* ((context (org-element-context))
           (lang (org-element-property :language context))
           (body (org-element-property :value context)))
      (if (string= lang "emacs-lisp")
          (progn
            (eval (read (concat "(progn\n" body "\n)")))
            (message "✅ Evaluated Emacs Lisp src block"))
        (message "⚠️ Not an Emacs Lisp src block"))))

   ;; If in a Yasnippet buffer, load the snippet buffer as org-mode
   ((derived-mode-p 'snippet-mode)
    (yas-load-snippet-buffer 'org-mode)
    (message "✅ Loaded Yasnippet buffer for org-mode"))

   ;; If in an Emacs Lisp buffer, eval the whole buffer
   ((derived-mode-p 'emacs-lisp-mode)
    (eval-buffer)
    (message "✅ Evaluated buffer"))

   ;; Otherwise, do nothing
   (t
    (message "⚠️ No matching eval context"))))


(global-set-key (kbd "C-c e") #'eval-adaptive)




#+END_SRC

*** document
**** kill to buffer end
     :PROPERTIES:
     :ID:       49820CA2-490C-4DA0-9036-F16B262F712E
     :END:

#+BEGIN_SRC emacs-lisp
(defun kill-to-buffer-end-or-beginning (arg)
  (interactive "p")
  (if (and arg (= 0 (mod arg 4)))
      (beginning-of-buffer)
    (end-of-buffer))
  (kill-region (mark) (point))
  (recenter-top-bottom))

(define-key key-minor-mode-map (kbd "M-w") 'kill-to-buffer-end-or-beginning)
#+END_SRC


** navigation
*** up by degrees
#+BEGIN_SRC emacs-lisp
(defun up-by-degrees ()
 (interactive)
       (previous-line 6)
 )


(defun down-by-degrees ()
 (interactive)
       (next-line 6)
 )


#+END_SRC


*** next-subtree-same-level-and-narrow
#+BEGIN_SRC emacs-lisp
(defun org-next-subtree-same-level-and-narrow ()
 (interactive)
 (widen)
 (org-forward-heading-same-level 1)
 (org-narrow-to-subtree)
 )

(defun org-previous-subtree-same-level-and-narrow ()
 (interactive)
(org-previous-visible-heading 1)
 (widen)
(org-backward-heading-same-level 1)
 (org-narrow-to-subtree)
 )
#+END_SRC

*** next-subtree-and-narrow - original
#+BEGIN_SRC emacs-lisp
(defun org-next-subtree-and-narrow ()
 (interactive)
 (widen)
 (org-next-visible-heading 1)
 (org-narrow-to-subtree)
 )

(defun org-previous-subtree-and-narrow ()
 (interactive)
(org-previous-visible-heading 1)
 (widen)
 (org-previous-visible-heading 1)
 (org-narrow-to-subtree)
 )
#+END_SRC

*** filing

**** refile active region or subtree
#+BEGIN_SRC emacs-lisp
(defun refile-region-or-subtree ()
  (interactive)
  (if (region-active-p)
      (call-interactively 'jay-refile-region)
    (org-refile)))
#+END_SRC


* org-config-files-mode
#+BEGIN_SRC emacs-lisp
(define-minor-mode org-config-files-local-mode
  "Minor mode for editing configuration files in org-mode."
  :init-value nil
  :lighter " OrgCfg"
  :keymap (let ((map (make-sparse-keymap)))
            (define-key map (kbd "<SPC>") 'insert-space)
            map)
  (message "org-config-files-local-mode is now %s" org-config-files-local-mode)
  (if org-config-files-local-mode
      (progn
        ;; When enabling, set any additional buffer-local variables
        (setq-local abbrev-mode nil))
    (kill-local-variable 'abbrev-mode)))
#+END_SRC

* yasnippet fixes
#+BEGIN_SRC emacs-lisp
(defun yas/pasteboard-raw ()
 "Return content of OS X system pasteboard via `pbpaste'."
 (shell-command-to-string "pbpaste | perl -p -e 's/\r$//' | tr '\r' '\n'"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun yas/org-get-time-stamp (&rest args)
 "Return the string that `org-insert-time-stamp' would insert."
 (with-temp-buffer
  (apply #'org-insert-time-stamp args)
  (buffer-string)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun yas/tiny-expand (str)
  (with-temp-buffer
    (insert str)
    (goto-char (point-max)) ; tiny-expand works on text preceding point
    (tiny-expand)
    (buffer-string)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun yas/suppress-errors ()
(interactive)
  (ignore-errors (add-to-list 'warning-suppress-types '(yasnippet backquote-change)))
)
#+END_SRC

* optimize emacs load time
#+BEGIN_SRC emacs-lisp
(defun loadup-gen ()
 "Generate the lines to include in the lisp/loadup.el file
to place all of the libraries that are loaded by your InitFile
into the main dumped emacs"
 (interactive)
 (defun get-loads-from-*Messages* ()
  (save-excursion
   (let ((retval ()))
	(set-buffer "*Messages*")
	(beginning-of-buffer)
	(while (search-forward-regexp "^Loading " nil t)
	 (let ((start (point)))
	  (search-forward "...")
	  (backward-char 3)
	  (setq retval (cons (buffer-substring-no-properties start (point)) retval))))
	retval)))
 (map 'list
    (lambda (file) (princ (format "(load \"%s\")\n" file)))
    (get-loads-from-*Messages*)))
#+END_SRC

* crux
#+BEGIN_SRC emacs-lisp

(use-package crux
:defer t
:bind
( "M-`" . crux-swap-windows)
( "s-k rf" .  crux-rename-file-and-buffer)
( "s-k df" . crux-delete-file-and-buffer)
( "C-c d" . crux-duplicate-current-line-or-region)
( "C-c i" . crux-find-user-init-file)
)
#+END_SRC

* typography custom functions
** em dash
#+BEGIN_SRC emacs-lisp
(defun em-dash ()
(interactive)
(cond (mark-active
   (progn (delete-region (mark) (point)))))
(expand-abbrev)
(insert "---")
  )
#+END_SRC

** true em dash
#+BEGIN_SRC emacs-lisp
(defun true-em-dash ()
(interactive)
(cond (mark-active
   (progn (delete-region (mark) (point)))))
(expand-abbrev)
(insert "—")
  )
#+END_SRC

** double quote
   #+BEGIN_SRC emacs-lisp
(defun insert-one-double-quote ()
(interactive)
(cond (mark-active
   (progn (delete-region (mark) (point)))))
(insert "\""))
#+END_SRC


** insert right-bracket
   :PROPERTIES:
   :ID:       C6D2D34A-628B-4DB2-9082-DECEBB5D8F9F
   :END:
#+BEGIN_SRC emacs-lisp
(defun insert-right-bracket ()
  (interactive)
(cond (mark-active
   (progn (delete-region (mark) (point)))))
  (insert "\]")
  )
#+END_SRC

** insert equals sign
#+BEGIN_SRC emacs-lisp
(defun insert-equals-sign ()
  (interactive)
(cond (mark-active
   (progn (delete-region (mark) (point)))))
  (insert "=")
  )
#+END_SRC

** insert slash no abbrev
#+BEGIN_EXAMPLE emacs-lisp
(defun jay/insert-slash ()
  (interactive)
  (insert "/")
  )
#+END_EXAMPLE


* undo-tree-mode
#+BEGIN_SRC emacs-lisp
(use-package undo-fu-session
  :init
  (setq undo-fu-session-compression nil)   ;; nil = never compress
  (undo-fu-session-global-mode))

(defun undo-fu-only-redo-fail-silently ()
 "Redo the last undone change if possible, silently fail if no more redo steps."
 (interactive)
 (ignore-errors
  (undo-fu-only-redo)))

(defun undo-fu-only-redo-fail-with-heart ()
 "Redo the last undone change if possible."
 (interactive)
 (condition-case nil
   (undo-fu-only-redo)
  (user-error (message "❤️"))))

(setq undo-tree-auto-save-history nil)

(setq undo-limit 67108864) ; 64mb.
(setq undo-strong-limit 100663296) ; 96mb.
(setq undo-outer-limit 1006632960) ; 960mb.
#+END_SRC

* Emacs 25
** don't create new frames
#+BEGIN_SRC emacs-lisp
(setq display-buffer-alist (quote (("" ignore (nil . reusable-frames)))))
#+END_SRC

* from Harry Schwartz
** find file as sudo
#+BEGIN_SRC emacs-lisp
(defun edit-this-file-as-sudo ()
  (interactive)
  (let ((file-name (buffer-file-name)))
   (when file-name
    (find-alternate-file (concat "/sudo::" file-name)))))

(defun sudo-find-file ()
 (interactive)
 (let ((file-name (buffer-file-name)))
  (when file-name
  (find-file (concat "/sudo::" file-name)))))

(defun sudo-edit-paths ()
 (interactive)
(find-file "/etc/paths")
(sudo-edit)
)

(defun sudo-edit-hosts ()
 (interactive)
(find-file "/private/etc/hosts")
(sudo-edit)
)


#+END_SRC


** Use fancy lambdas
Why not?

#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook #'prettify-symbols-mode)
#+END_SRC



** Projectile
Projectile's default binding of =projectile-ag= to =C-c p s s= is clunky enough
that I rarely use it (and forget it when I need it). This binds the
easier-to-type =C-c C-v= and =C-c v= to useful searches.

#+BEGIN_SRC emacs-lisp
 (defun hrs/search-project-for-symbol-at-point ()
  "Use `projectile-ag' to search the current project for `symbol-at-point'."
  (interactive)
  (projectile-ag (projectile-symbol-at-point)))

 (global-set-key (kbd "C-c v") 'projectile-ag)
 (global-set-key (kbd "C-c C-v") 'hrs/search-project-for-symbol-at-point)
;; (setq projectile-indexing-method 'native)
#+END_SRC

*** Ignore files specified in .projectile (doesn't work)
The function counsel-projectile-grep is failing to ignore the files I
specified to ignore in my .projectile file. How can I direct
counsel-projectile-grep to ignore these files?

By default, =counsel-projectile-grep= doesn't use the settings from your
=.projectile= file. To configure =counsel-projectile-grep= to respect
the ignore patterns specified in your =.projectile= file, you can modify
the =counsel-projectile-grep= function by using the =advice-add= feature
in Emacs Lisp.

Here's an example of how to create an advice function that passes the
ignore patterns to =counsel-projectile-grep=:

#+begin_EXAMPLE emacs-lisp
(defun my-projectile-ignore-list ()
 (let ((project-root (projectile-project-root))
    (projectile-file (concat (projectile-project-root) ".projectile")))
  (when (file-exists-p projectile-file)
   (with-temp-buffer
    (insert-file-contents projectile-file)
    (split-string (buffer-string) "\n" t)))))

(defun my-ignore-list-to-grep-options (ignore-list)
 (when ignore-list
  (mapconcat (lambda (pattern)
         (concat "--exclude=" (shell-quote-argument pattern)))
        ignore-list " ")))

(defun my-counsel-projectile-grep-ignore-config (orig-fun &rest args)
 (let ((counsel-projectile-grep-base-command
     (concat counsel-projectile-grep-base-command " "
         (my-ignore-list-to-grep-options


#+end_EXAMPLE

* web-mode
If I'm in =web-mode=, I'd like to:

- Color color-related words with =rainbow-mode=.
- Still be able to run RSpec tests from =web-mode= buffers.
- Indent everything with 2 spaces.

Use =web-mode= with embedded Ruby files, regular HTML, and PHP.

#+BEGIN_EXAMPLE emacs-lisp
(defun hrs/add-auto-mode (mode &rest patterns)
  "Add entries to `auto-mode-alist' to use `MODE' for all given file `PATTERNS'."
  (dolist (pattern patterns)
   (add-to-list 'auto-mode-alist (cons pattern mode))))


 (hrs/add-auto-mode
  'web-mode
  "\\.erb$"
  "\\.html$"
  "\\.php$"
  "\\.rhtml$")
#+END_EXAMPLE


When editing a code snippet, use the current window rather than popping open a
new one (which shows the same information).

#+BEGIN_SRC emacs-lisp
 (setq org-src-window-setup 'current-window)
#+END_SRC


* how to do an argument
Insert today's date
Ben Maughan

Here's a simple bit of code from the Emacs wiki to insert the current date. I've set the default to be in the format YYYY-MM-DD, but if you use a prefix C-u then you get DD-MM-YYYY.

;; from http://bit.ly/2aBY92J

#+BEGIN_SRC emacs-lisp
(defun insert-todays-date (arg)
 (interactive "P")
 (insert (if arg
    (format-time-string "%d-%m-%Y")
   (format-time-string "%Y-%m-%d"))))
#+END_SRC


* toggle-between-src-and-example-block
#+BEGIN_SRC emacs-lisp
(defun toggle-between-src-and-example-block ()
  (interactive)
  (save-excursion
    (let* ((elt (org-element-at-point))
           (elt-type (org-element-type elt))
           (bgn (org-element-property :begin elt)))
      (cond
       ((eq elt-type 'src-block)
        (goto-char bgn)
        (re-search-forward "#\\+BEGIN_SRC\\s-*\\(\\S-+\\)?")
        (replace-match "#+BEGIN_EXAMPLE \\1")
        (re-search-forward "#\\+END_SRC" nil t)
        (replace-match "#+END_EXAMPLE"))
       ((eq elt-type 'example-block)
        (goto-char bgn)
        (re-search-forward "#\\+BEGIN_EXAMPLE\\s-*\\(\\S-+\\)?")
        (replace-match "#+BEGIN_SRC \\1")
        (re-search-forward "#\\+END_EXAMPLE" nil t)
        (replace-match "#+END_SRC"))
       (t (message "Not in a src or example block goddammit!"))))))
#+END_SRC



* ediff
#+BEGIN_SRC emacs-lisp
(setq ediff-diff-options "-w")
#+END_SRC

* mouse scrolling
#+BEGIN_SRC emacs-lisp
(setq mac-wheel-button-is-mouse-2 nil)
;; so that the middle button works

(setq scroll-conservatively 1000) ; seems nice

#+END_SRC

* fix image links
#+BEGIN_SRC emacs-lisp
(defun fix-image-links ()
(interactive)
)
#+END_SRC

* ox-clip
#+BEGIN_SRC emacs-lisp
(use-package ox-clip
  :defer t)
#+END_SRC

* org-def
#+BEGIN_SRC emacs-lisp
(defun org-def ()
(interactive)
(save-excursion
(beginning-of-line)
 (insert "- "))
(insert " :: ")
)
#+END_SRC


* delete html blocks
#+BEGIN_SRC emacs-lisp
(defun delete-html-blocks ()
(interactive)
(replace-regexp "#\\+BEGIN_HTML\\(?:.*\\|\n\\)*#\\+END_HTML" "")
)
#+END_SRC

* beacon
#+BEGIN_EXAMPLE emacs-lisp
(use-package beacon
:defer t
 :init

 (beacon-mode 1)
(setq beacon-push-mark 35)
(setq beacon-color "#FFF876")
 )
#+END_EXAMPLE

* Tufte
** tufte export to HTML
#+BEGIN_SRC emacs-lisp
(use-package ox-tufte
  :defer t)
#+END_SRC

** tufte export to LaTeX
#+begin_src emacs-lisp
(use-package ox-tufte-LaTeX
:defer t
  :ensure nil
  :init (load "/Users/jay/emacs/emacs-settings/tufte-org-mode-master/ox-tufte-latex.el")
  )
#+end_SRC

* add YouTube link type yt:
#+BEGIN_SRC emacs-lisp
(defvar yt-iframe-format
 ;; You may want to change your width and height.
 (concat "<iframe width=\"440\""
     " height=\"335\""
     " src=\"https://www.youtube.com/embed/%s\""
     " frameborder=\"0\""
     " allowfullscreen>%s</iframe>"))

(org-add-link-type
 "yt"
 (lambda (handle)
  (browse-url
  (concat "https://www.youtube.com/embed/"
      handle)))
 (lambda (path desc backend)
  (cl-case backend
   (html (format yt-iframe-format
          path (or desc "")))
   (latex (format "\href{%s}{%s}"
          path (or desc "video"))))))
#+END_SRC


[[http://endlessparentheses.com/embedding-youtube-videos-with-org-mode-links.html][Embedding Youtube videos with org-mode links · Endless Parentheses]]

To use this, just write your org links in the following way (optionally adding a description).

[[yt:A3JAlWM8qRM]]

* display and copy spacemacs version info
#+BEGIN_SRC emacs-lisp
(defun spacemacs-version-display-and-copy ()
 "Echo the current version of Spacemacs, Emacs, and org-mode, and copy it."
 (interactive)
(setq system-version
 (substring
 (shell-command-to-string "defaults read loginwindow SystemVersionStampAsString")
 0 -1))
 (kill-new
   (message "Mac OSX Sierra version %s, Spacemacs version %s, Emacs version %s, org-mode version %s"
       system-version spacemacs-version emacs-version org-version))
 (push-kill-ring-pasteboard-to-MacOS-clipboard)
)
#+END_SRC

See also spacemacs/describe-system-info

* display and copy emacs version info
#+BEGIN_SRC emacs-lisp
(defun emacs-version-display-and-copy ()
 "Echo the current version of Spacemacs, Emacs, and org-mode, and copy it."
 (interactive)
(setq system-version
 (substring
 (shell-command-to-string "defaults read loginwindow SystemVersionStampAsString")
 0 -1))
 (kill-new
   (message "Mac OSX Sierra version %s, Emacs version %s, org-mode version %s"
       system-version emacs-version org-version))
 (push-kill-ring-pasteboard-to-MacOS-clipboard)
)
#+END_SRC

See also spacemacs/describe-system-info

* shell command on region
#+BEGIN_SRC emacs-lisp
(defun tidy-html ()
 "Tidies the HTML content in the buffer using `tidy'"
 (interactive)
 (shell-command-on-region
  ;; beginning and end of buffer
  (point-min)
  (point-max)
  ;; command and parameters
  "tidy -i -w 120 -q"
  ;; output buffer
  (current-buffer)
  ;; replace?
  t
  ;; name of the error buffer
  "*Tidy Error Buffer*"
  ;; show error buffer?
  t))
#+END_SRC
[[https://www.masteringemacs.org/article/executing-shell-commands-emacs][Executing Shell Commands in Emacs - Mastering Emacs]]


* smart question mark
#+BEGIN_SRC emacs-lisp
(defun qm-maybe ()
(interactive)
(when
(not
(looking-back "$")
)
(smart-question-mark)
)
)

;; (define-key key-minor-mode-map (kbd "?") 'qm-maybe)
#+END_SRC



* convert to chat format
#+BEGIN_EXAMPLE emacs-lisp
(defun intern-convert-to-chat-format (begin end)
 (interactive "r")
 (xah-replace-pairs-region begin end
 '(
 ["Mary Dean: " "** Mary Dean\n"]
 ["Ricky DeSantis: " "** Ricky DeSantis\n"]
 ["Jay Dixit: " "** Jay Dixit\n"]
 ["me: " "** Jay Dixit\n"]
 ["Benjamin: " "** Benjamin Carp\n"]
 ["Camille Inge: " "** Camille Inge\n"]
 ["Benjamin: " "** Ben Bechar\n"]
 )))

#+END_EXAMPLE


* shell-pop
#+BEGIN_SRC emacs-lisp
(use-package shell-pop
:defer t
 :bind (("C-t" . shell-pop))
 :config
 (setq shell-pop-shell-type (quote ("ansi-term" "*ansi-term*" (lambda nil (ansi-term shell-pop-term-shell)))))
 (setq shell-pop-term-shell "/bin/zsh")
 ;; need to do this manually or not picked up by `shell-pop'
 (shell-pop--set-shell-type 'shell-pop-shell-type shell-pop-shell-type))
#+END_SRC



* fix case

* ignore case in searches
#+BEGIN_SRC emacs-lisp
(defun ignore-case-in-searches ()
 (interactive)
 (setq case-fold-search t)
 )
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun isearch-forward-ignore-case ()
(interactive)
(ignore-case-in-searches)
(isearch-forward)
)
#+END_SRC


* org count words
Source: [[https://www.reddit.com/r/emacs/comments/8qm1lb/new_orgcountwords_command/][New org-count-words command : emacs]]


Note that it does not count words in heading lines, planning lines, and drawers, so it gives a more useful count for the "prose" in the subtree.

ounts lines, words, and characters in the region or the subtree at point. It prints a message like count-words does, like:

: Subtree "Heading" has 7 line, 5 words, and 28 characters.


#+BEGIN_SRC emacs-lisp

(defun ap/org-count-words ()
  "If region is active, count words in it; otherwise count words in current subtree."
  (interactive)
  (if (use-region-p)
    (funcall-interactively #'count-words-region (region-beginning) (region-end))
   (org-with-wide-buffer
    (cl-loop for (lines words characters)
        in (org-map-entries
          (lambda ()
           (ap/org-forward-to-entry-content 'unsafe)
           (let ((end (org-entry-end-position)))
            (list (count-lines (point) end)
               (count-words (point) end)
               (- end (point)))))
          nil 'tree)
        sum lines into total-lines
        sum words into total-words
        sum characters into total-characters
        finally do (message "Subtree \"%s\" has %s lines, %s words, and %s characters."
                  (org-get-heading t t) total-lines total-words total-characters)))))

(defun ap/org-forward-to-entry-content (&optional unsafe)
  "Skip headline, planning line, and all drawers in current entry.
If UNSAFE is non-nil, assume point is on headline."
  (unless unsafe
   ;; To improve performance in loops (e.g. with `org-map-entries')
   (org-back-to-heading))
  (cl-loop for element = (org-element-at-point)
       for pos = (pcase element
             (`(headline . ,_) (org-element-property :contents-begin element))
             (`(,(or 'planning 'property-drawer 'drawer) . ,_) (org-element-property :end element)))
       while pos
       do (goto-char pos)))
#+END_SRC


* time stamps
[[http://emacs-fu.blogspot.com/2008/12/automatic-timestamps.html][emacs-fu: automatic timestamps]]


#+BEGIN_SRC emacs-lisp
(setq
 time-stamp-active t     ; do enable time-stamps
time-stamp-line-limit 50; check first 50 lines
time-stamp-format "%04y-%02m-%02d"; date format
time-stamp-pattern "50//*Invoice date:\\*+\s%:y-%02m-%02d\\\\?$"
)

;; (add-hook 'write-file-hooks 'time-stamp) ; update when saving

(add-hook 'before-save-hook 'time-stamp)
#+END_SRC


* poet-mode
#+BEGIN_SRC emacs-lisp
;; (add-hook 'org-mode-hook
;;         (lambda ()
;;         (variable-pitch-mode 1)))

;; (set-face-attribute 'variable-pitch nil :family "Baskerville")
(set-face-attribute 'variable-pitch nil :family "Triplicate T3")

(add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
  (add-to-list 'default-frame-alist '(ns-appearance . light))


;;  (typo-mode 1)      ;; Good for symbols like em-dash
(add-hook 'poetry-mode-hook 'olivetti-mode 1)
;; (add-hook 'poetry-mode-hook 'olivetti-mode 1)

(defun poet-mode ()
(interactive)
(set-face-attribute 'default nil :family "Iosevka" :height 130)
(set-face-attribute 'fixed-pitch nil :family "Iosevka")
        (variable-pitch-mode 1)
(poetry-mode)
(olivetti-mode 1)
;; (turn-off-auto-capitalize-mode)

)
#+END_SRC


* default org-css
#+begin_SRC emacs-lisp
(defvar my-org-selected-css "/Users/jaydixit/Dropbox/web-design/custom-css/sans-serif.css"
  "Path of the selected CSS file or 'none' for no stylesheet. Defaults to sans-serif.css if not manually selected.")

(defvar my-org-css-options
  '("/Users/jay/Dropbox/web-design/custom-css/email.css"
    "/Users/jay/Dropbox/web-design/custom-css/gmail.css"
    "/Users/jay/Dropbox/github/incandescentman.github.io/css/neocortex.css"
"/Users/jay/Library/CloudStorage/Dropbox/github/incandescentman.github.io/css/bold.css"
"/Users/jay/Library/CloudStorage/Dropbox/web-design/custom-css/chatgpt-images.css"
    "/Users/jaydixit/Dropbox/web-design/custom-css/sakura-1.50css"
    "/Users/jaydixit/Dropbox/web-design/custom-css/sans-serif.css"
    "/Users/jay/Dropbox/github/org-html-themes/src/bigblow_theme/css/bigblow.css"
"/Users/jay/Library/CloudStorage/Dropbox/github/incandescentman.github.io/css/iphone.css"
    "none")
  "List of CSS file options for Org HTML export.")

(defun select-org-export-css ()
  "Prompt the user to select a CSS file or choose none."
  (interactive)
  (setq my-org-selected-css
        (completing-read "Choose a CSS file or none: " my-org-css-options))
  (when (string-equal my-org-selected-css "none")
    (setq my-org-selected-css nil)))

(defun my-org-inline-css-hook (exporter)
  "Insert custom inline CSS for Org HTML export."
  (when (eq exporter 'html)
    (when (eq my-org-selected-css 'unset)
      (select-org-export-css))
    (if (and my-org-selected-css (not (eq my-org-selected-css 'unset)))
        (let ((final my-org-selected-css))
          (when (file-exists-p final)
            (setq org-html-head-include-default-style nil)
            (setq org-html-head (concat
                                 "<style type=\"text/css\">\n"
                                 "<!--/*--><![CDATA[/*><!--*/\n"
                                 (with-temp-buffer
                                   (insert-file-contents final)
                                   (buffer-string))
                                 "/*]]>*/-->\n"
                                 "</style>\n"))))
      (setq org-html-head-include-default-style nil)
      (setq org-html-head nil))))

(add-hook 'org-export-before-processing-hook 'my-org-inline-css-hook)
#+END_SRC

* hashtags
#+begin_src emacs-lisp
(defun show-duplicate-words (&optional alphabetical)
 "Collect all of the unique words in the current buffer and
display them in a new buffer. With prefix, alphabetize the
list."
 (interactive "P")
 (let ((buf (buffer-name))
    (new (get-buffer-create "*Unique Words*"))
    (txt (delete-dups (mapcar #'downcase
                 (split-string (buffer-string)
                        nil nil
                        "[^[:alnum:]]+")))))
  (with-current-buffer new
   (delete-region (point-min) (point-max))
   (insert (format "%d unique words in the <%s> buffer:\n\n"
           (length txt) buf))
   (cl-dolist (word (if alphabetical (sort txt #'string<) txt))
    (insert (concat word "\n"))))
  (pop-to-buffer new)))
#+end_src


* suppress org-tempo warning
Redefine org-tempo-add-templates

#+begin_src emacs-lisp

(defun org-tempo-add-templates ()
 "Update all Org Tempo templates.

Go through `org-structure-template-alist' and
`org-tempo-keywords-alist' and update tempo templates."
 (mapc 'org--check-org-structure-template-alist '(org-structure-template-alist
						  org-tempo-keywords-alist))
 (let ((keys (org-tempo--keys)))
  ;; Check for duplicated snippet keys and warn if any are found.
  (when (> (length keys) (length (delete-dups keys)))
)
  ;; Remove any keys already defined in case they have been updated.
  (setq org-tempo-tags
	 (cl-remove-if (lambda (tag) (member (car tag) keys)) org-tempo-tags))
  (mapc #'org-tempo-add-block org-structure-template-alist)
  (mapc #'org-tempo-add-keyword org-tempo-keywords-alist)))

#+END_SRC


* multiple cursors
#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :defer t)
(setq mc/list-file "/Users/jay/emacs/emacs-settings/mc-lists.el")


(define-key key-minor-mode-map (kbd "C-8") 'endless/mc-map)
(define-prefix-command 'endless/mc-map)
(define-key ctl-x-map "m" 'endless/mc-map)
(define-key key-minor-mode-map (kbd "C-8") 'endless/mc-map)

;;; Really really nice!
(define-key endless/mc-map "i" #'mc/insert-numbers)
(define-key endless/mc-map "h" #'mc-hide-unmatched-lines-mode)
(define-key endless/mc-map "a" #'mc/mark-all-like-this)

;;; Occasionally useful
(define-key endless/mc-map (kbd "<backspace>") 'delete-backward-char)
(define-key endless/mc-map "d" #'mc/mark-all-symbols-like-this-in-defun)
(define-key endless/mc-map "r" #'mc/reverse-regions)
(define-key endless/mc-map "s" #'mc/sort-regions)
(define-key endless/mc-map "l" #'mc/edit-lines)
(define-key endless/mc-map (kbd "<return>") #'newline-and-indent)
(define-key endless/mc-map "\C-a"
 #'mc/edit-beginnings-of-lines)
(define-key endless/mc-map "\C-e"
 #'mc/edit-ends-of-lines)
(define-key endless/mc-map (kbd ">") #'mc/cycle-forward)
(define-key endless/mc-map (kbd "<") #'mc/cycle-backward)

(use-package hydra
:defer t
  :ensure t)

(defhydra hydra-mc (:hint nil)
  "
Multiple cursors:

 Mark:   _n_ext   _p_revious   _a_ll   _l_ines      Unmark: _u_ next  _U_ prev
 Edit:   _i_nsert nums   edit _b_egin   edit _e_nd   _s_ort   _r_everse
 Cycle:  _>_ forward   _<_ backward
 Other:  _h_ide unmatched   _q_uit
"
  ("n" mc/mark-next-like-this)
  ("p" mc/mark-previous-like-this)
  ("a" mc/mark-all-like-this)
  ("l" mc/edit-lines)
  ("u" mc/unmark-next-like-this)
  ("U" mc/unmark-previous-like-this)
  ("i" mc/insert-numbers)
  ("b" mc/edit-beginnings-of-lines)
  ("e" mc/edit-ends-of-lines)
  ("s" mc/sort-regions)
  ("r" mc/reverse-regions)
  (">" mc/cycle-forward)
  ("<" mc/cycle-backward)
  ("h" mc-hide-unmatched-lines-mode)
  ("q" nil))

;; Bind hydra to your existing keymap
(define-key endless/mc-map (kbd "H") #'hydra-mc/body)


#+END_SRC
* org-mode-hooks and text-mode-hooks
** text-mode-hooks
#+begin_src emacs-lisp

(add-hook 'text-mode-hook 'flyspell-mode)
(add-hook 'text-mode-hook #'dubcaps-mode)
(add-hook 'org-mode-hook #'dubcaps-mode)

(add-hook 'text-mode-hook #'olivetti-mode 1)
;; (add-hook 'org-mode-hook 'turn-off-autocomplete-mode )

(add-hook 'org-mode-hook 'turn-on-flyspell)
;; (add-hook 'org-mode-hook (lambda () (flyspell-lazy-mode 1)))

;; (add-hook 'org-mode-hook #'flycheck-mode)
;; (add-hook 'org-mode-hook (lambda () (org-sticky-header-mode 1)))

#+end_src

** org-mode-hooks
#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook 'turn-on-visual-line-mode)
(add-hook 'org-mode-hook #'(lambda () (auto-fill-mode -1)))

;; (add-hook 'org-mode-hook 'turn-on-auto-capitalize-mode)


(add-hook 'org-mode-hook 'wrap-region-mode)
 (add-hook 'latex-mode-hook 'wrap-region-mode)

(add-hook
 'org-mode-hook
 (lambda ()
 (define-key org-mode-map (kbd "DEL")
  'new-org-delete-backward-char)))

#+END_SRC


* wide-screen
#+begin_src emacs-lisp
(defun wide-screen ()
(interactive)
(setq olivetti-body-width 72)
)
#+end_src


* hide blank lines only in heading mode
In collapsed view, hide empty lines between subtrees

#+begin_src emacs-lisp
(setq org-cycle-separator-lines 0)
#+end_src

* Demote sequence for list bullets
#+begin_src emacs-lisp
(setq org-list-demote-modify-bullet '(("+" . "-") ("-" . "+")))
#+end_src


* embiggen text
#+begin_SRC emacs-lisp


(defun embiggen-text ()
 (interactive)
 (text-scale-increase 1)
 )

(defun ensmallen-text ()
 (interactive)
 (text-scale-decrease 1)
 )

#+END_SRC


* yesterday
#+begin_src emacs-lisp

(defun yesterday ()
  (interactive)
    (insert (shell-command-to-string "echo -n $(date -v -1d +%F)"))
  )
#+end_src



For bash:

#+begin_src sh

yesterday=$(date -v -1d '+%m-%d-%y') && echo $yesterday

#+end_src

* today
#+begin_src emacs-lisp

(defun today ()
  (interactive)
    (insert (shell-command-to-string "echo -n $(date +%F)"))
  )
#+end_src


* minimalist org ellipsis
#+begin_src emacs-lisp
(custom-set-faces
 '(org-ellipsis ((t (:family "Iosevka Nerd Font" :foreground "LightGray" :underline nil)))))
(setq org-ellipsis " ")
;; (setq org-ellipsis " ▶")
#+end_src

Courtesy of Mike Goldenberg



* render org-tables in buffer
[[https://www.reddit.com/r/emacs/comments/d3a8or/pretty_org_tables_in_the_buffer_chapter_2_it/][Pretty org tables in the buffer - chapter 2 (it works properly) : emacs]]

#+begin_src emacs-lisp
(defun org-render-table-at-point ()
 (interactive)
 (save-excursion
  (beginning-of-line)
  (if (overlays-at (point))
    ;; this is a rough solution, because there can
    ;; be other overlays at point
    (delete-overlay (car (overlays-at (point))))

   (let* ((element-type (org-element-type (org-element-at-point))))
    (if (and (not (eq element-type 'table))
         (not (eq element-type 'table-row)))
      (error "not at an org table")

     (while (not (eq 'table (org-element-type (org-element-at-point))))
      (forward-line -1))

     (org-render-table (org-element-at-point)))))))


(defun org-render-table (table)
 (interactive)
 (let* ((begin (org-element-property :begin table))
     (end (let ((pos (org-element-property :end table)))
        (goto-char pos)
        (beginning-of-line)
        ;; skip possible space after table
        (while (not (looking-at " *[|#]"))
         (setq pos (point))
         (forward-line -1))
        pos))
     (tabletxt (buffer-substring-no-properties begin end))
     (img (with-temp-buffer
        (insert tabletxt)
        (mark-whole-buffer)
        (org-latex-convert-region-to-latex)
        (org-preview-latex-fragment)
        (goto-char (point-min))
        (overlay-get (car (overlays-at (point))) 'display)))
     (overlay (make-overlay begin end)))
  (overlay-put overlay 'display img)
  (forward-line -1)))


(defun org-render-tables-in-buffer ()
 (save-excursion
  (org-element-map (org-element-parse-buffer) 'table 'org-render-table)))

#+end_src


* org-show-inline-images
#+begin_src emacs-lisp
(defun org-show-inline-images ()
 (interactive)
(org-toggle-inline-images))
#+end_src

* ido-vertical-mode
Pretty cool here:
[[https://github.com/creichert/ido-vertical-mode.el][creichert/ido-vertical-mode.el: makes ido-mode display vertically]]


#+begin_src emacs-lisp
(use-package ido-vertical-mode
  :defer t)
(ido-mode 1)
(ido-vertical-mode 1)
(setq ido-vertical-define-keys 'C-n-and-C-p-only)

(setq ido-vertical-define-keys 'C-n-C-p-up-down-left-right)

;; optionally
(setq ido-use-faces nil)

;; (setq ido-use-faces t)
;; (set-face-attribute 'ido-vertical-first-match-face nil :foreground "orange")

#+end_src

#+begin_src emacs-lisp
(defvar mode-line-cleaner-alist
 `((auto-complete-mode . " α")
  (yas/minor-mode . " υ")
  (paredit-mode . " π")
  (eldoc-mode . "")
  (abbrev-mode . "")
  (rmail-mode . "")
  (counsel-mode . ".")
  (palimpsest-mode . "")
  ;; Major modes
  (lisp-interaction-mode . "λ")
  (hi-lock-mode . "")
  (python-mode . "Py")
  (emacs-lisp-mode . "EL")
  (nxhtml-mode . "nx"))
 "Alist for `clean-mode-line'.

When you add a new element to the alist, keep in mind that you
must pass the correct minor/major mode symbol and a string you
want to use in the modeline *in lieu of* the original.")


(defun clean-mode-line ()
 (interactive)
 (cl-loop for cleaner in mode-line-cleaner-alist
    do (let* ((mode (car cleaner))
         (mode-str (cdr cleaner))
         (old-mode-str (cdr (assq mode minor-mode-alist))))
       (when old-mode-str
         (setcar old-mode-str mode-str))
        ;; major mode
       (when (eq mode major-mode)
        (setq mode-name mode-str)))))


(add-hook 'after-change-major-mode-hook 'clean-mode-line)

;;; alias the new `flymake-report-status-slim' to
;;; `flymake-report-status'
(defalias 'flymake-report-status 'flymake-report-status-slim)
(defun flymake-report-status-slim (e-w &optional status)
 "Show \"slim\" flymake status in mode line."
 (when e-w
  (setq flymake-mode-line-e-w e-w))
 (when status
  (setq flymake-mode-line-status status))
 (let* ((mode-line " Φ"))
  (when (> (length flymake-mode-line-e-w) 0)
   (setq mode-line (concat mode-line ":" flymake-mode-line-e-w)))
  (setq mode-line (concat mode-line flymake-mode-line-status))
  (setq flymake-mode-line mode-line)
  (force-mode-line-update)))

(setq flymake-mode-line-format "")

(add-to-list 'mode-line-cleaner-alist '(org-ai-mode . ""))

(setq-default mode-line-format
       (remove '(vc-mode vc-mode) mode-line-format))

(setq evil-want-keybinding nil)
(setq evil-mode-line-format nil)

(setq gcmh-mode-line nil)


#+end_src

* org-timesheet
Source: [[https://emacs.stackexchange.com/questions/30280/how-to-conveniently-insert-a-clock-entry][org mode - How to conveniently insert a clock entry? - Emacs Stack Exchange]]

#+begin_src emacs-lisp
(defun timesheet_insert-custom-clock-entry ()
 (interactive)
 (insert "CLOCK: ")
 (org-time-stamp-inactive)
 (insert "--")
 ;; Inserts the current time by default.
 (let ((current-prefix-arg '(4))) (call-interactively 'org-time-stamp-inactive))
 (org-ctrl-c-ctrl-c))

#+end_src




* clean up tex files
[[https://emacs.stackexchange.com/questions/23982/cleanup-org-mode-export-intermediary-file][Cleanup org-mode export intermediary file - Emacs Stack Exchange]]

#+begin_src emacs-lisp
(setq org-latex-logfiles-extensions (quote ("lof" "lot" "tex" "odt" "aux" "idx" "log" "out" "toc" "nav" "snm" "vrb" "dvi" "fdb_latexmk" "blg" "brf" "fls" "entoc" "ps" "spl" "bbl")))
#+end_src



* koma letter
#+begin_src emacs-lisp
(add-to-list 'org-latex-classes
    '("my-letter"
     "\\documentclass\[%
 DIV=14,
 fontsize=12pt,
 parskip=half,
 subject=titled,
 backaddress=false,
 fromalign=left,
 fromemail=true,
 fromphone=true\]\{scrlttr2\}
 \[DEFAULT-PACKAGES]
 \[PACKAGES]
 \[EXTRA]"))

#+end_src

#+BEGIN_SRC emacs-lisp
(defun load-koma-letter ()
 (interactive)
 (load "/Users/jay/emacs/emacs-settings/ox-koma-letter.el")
 (load "/Users/jay/emacs/emacs-settings/fiverr-koma.el")
 )
#+END_SRC

* allow file local custom code
#+begin_src emacs-lisp
(setq enable-local-eval t)
#+end_src

* saveplace
#+begin_src emacs-lisp
(use-package saveplace
  :defer)
(setq-default save-place t)
#+end_src


* org export preserve line breaks
#+begin_src emacs-lisp
(setq org-export-preserve-breaks t)
#+end_src


* calc
#+begin_src emacs-lisp
(define-key key-minor-mode-map (kbd "M-=") 'calc-grab-region)
#+end_src


* trailing lines
#+begin_src emacs-lisp
(setq delete-trailing-lines nil)
#+end_SRC




* don't lock files
#+begin_src emacs-lisp
(setq create-lockfiles nil)
(run-with-idle-timer 300 t 'org-save-all-org-buffers)
#+end_SRC


* I love you
#+begin_src emacs-lisp
(defun iloveyou (args)
 (interactive "P")
(message "%s" (propertize "I love you! ❤️" 'Face '(:foreground "red")))
 )
#+end_src

* set OpenAI API key
Rewrite this emacs-lisp function to retrieve the API key from an external file: (setq openai-api-key "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")

Here is an example of how you might rewrite the function to retrieve the API key from an external file:

#+begin_src emacs-lisp
(defun get-openai-api-key ()
 "Retrieve the OpenAI API key from an external file."
 (let ((api-key-file "~/.openai-api-key"))
 (when (file-exists-p api-key-file)
  (with-temp-buffer
  (insert-file-contents api-key-file)
  (buffer-string)))))

(setq openai-api-key (get-openai-api-key))
#+end_src

This function will look for a file named ~/.openai/api-key, read the contents of the file, and return the API key as a string. The openai-api-key variable will then be set to this value.

* playing with ChatGTP
#+begin_src emacs-lisp
(defun start-pomodoro ()
 "Starts a 25-minute pomodoro timer and logs the completed pomodoro in a file called `~/pomodori.txt`."
 (interactive)
 (run-at-time "25 min" nil
        (lambda ()
         (with-current-buffer (find-file-noselect "~/pomodori.txt")
          (goto-char (point-max))
          (insert (concat (format-time-string "%Y-%m-%d %H:%M:%S")
                  ": Completed pomodoro\n"))
          (save-buffer))))
 (message "Pomodoro timer started. Will log completed pomodoro in `~/pomodori.txt` at %s"
      (format-time-string "%Y-%m-%d %H:%M:%S" (+ (float-time) (* 60 25)))))
#+end_SRC

* Warnings
#+begin_src emacs-lisp
(use-package warnings
  :defer t)
(add-to-list 'warning-suppress-types '(yasnippet backquote-change))
#+end_src

* org 9.6 suppress a weird error message
[[https://github.com/nobiot/org-transclusion/issues/105][Warning (emacs): org-element--cache: Unregistered buffer modifications detected. Resetting · Issue #105 · nobiot/org-transclusion]]

#+BEGIN_EXAMPLE emacs-lisp
(setq warning-suppress-types (append warning-suppress-types '((org-element-cache))))
#+END_EXAMPLE


* Export to .docx
#+begin_src emacs-lisp
(setq org-odt-preferred-output-format "docx")
#+end_src


* Capitalization
** Capitalize level 1 headings use correct rules of capitalizing titles
#+begin_src emacs-lisp
(defun org-titlecase-level-1 ()
 "Convert all Level 1 org-mode headings to title case."
 (interactive)
 (save-excursion
 (goto-char (point-min))
 (while (re-search-forward "^\\* " nil t)
  (titlecase-line))))
#+end_SRC

** Sentencecase-region
#+begin_EXAMPLE emacs-lisp
(defun sentencecase-region (start end)
 "Convert the region to sentence case."
 (interactive "r")
 (let ((end-marker (copy-marker end))) ; Create a marker to remember the end position
  (save-excursion
   (goto-char start)
   (downcase-region start end) ; First, make everything lowercase
   (while (< (point) end-marker)
    (when (or (and (eq (point) start) (bolp)) ; Special case for the start
         (eq (char-before) ?.) ; Period
         (eq (char-before) ?!) ; Exclamation mark
         (eq (char-before) ??)) ; Question mark
     (skip-syntax-forward " ") ; Skip any spaces
     (when (< (point) end-marker) ; Check if still within bounds
      (capitalize-word 1))) ; Capitalize the first word
    (forward-word 1)))))




#+END_EXAMPLE

^ doesn't work

#+begin_src emacs-lisp
(defun sentencecase-region (start end)
 "Convert the region to sentence case."
 (interactive "r")
 (let ((case-fold-search nil)) ; Make search case-sensitive
 (save-excursion
  (goto-char start)
  (downcase-region start end) ; Convert everything to lowercase first
  (while (< (point) end)
  (capitalize-word 1)  ; Capitalize the first word
  (forward-sentence))  ; Move to the next sentence
  (goto-char start)    ; Go back to the start to fix special cases
  (while (re-search-forward "\\bi\\b" end t)
  (replace-match "I"))
  (goto-char start)
  (while (re-search-forward "\\bi'" end t)
  (replace-match "I'"))
  (goto-char start)
  (while (re-search-forward "\\bjay\\b" end t)
  (replace-match "Jay"))
  (goto-char start)
  (while (re-search-forward "\\bsunjay\\b" end t)
  (replace-match "Sunjay"))
  (goto-char start)
  (while (re-search-forward "\\bdixit\\b" end t)
  (replace-match "Dixit")))))

#+end_src

* extract hyperlinks
#+begin_src emacs-lisp
(defun extract-hyperlinks-from-file (file)
 "Extracts all hyperlinks from the text file FILE."
 (interactive "fEnter file to extract hyperlinks from: ")
 (let ((hyperlinks '()))
  (with-temp-buffer
   (insert-file-contents file)
   (goto-char (point-min))
   (while (re-search-forward "\\(http\\|https\\|id\\)://[^[:space:]]+" nil t)
    (push (match-string-no-properties 0) hyperlinks)))
  (message "Hyperlinks extracted: %s" hyperlinks)
  hyperlinks))


(defun extract-hyperlinks-from-buffer ()
 "Extracts all hyperlinks from the current buffer."
 (interactive)
 (let ((hyperlinks '()))
  (save-excursion
   (goto-char (point-min))
   (while (re-search-forward "\\[\\[id:[^]]+\\]\\]" nil t)
    (push (match-string-no-properties 0) hyperlinks)))
  (message "Hyperlinks extracted: %s" hyperlinks)
  hyperlinks))

#+end_src





* Key chords
Use key chord
#+BEGIN_SRC emacs-lisp
(use-package key-chord
  :defer t)
(key-chord-mode 1)
#+END_SRC


* Add numbering
Written by ChatGPT 3.5 Worked the first time.

Jay:

Write an Emacs-lisp org-mode function to add numbering to a highlighted region.

ChatGPT:

Here's an Emacs Lisp function that can be used in Org-mode to add numbering to a highlighted region:

#+begin_src emacs-lisp
(defun number-region (beg end)
 "Add numbering to a highlighted region."
 (interactive "r")
 (let ((counter 1)
    (end-marker (copy-marker end)))
  (save-excursion
   (goto-char beg)
   (beginning-of-line)
   (while (< (point) end-marker)
    (insert (format "%d. " counter))
    (setq counter (1+ counter))
    (forward-line 1))
   (set-marker end-marker nil))))

#+end_src

To use this function, highlight the region you want to add numbering to and then call the ~number-region~ function using M-x ~number-region~. This will add a number to the beginning of each line in the highlighted region. The numbering will start from 1 and increment by 1 for each line.

* org-panes
#+begin_EXAMPLE emacs-lisp

(use-package org-panes
:defer t
 :ensure nil
 :config (setq org-panes-split-overview-horizontally t)
     (setq org-panes-main-size 70))

; org-panes and olivetti don't play well together
; because they both change window sizes. this function
; turns olivetti-mode off first if it's on, so that
; org-panes doesn't get confused about the window size
(defun org-panes-check-olivetti ()
 (interactive)
 (if (bound-and-true-p olivetti-mode)
   (progn (olivetti-mode -1)
       (org-panes)
       (olivetti-mode))
    (org-panes)))


     #+END_EXAMPLE

* word count
#+BEGIN_EXAMPLE emacs-lisp
(use-package wc-goal-mode
:defer t)
#+END_EXAMPLE


* org-roam
#+begin_src emacs-lisp
(load "/Users/jay/emacs/emacs-settings/org-roam-config.el")

 #+end_SRC




* consult
#+begin_src emacs-lisp
;; Example configuration for Consult
(use-package consult
:defer t
 :after (consult-eglot)
 ;; Replace bindings. Lazily loaded due by `use-package'.
 :bind (
;; ("C-s s" . consult-line)
;; 	 ("C-s e" . consult-eglot-symbols)
;; 	 ("C-s r" . consult-ripgrep)
;; ("s-G" . consult-ripgrep)
;; 	 ("C-s f" . consult-find)
;; 	 ("C-s l" . consult-flymake)
;; 	 ("C-s n" . consult-focus-lines)
;; 	 ("C-s I" . consult-project-imenu)
;; 	 ("C-s o" . consult-outline)
;; 	 ("C-s b" . consult-bookmark)
;; 	 ("C-s m" . consult-man)


   )

 ;; Enable automatic preview at point in the *Completions* buffer. This nt when you use the default completion UI.
 :hook (completion-list-mode . consult-preview-at-point-mode)

 ;; The :init configuration is always executed (Not lazy)
 :init

 (global-unset-key (kbd "C-s"))

 ;; Optionally configure the register formatting. This improves the register
 ;; preview for `consult-register', `consult-register-load',
 ;; `consult-register-store' and the Emacs built-ins.
 (setq register-preview-delay 0.5
    register-preview-function #'consult-register-format)

 ;; Optionally tweak the register preview window.
 ;; This adds thin lines, sorting and hides the mode line of the window.
 (advice-add #'register-preview :override #'consult-register-window)

 ;; Use Consult to select xref locations with preview
 (setq xref-show-xrefs-function #'consult-xref
    xref-show-definitions-function #'consult-xref)

 ;; Configure other variables and modes in the :config section,
 ;; after lazily loading the package.
 :config

 ;; Optionally configure preview. The default value
 ;; is 'any, such that any key triggers the preview.
 ;; (setq consult-preview-key 'any)
 ;; (setq consult-preview-key (kbd "M-."))
 ;; (setq consult-preview-key (list (kbd "<S-down>") (kbd "<S-up>")))
 ;; For some commands and buffer sources it is useful to configure the
 ;; :preview-key on a per-command basis using the `consult-customize' macro.
 (consult-customize
  consult-theme
  :preview-key '(:debounce 0.2 any)
  consult-ripgrep consult-git-grep consult-grep
  consult-bookmark consult-recent-file consult-xref
  consult--source-bookmark consult--source-recent-file
  consult--source-project-recent-file
  ;; :preview-key (kbd "M-."))

  ;; Optionally configure the narrowing key.
  ;; Both < and C-+ work reasonably well.
  (setq consult-narrow-key "<") ;; (kbd "C-+")

  ;; Optionally make narrowing help available in the minibuffer.
  ;; You may want to use `embark-prefix-help-command' or which-key instead.
  ;; (define-key consult-narrow-map (vconcat consult-narrow-key "?") #'consult-narrow-help)

  ;; By default `consult-project-function' uses `project-root' from project.el.
  ;; Optionally configure a different project root function.
  ;; There are multiple reasonable alternatives to chose from.
 ;;;; 1. project.el (the default)
  ;; (setq consult-project-function #'consult--default-project--function)
 ;;;; 2. projectile.el (projectile-project-root)
  ;; (autoload 'projectile-project-root "projectile")
  ;; (setq consult-project-function (lambda (_) (projectile-project-root)))
 ;;;; 3. vc.el (vc-root-dir)
  ;; (setq consult-project-function (lambda (_) (vc-root-dir)))
 ;;;; 4. locate-dominating-file
  ;; (setq consult-project-function (lambda (_) (locate-dominating-file "." ".git")))
  ))

(key-chord-define-global "SS" 'consult-line)

#+end_src


* org-roam-ui
Pretty knowledge graphs are to knowledge management what speaker lights are to music.

  #+begin_SRC emacs-lisp
(use-package org-roam-ui
:defer t
  :after org-roam
;;     normally we'd recommend hooking orui after org-roam, but since org-roam does not have
;;     a hookable mode anymore, you're advised to pick something yourself
;;     if you don't care about startup time, use
;; :hook (after-init . org-roam-ui-mode)

  :config
  (setq org-roam-ui-sync-theme t
     org-roam-ui-follow t
     org-roam-ui-update-on-save t
     org-roam-ui-open-on-start t))
#+end_SRC



* orderless
#+begin_src emacs-lisp
(use-package orderless

 :defer t
 :ensure t
 :custom
 (completion-styles '(orderless))
 (completion-category-overrides '((command (styles . (partial-completion))))))
  #+end_SRC


* vertico
#+begin_src emacs-lisp
(use-package marginalia
:defer t
:ensure t
 :delight
 :custom
 (marginalia-max-relative-age 0)
 (marginalia-align 'right)
 :init
 (marginalia-mode))

 (use-package vertico
:defer t
:ensure t
   :init
 (vertico-mode)

 ;; Different scroll margin
 ;; (setq vertico-scroll-margin 0)

 ;; Show more candidates
 ;; (setq vertico-count 20)

 (setq vertico-resize t)

 ;; Optionally enable cycling for `vertico-next' and `vertico-previous'.
 ;; (setq vertico-cycle t)
 )
#+end_SRC

* embark
#+begin_EXAMPLE emacs-lisp

(use-package embark
:defer t
 :ensure t

 :bind
 (("s-e" . embark-act)     ;; pick some comfortable binding
  ("C-;" . embark-dwim)    ;; good alternative: M-.
  ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'

 :init

 ;; Optionally replace the key help with a completing-read interface
 (setq prefix-help-command #'embark-prefix-help-command)

 ;; Show the Embark target at point via Eldoc. You may adjust the Eldoc
 ;; strategy, if you want to see the documentation from multiple providers.
 (add-hook 'eldoc-documentation-functions #'embark-eldoc-first-target)
 ;; (setq eldoc-documentation-strategy #'eldoc-documentation-compose-eagerly)

 :config

 ;; Hide the mode line of the Embark live/completions buffers
 (add-to-list 'display-buffer-alist
        '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
         nil
         (window-parameters (mode-line-format . none)))))

;; Consult users will also want the embark-consult package.
(use-package embark-consult
:defer t
 :ensure t ; only need to install it, embark loads it after consult if found
 :hook
 (embark-collect-mode . consult-preview-at-point-mode))
#+END_EXAMPLE


* show duplicate lines
#+begin_src emacs-lisp
(defun show-duplicate-lines ()
 "Display all duplicate lines in the current buffer."
 (interactive)
 (let ((lines (split-string (buffer-string) "\n" t))
    (seen-lines '())
    (dup-lines '()))
  (dolist (line lines)
   (if (member line seen-lines)
     (setq dup-lines (cons line dup-lines))
    (setq seen-lines (cons line seen-lines))))
  (if dup-lines
    (with-output-to-temp-buffer "*Duplicate Lines*"
     (dolist (line (reverse dup-lines))
      (princ (concat line "\n"))))
   (message "No duplicate lines found."))))
#+end_src



* Eisenhower Matrix :urgent:
#+begin_src emacs-lisp
(setq org-tag-alist '(("important" . ?i)
           ("urgent"  . ?u)))
#+end_src


#+begin_EXAMPLE emacs-lisp
(add-to-list 'load-path "/Users/jay/emacs/external-packages/chatgpt-shell-main")
(use-package chatgpt-shell
  :defer t)


#+END_EXAMPLE

* openwith
#+begin_src emacs-lisp

(use-package openwith
  :defer t)
(setq openwith-associations '(("\\.pdf\\'" "open" (file))))
(openwith-mode t)
#+end_src


* load my LaTeX config only when I actually need to export something
Jay: How do I direct Emacs to load a file (containing my org-mode LaTeX
export configuration) the first time I run org Export to LaTeX?

ChatGPT: You can achieve this by using the ~org-export-before-processing-hook~.
This hook allows you to run a custom function before the export process
starts. You can define a custom function to load your Org-mode LaTeX
export configuration file and add this function to the hook.

Jay: Can I make it load this file only the first time I export something to
LaTeX, rather than every time?

ChatGPT: Yes, you can achieve this by modifying your custom function to remove
itself from the ~org-export-before-processing-hook~ after it loads your
configuration file. This way, the function will be executed only once
during the first export:

#+begin_src emacs-lisp
(add-hook 'org-export-before-processing-hook 'my-load-org-latex-export-config)

(defun my-load-org-latex-export-config (&rest args)
  "Load the Org-mode LaTeX export configuration file and remove itself from the hook."
  (jay-load-latex)
  (remove-hook 'org-export-before-processing-hook 'my-load-org-latex-export-config))
#+end_src


* org-autolist
#+begin_EXAMPLE emacs-lisp
(use-package org-autolist
:defer t
:hook (org-mode . org-autolist-mode))
(add-hook 'org-mode-hook (lambda () (org-autolist-mode)))

(setq org-autolist-enable-delete nil)
#+END_EXAMPLE

*** org-autolist deleting list items
Suppose we start with:

#+begin_example
- [ ] one
- [ ] two
- [ ] apple
- [ ] |
#+end_example

Pressing "Backspace" will produce:

#+begin_example
- [ ] one
- [ ] two
- [ ] apple|
#+end_example

Similarly, if we instead start from here:

#+begin_example
- [ ] one
- [ ] two
- [ ] |apple
#+end_example

Then pressing "Backspace" will produce:

#+begin_example
- [ ] one
- [ ] two|apple
#+end_example

If you want to disable this behavior, add this to your ~init.el~:

#+begin_SRC emacs-lisp
(setq org-autolist-enable-delete nil)
#+END_SRC

*** start at the right number
[[https://www.reddit.com/r/orgmode/comments/10ybf40/how_to_force_orgautolistel_to_start_from_the/][How to force org-autolist.el to start from the number I choose : orgmode]]

* dictionaries
Three different dictionary programs:

irony

** ~define-word~
- its own dictionary. Definitions appear in minibuffer, which is weird.
- But nicely formatted

#+begin_src emacs-lisp
(defun define-word--convert-html-tag-to-face (str)
 "Replace semantical HTML markup in STR with the relevant faces."
 (with-temp-buffer
  (insert str)
  ;; Remove empty <i></i> tags
  (goto-char (point-min))
  (while (re-search-forward "<i></i>" nil t)
   (replace-match ""))
  (cl-loop for (regexp face) in define-word--tag-faces do
     (define-word--regexp-to-face regexp face))
  (buffer-string)))

#+end_src

** dictionary
- dictionary-lookup-definition
- dictionary-search
- via dict.org
- choice of wordnet, websters (gcide)

** sdcv
Gives me all the offline dictionaries I've previously installed! Is great.

#+begin_src emacs-lisp
(use-package sdcv
:defer t
:custom
sdcv-popup-function 'showtip)
#+end_SRC

* consult ripgrep
Avoid recentering errors. Works!
#+begin_src emacs-lisp
(defun consult-recenter-advice (orig-fn &rest args)
 "Advice for `recenter' to avoid errors when the window is not displaying the current buffer."
 (when (eq (window-buffer) (current-buffer))
  (apply orig-fn args)))

(advice-add 'recenter :around #'consult-recenter-advice)
#+end_src


* outdent or promote
Do the same thing whether on a plain text list or an org heading.
#+begin_src emacs-lisp
(defun org-outdent-or-promote ()
 "Run either org-outdent-item-tree or org-promote-subtree,
depending on which one is appropriate based on the context."
 (interactive)
 (cond
 ;; If the cursor is on a plain list item, run org-outdent-item-tree
 ((org-at-item-p) (org-outdent-item-tree))
 ;; If the cursor is on a headline, run org-promote-subtree
 ((org-at-heading-p) (org-promote-subtree))
 ;; Otherwise, do nothing and show a message
 (t (message "Not at an item or a headline"))))

(defun org-indent-or-demote ()
 "Run either org-indent-item-tree or org-demote-subtree,
depending on which one is appropriate based on the context."
 (interactive)
 (cond
  ;; If the cursor is on a plain list item, run org-indent-item-tree
  ((org-at-item-p) (org-indent-item-tree))
  ;; If the cursor is on a headline, run org-demote-subtree
  ((org-at-heading-p) (org-demote-subtree))
  ;; Otherwise, do nothing and show a message
  (t (message "Not at an item or a headline"))))
#+end_src


* Info mode
#+begin_src emacs-lisp
; (define-key Info-mode-map (kbd "s-o") 'copy-region-to-other-window)
; (define-key org-mode-map (kbd "s-o") 'move-region-to-other-window)
(define-key Info-mode-map (kbd "s-[") 'Info-backward-node)
(define-key Info-mode-map (kbd "s-]") 'Info-forward-node)
#+end_src


* toggle between two windows but not the third
#+begin_src emacs-lisp
(defun toggle-window-2-3 ()
 "Toggle between window 2 and window 3 using winum."
 (interactive)
 (let ((current-window (winum-get-number)))
  (cond ((= current-window 2)
      (winum-select-window-by-number 3))
     ((= current-window 3)
      (winum-select-window-by-number 2))
     (t
      (message "Point is not in window 2 or 3.")))))
;; (define-key key-minor-mode-map (kbd "s-`") 'toggle-window-2-3)
#+end_src


* fuzzy open recent file
This is my goto way for navigating. It feels like it is reading your mind.

#+begin_src emacs-lisp
;;;; 0.  make Emacs start with your full shell environment  ;;;;



;; (use-package exec-path-from-shell
;;   :demand t
;;   :custom
;;   (exec-path-from-shell-arguments '("-l"))   ; no "-i"
;;   :config
;;   (exec-path-from-shell-initialize)
;; )


(setenv "FASD_DATA" (expand-file-name "~/.fasd"))

  ;; import PATH and other vars
  ;; (dolist (var '("PATH" "FASD_OPTS"))
  ;;   (exec-path-from-shell-copy-env var)))

;;;; 1.  fasd ----------------------------------------------------

(use-package ivy :ensure t)
(use-package fasd
  :ensure t
  :after ivy)

(use-package fasd
  :commands (fasd-find-file)
  :init
  ;; do NOT auto-prompt --- the command runs with an empty query
  (setq fasd-enable-initial-prompt nil)
  :config
  ;; ------------------------------------------------------------
  ;;  one single dispatcher
  ;; ------------------------------------------------------------
(defun fasd-find-file (&optional prefix query)
  "Jump to a file/dir with fasd.
PREFIX >1 ⇒ dirs only,  PREFIX <0 ⇒ files only,  none ⇒ both."
  (interactive "P")
  (unless (executable-find "fasd")
    (user-error "fasd executable not found in PATH"))
  ;; --- build the CLI we know works for us -------------------
  (let* ((type-opt (pcase (prefix-numeric-value prefix)
                     ((pred (< 0)) " -f")     ; negative = files only
                     ((pred (> 1)) " -d")     ; >1 = dirs only
                     (_ "")))                 ; default = both
         ;; Here we use  -s (score) + -l (list)
         (cmd (string-trim
               (format "fasd -sl%s %s"
                       type-opt
                       (shell-quote-argument (or query "")))))
         (cands (split-string (shell-command-to-string cmd) "\n" t)))
    (unless cands
      (user-error "fasd returned nothing (cmd was: %s)" cmd))
    (let ((choice (completing-read "fasd: " cands nil t)))
      (if (file-directory-p choice)
          (dired choice)
        (find-file choice)))))
)

;; ------------------------------------------------------------
;;  Global function to add paths to fasd
;; ------------------------------------------------------------
(defun my/fasd--add (path)
  "Register PATH in the fasd database, if fasd is available."
  (when (and path                       ; a real file/dir
             (executable-find "fasd")   ; the binary is in PATH
             (file-exists-p path))
    ;; run asynchronously - never blocks Emacs
    (start-process "fasd-add" nil "fasd" "--add" (expand-file-name path))))

;; ------------------------------------------------------------
;;  Hook it up to file visits
;; ------------------------------------------------------------
(add-hook 'find-file-hook          ; every real file you visit
          (lambda () (my/fasd--add buffer-file-name)))

(add-hook 'dired-after-readin-hook ; every directory you enter in Dired
          (lambda () (my/fasd--add
                      (if (stringp dired-directory)
                          dired-directory
                        (car dired-directory)))))
#+end_src


* Google things from within emacs
#+begin_SRC emacs-lisp
(use-package google-this
:defer t
:custom
(google-this-browse-url-function 'eww-browse-url)
  )


(defun google-word-and-display-in-EWW ()
 "Google the word at point and display the results in the minibuffer using EWW."
 (interactive)
 (let ((word (thing-at-point 'word t)))
  (if word
    (progn
     (eww-browse-url (concat "https://www.google.com/search?q=" word))
     (message "Showing results for %s in EWW" word))
   (message "No word at point"))))

(define-key key-minor-mode-map (kbd "M-g M-g") 'google-this)

(defun er-google ()
 "Google the selected region if any, display a query prompt otherwise."
 (interactive)
 (browse-url
  (concat
  "http://www.google.com/search?ie=utf-8&oe=utf-8&q="
  (url-hexify-string (if mark-active
     (buffer-substring (region-beginning) (region-end))
    (read-string "Google: "))))))

   #+end_SRC

* EWW
o: open in external browser
r: reload
w: copy-page-url
v: view-source

#+begin_src emacs-lisp
(use-package eww
:defer t
:bind
  (
   :map eww-mode-map
        ("o" . eww-browse-with-external-browser)
        ("r" . eww-reload)
        ("s-l" . eww)
        ("s-[" . eww-back-url)
        ("s-]" . eww-forward-url)
        ("s-o" . eww-open-file)
   ))
#+end_src

If you want to waste some time, there are some extras here:
https://protesilaos.com/codelog/2021-03-25-emacs-eww/

(set-face-attribute 'org-variable-pitch-face (face-attribute 'default :font))

* consult git grep
#+begin_src emacs-lisp
;; (setq consult-git-grep-args )
#+end_src


* org-mac-link
** edge
#+begin_src emacs-lisp
(use-package org-mac-link
  :ensure t        ;; auto‑install if needed (remove if you vendor it)
  :defer nil       ;; load immediately so your redefs take effect
  :config
  ;; (Anything that depends on org-mac-link being loaded can live here.)
  )

(defun org-mac-paste-applescript-links (as-link-list)
  "Convert AS-LINK-LIST returned by AppleScript to Org links and yank it.

Input format is one link per line, each line:
   \"URL::split::Title\""
  (let* ((raw (string-trim as-link-list "\"" "\""))
         (lines (split-string raw "[\r\n]+" t))
         (links (cl-loop for l in lines
                         for parts = (split-string l "::split::")
                         for url  = (car parts)
                         for desc = (cadr parts)
                         unless (string-empty-p url)
                         collect (org-make-link-string url desc))))
    (kill-new (string-join links "\n"))
    (car kill-ring)))

(defun org-mac-link-skim-open (uri _)
  "Open a Skim link URI.
Accepted formats:
  skim://path/to/file.pdf::123   ; jump to page 123
  skim://path/to/file.pdf        ; just open the PDF"
  (let* ((pos   (string-match "::\\([0-9]+\\)\\'" uri)) ; position of "::"
         (page  (if pos (match-string 1 uri) "1"))      ; default to page 1
         (doc   (if pos (substring uri 0 pos) uri)))
    (do-applescript
     (format
 "tell application \"Skim\"
    activate
    open (quoted form of POSIX file \"%s\")
    go document 1 to page %s of document 1
  end tell" doc page)
     )))

;;;###autoload
(defun org-mac-bing-insert-frontmost-url () …)
;;;###autoload
(defun org-mac-bing-get-frontmost-url () …)
;;;###autoload
(defun org-mac-link-skim-open (uri _) …)
 #+end_SRC

** don't number windows
#+begin_src emacs-lisp
(defun org-mac-link--clean-title (title)
  "Remove unwanted prefixes like '(2) ' from TITLE."
  (replace-regexp-in-string "^([0-9]+)\\s-+" "" title))

(defun org-mac-link-chrome-copy-frontmost-url ()
  "Retrieve the URL and title from the frontmost Google Chrome tab and copy as an Org-mode link."
  (interactive)
  (let* ((as-command
          "tell application \"Google Chrome\"
               if not (exists front window) then return \"NO_ACTIVE_TAB\"
               set theURL to URL of active tab of front window
               set theTitle to title of active tab of front window
               return theURL & \"§§§\" & theTitle
           end tell")
         (as-result (string-trim (shell-command-to-string (concat "osascript -e " (shell-quote-argument as-command))))))
    (if (string-equal as-result "NO_ACTIVE_TAB")
        (message "No active tab found in Google Chrome.")
      (let* ((components (split-string as-result "§§§"))
             (url (string-trim (nth 0 components)))
             (title (org-mac-link--clean-title (string-trim (nth 1 components))))
             (org-link (format "[[%s][%s]]" url title)))
        (kill-new org-link)
(message "Copied Org link to clipboard: %s" org-link)
))))

(defun org-mac-link-chrome-insert-frontmost-url ()
  "Insert the URL and title from the frontmost Google Chrome tab as an Org-mode link."
  (interactive)
  (let* ((as-command
          "tell application \"Google Chrome\"
               set theURL to URL of active tab of front window
               set theTitle to title of active tab of front window
               return theURL & \"§§§\" & theTitle
           end tell")
         (as-result (string-trim (shell-command-to-string (concat "osascript -e " (shell-quote-argument as-command)))))
         (components (split-string as-result "§§§"))
         (url (string-trim (nth 0 components)))
         (title (org-mac-link--clean-title (string-trim (nth 1 components))))
         (org-link (format "[[%s][%s]]" url title)))
    (insert org-link)
;; (message "Inserted Org link: %s" org-link)
))

;; or in Safari format
(defun org-mac-link-chrome-insert-frontmost-url (arg)
  "Insert URL and title from frontmost Chrome tab as Org-mode link.
With prefix ARG, insert using 'safari' custom link type."
  (interactive "P")
  (let* ((as-command
          "tell application \"Google Chrome\"
               set theURL to URL of active tab of front window
               set theTitle to title of active tab of front window
               return theURL & \"§§§\" & theTitle
           end tell")
         (as-result (string-trim (shell-command-to-string (concat "osascript -e " (shell-quote-argument as-command)))))
         (components (split-string as-result "§§§"))
         (url (string-trim (nth 0 components)))
         (title (org-mac-link--clean-title (string-trim (nth 1 components))))
         (org-link (if arg
                       (format "[[safari:%s][%s]]" url title) ; Safari format if universal arg
                     (format "[[%s][%s]]" url title))))       ; Default format otherwise
    (insert org-link)))

#+end_src

* org-refile-region-to-org-heading-or-roam-node
wonder if this could help...
https://www.reddit.com/r/emacs/comments/l99xc8/consult_got_support_for_multiple_candidate_sources/

#+begin_EXAMPLE emacs-lisp
(defun org-refile-region-to-org-heading-or-roam-node (beg end &optional copy)
 "Refile the region between BEG and END to an Org mode heading or Org-roam node.
If COPY is non-nil, copy the region instead of cutting it."
 (interactive "r\nP")
 (let* ((target (org-refile-get-location))
     (file (nth 1 target))
     (pos (nth 3 target))
     (text (buffer-substring-no-properties beg end)))
  (if pos
    (progn
     (unless copy
      (kill-region beg end))
     (deactivate-mark)
     (with-current-buffer (find-file-noselect file)
      (save-excursion
       (goto-char pos)
       (if (eql refile-region-position 'bottom)
         (org-end-of-subtree)
        (org-end-of-meta-data))
       (insert (format refile-region-format text)))))
   (progn
    (message "Target: %s" target)
    (user-error "Invalid target location")))))


(defun org-refile-get-location (&optional prompt default-buffer new-nodes)
 "Prompt the user for a refile location, including Org-roam nodes.
PROMPT should not be suffixed with a colon and a space, because
this function appends the default value from
`org-refile-history' automatically, if that is not empty."
 (let ((org-refile-targets org-refile-targets)
    (org-refile-use-outline-path org-refile-use-outline-path))
  (setq org-refile-target-table (org-refile-get-targets default-buffer)))
 (unless org-refile-target-table
  (user-error "No refile targets"))

 (let* ((cbuf (current-buffer))
     (cfn (buffer-file-name (buffer-base-buffer cbuf)))
     (cfunc (if (and org-refile-use-outline-path
             org-outline-path-complete-in-steps)
          #'org-olpath-completing-read
         #'completing-read))
     (extra (if org-refile-use-outline-path "/" ""))
     (cbnex (concat (buffer-name) extra))
     (filename (and cfn (expand-file-name cfn)))
     (org-cands (mapcar
           (lambda (x)
            (if (and (not (member org-refile-use-outline-path
                       '(file full-file-path title)))
                (not (equal filename (nth 1 x))))
              (cons (concat (car x) extra " ("
                     (file-name-nondirectory (nth 1 x)) ")")
                 (cdr x))
             (cons (concat (car x) extra) (cdr x))))
           org-refile-target-table))
     (roam-cands (mapcar (lambda (node)
                (cons (org-roam-node-title node)
                   (list (org-roam-node-file node)
                      (org-roam-node-point node))))
               (org-roam-node-list)))
     (tbl (append org-cands roam-cands))
     (completion-ignore-case t)
     cdef
     (prompt (let ((default (or (car org-refile-history)
                  (and (assoc cbnex tbl) (setq cdef cbnex)
                     cbnex))))
          (org-format-prompt prompt default)))
     answ)
  (setq answ (funcall cfunc prompt tbl nil (not new-nodes)
            nil 'org-refile-history
            (or cdef (car org-refile-history))))
  (if (assoc answ tbl)
    (let ((location-data (cdr (assoc answ tbl))))
     (if (org-roam-node-p (car location-data))
       (list answ (org-roam-node-file (car location-data)) (org-roam-node-point (car location-data)))
      location-data))
   (if (string-match "\\`\\(.*\\)/\\([^/]+\\)\\'" answ)
     (progn
      (setq parent (match-string 1 answ)
         child (match-string 2 answ))
      (setq parent-target (org-refile--get-location parent tbl))
      (when (and parent-target
            (or (eq new-nodes t)
              (and (eq new-nodes 'confirm)
                (y-or-n-p (format "Create new node \"%s\"? "
                         child)))))
       (org-refile-new-child parent-target child)))
    (user-error "Invalid target location")))))

#+END_EXAMPLE


* aliases
#+begin_src emacs-lisp
(defalias 'affe-grep-current-project 'affe-grep)
(defalias 'consult-grep-current-project 'consult-grep)


(defalias 'affe-find-filenames-and-folder-names 'affe-find)
(defalias 'consult-find-filenames-and-folder-names 'consult-find)

(defalias 'counsel-google 'counsel-search)
(defalias 'google-counsel-Google-with-autosuggest 'counsel-search)
#+end_src


* ignore unresolvable links
Instead of canceling export. So that I can export org-roam nodes if I want to.

** my own attempts to fix this. Second one worked
#+begin_SRC emacs-lisp
(use-package org-roam-export
  :defer)

(defun org-export-id-link-removal (backend)
 "Inspired by 'org-attach-expand-links' ，which is in 'org-export-before-parsing-functions' "
 (save-excursion
  (while (re-search-forward "id:" nil t)
   (let ((link (org-element-context)))
    (if (and (eq 'link (org-element-type link))
         (string-equal "id"
                (org-element-property :type link)))
      (let ((description (and (org-element-property :contents-begin link)
                  (buffer-substring-no-properties
                   (org-element-property :contents-begin link)
                   (org-element-property :contents-end link))))
         )
       (goto-char (org-element-property :end link))
       (skip-chars-backward " \t")
       (delete-region (org-element-property :begin link) (point))
       (insert description))
     )))))

(add-to-list 'org-export-before-parsing-functions #'org-export-id-link-removal)
#+END_SRC


* org-agenda
#+begin_src emacs-lisp
;; (setq org-agenda-files '("/Users/jay/dropbox/roam/notes"))
#+end_src

* org-attach
#+begin_src emacs-lisp

(setq org-attach-auto-tag "ATTACHMENTS")
(setq org-attach-id-dir "/Users/jay/dropbox/roam/attachments")
(defun org-roam-show-attachments (node)
  (when-let ((id (org-roam-node-id node))
             (folder (org-attach-dir-from-id id t))
             (attached-files (org-attach-file-list folder)))
    (magit-insert-section (org-roam-show-attachments)
      (magit-insert-heading "Attached Files")
      (dolist (file attached-files)
        (insert (org-roam-fontify-like-in-org-mode
                 (format " - [[file:%s/%s][%s]]\n" folder file file))))
      (insert "\n"))))
#+end_src

** org unique ID method
Source: [[https://taonaw-blog.netlify.app/2022-03-13/][Org ID, Org Attach & Better Folder Names · The Art of Not Asking Why]]


#+begin_src emacs-lisp
(setq org-id-method 'ts)
(setq org-attach-id-to-path-function-list
 '(org-attach-id-ts-folder-format
  org-attach-id-uuid-folder-format))
#+end_src

* org-roam browsing history
#+begin_src emacs-lisp
(winner-mode +1)
(define-key winner-mode-map (kbd "s-[") #'winner-undo)
(define-key winner-mode-map (kbd "s-]") #'winner-redo)
#+end_src


* deft
#+begin_EXAMPLE emacs-lisp
(use-package deft
:defer
:after org
 :bind
 ("s-k d e" . deft)
 :custom
 (deft-recursive t)
 (deft-use-filter-string-for-filename t)
 (deft-default-extension "org")
 (deft-directory org-roam-directory))
#+END_EXAMPLE


* rg
#+begin_src emacs-lisp


;; (rg-enable-default-bindings)
#+end_src


* deadgrep
#+begin_src emacs-lisp
(use-package deadgrep
  :defer)
(define-key key-minor-mode-map (kbd "s-k d g") 'deadgrep-current-directory)
#+end_src


* search recently used directories
#+begin_src emacs-lisp

 (defun timu/search-org-files ()
  "Grep for a string in the `~/org' using `rg'."
  (interactive)
(consult-ripgrep "~/org" ""))

 (defun timu/search-project-files ()
  "Grep for a string in the `~/projects' using `rg'."
  (interactive)
(consult-ripgrep "~/projects" ""))

#+end_src

* org headings
#+begin_src emacs-lisp

(defun timu/org-go-to-heading (&optional arg)

"Go to an outline heading with `consult-org-heading'. Also move the heading to the top of the buffer with `evil-scroll-line-to-top'"

  (interactive)

(consult-org-heading)
(evil-scroll-line-to-top arg))

#+end_src


* Dired
Here's an adaptation of dired-create-directory. It works the same way, so as well as a plain filename, you can also specify new parent directories (to be created under the current directory) for the file (e.g. foo/bar/filename).


#+BEGIN_SRC emacs-lisp

; dired Settings
(setq dired-clean-up-buffers-too nil
      dired-kept-versions 8)



;; (use-package dired-details+)



;; (defadvice dired-readin
;;     (after dired-after-updating-hook first () activate)
;;   "Sort dired listings with directories first before adding marks."
;;   (mydired-sort)
;;   (let ((dired-details-internal-overlay-list  ())) (dired-details-hide)))

(defcustom dired-details-hidden-string ""
  "*This string will be shown in place of file details and symbolic links."
  :group 'dired-details
  :type 'string)

(defcustom dired-details-initially-hide t
  "*Hide dired details on entry to dired buffers."
  :group 'dired-details
  :type 'boolean)


       (defun my-dired-create-file (file)
         "Create a file called FILE.
  If FILE already exists, signal an error."
         (interactive
          (list (read-file-name "Create file: " (dired-current-directory))))
         (let* ((expanded (expand-file-name file))
                (try expanded)
                (dir (directory-file-name (file-name-directory expanded)))
                new)
           (if (file-exists-p expanded)
               (error "Cannot create file %s: file exists" expanded))
           ;; Find the topmost nonexistent parent dir (variable `new')
           (while (and try (not (file-exists-p try)) (not (equal new try)))
             (setq new try
                   try (directory-file-name (file-name-directory try))))
           (when (not (file-exists-p dir))
             (make-directory dir t))
           (write-region "" nil expanded t)
           (when new
             (dired-add-file new)
             (dired-move-to-filename))))
#+END_SRC

Although I've specified a user-reserved binding in the code, I've actually bound this to _ which on my keyboard layout is the shifted sequence next to +, meaning the keys for "new directory" and "new file" in dired are right next to one another.

** open current directory in Finder
#+begin_src emacs-lisp

(defun timu-baseline-async-shell-command-no-window (command)

 "Do not display the `async-shell-command' COMMAND output buffer.

Credit: https://stackoverflow.com/a/60333836

Credit: https://stackoverflow.com/a/47910509."

 (interactive)

 (let ((display-buffer-alist

     (list (cons

        "\\*Async Shell Command\\*.*"

        (cons #'display-buffer-no-window nil)))))

  (async-shell-command command)))


(defun shell-open-dir ()
 "Open current directory at point with shell command \"open\".
This will open \"Finder.app\" at current location."
 (interactive)
 (timu-baseline-async-shell-command-no-window "open ./" ))


(defun dired-up-directory ()
 "Go up a directory in `dired'."
 (interactive)
 (find-alternate-file ".."))

(defun jay-up-directory ()
  "If in Dired, go up.  Otherwise open parent dir in Dired."
  (interactive)
  (cond
   ;; Already in Dired → behave like the native command
   ((derived-mode-p 'dired-mode)
    (find-alternate-file ".."))
   ;; Visiting a real file → open its parent directory
   (buffer-file-name
    (dired (file-name-directory buffer-file-name)))
   ;; Fallback: prompt for a directory
   (t
    (call-interactively #'dired))))


(defun dired-copy-path-at-point ()
 "Copy the full path of the at `point' to the `kill-ring'.
Credit: https://emacs.stackexchange.com/a/36851/30874"
 (interactive)
 (dired-copy-filename-as-kill 0))



(defun dired-shell-open-dir ()
 "Open current directory at point with shell command \"open\".
This will open \"Finder.app\" at current location."
 (interactive)
 (timu-baseline-async-shell-command-no-window "open ./" ))

#+end_src

** quicklook
#+begin_src emacs-lisp
(defun quicklook ()
 "Open the files at point with shell command \"qlmanage\".
This will display a Quicklook of the file at point in macOS."
 (interactive)
 (setq file (dired-get-file-for-visit))
 (timu-baseline-async-shell-command-no-window
  (concat "qlmanage -p " (shell-quote-argument file) " > /dev/null 2>&1")))
#+end_src

** use dired for directory links
#+BEGIN_SRC emacs-lisp
(add-to-list 'org-file-apps '(directory . emacs))
#+END_SRC


Use this notation in the org mode to create a link:

It will open the link in Emacs with typing C-c C-o.

** touch-file
#+BEGIN_SRC emacs-lisp

    (defun touch-file (file)
    "Create a file called FILE.
  If FILE already exists, signal an error."
    (interactive
    (list (read-file-name "Create file: " (dired-current-directory))))
    (let* ((expanded (expand-file-name file))
      (try expanded)
      (dir (directory-file-name (file-name-directory expanded)))
      new)
     (if (file-exists-p expanded)
      (error "Cannot create file %s: file exists" expanded))
     ;; Find the topmost nonexistent parent dir (variable `new')
     (while (and try (not (file-exists-p try)) (not (equal new try)))
     (setq new try
       try (directory-file-name (file-name-directory try))))
     (when (not (file-exists-p dir))
     (make-directory dir t))
     (write-region "" nil expanded t)
     (when new
     (dired-add-file new)
     (dired-move-to-filename))))
#+END_SRC



*** open recent directories
#+BEGIN_EXAMPLE emacs-lisp
;; open recent directory, rquires ivy (part of swiper)
;; borrows from http://stackoverflow.com/questions/23328037/in-emacs-how-to-maintain-a-list-of-recent-directories
(defun bjm/ivy-dired-recent-dirs ()
 "Present a list of recently used directories and open the selected one in dired"
 (interactive)
 (let ((recent-dirs
     (delete-dups
     (mapcar (lambda (file)
          (if (file-directory-p file) file (file-name-directory file)))
         recentf-list))))

  (let ((dir (ivy-read "Directory: "
             recent-dirs
             :re-builder #'ivy--regex
             :sort nil
             :initial-input nil)))
   (dired dir))))


;; (define-key key-minor-mode-map (kbd "C-x d") 'bjm/ivy-dired-recent-dirs)
;; c-x C-d runs the command ido-list-directory
#+END_EXAMPLE

**** dired-quick-sort
#+BEGIN_SRC emacs-lisp
(use-package dired-quick-sort
  :defer)
#+END_SRC


***** dired
#+begin_src emacs-lisp
;; (define-key dired-mode-map (kbd "<return>") 'dired-find-file-other-window)
#+end_src

****** open in external app
#+begin_src emacs-lisp
(defun timu-dired-open-in-external-app (&optional file)

 "Open the current FILE or Dired marked files in external app.

The app is chosen from your OS's preference.

Credit: http://xahlee.info/emacs/emacs/emacs_dired_open_file_in_ext_apps.html."

 (interactive)

 (let (doIt (myFileList

       (cond

        ((eq major-mode 'dired-mode)

        (dired-get-marked-files))

        ((not file) (list (buffer-file-name)))

        (file (list file)))))

  (setq doIt (if (<= (length myFileList) 30) t

         (y-or-n-p "Open more than 30 files? ")))

  (when doIt

   (cond

    ((string-equal system-type "windows-nt")

    (mapc (lambda (fPath)

        (w32-shell-execute

         "open" (replace-regexp-in-string "/" "\\" fPath t t)))

       myFileList))

    ((string-equal system-type "darwin")

    (mapc (lambda (fPath)

        (shell-command (format "open \"%s\"" fPath)))

       myFileList))

    ((string-equal system-type "gnu/linux")

    (mapc (lambda (fPath)

        (let ((process-connection-type nil))

         (start-process "" nil "xdg-open" fPath))) myFileList))))))

#+end_src


** dired-preview
#+begin_src sh
(add-to-list 'load-path "/Users/jay/emacs/external-packages/dired-preview")

(use-package dired-preview
:defer t)



#+end_src


** nvalt
#+begin_src emacs-lisp
(defun nvalt ()
 "Open the directory in dired and run dired-preview."
 (interactive)

 (let ((directory "/Users/jay/Library/Mobile Documents/27N4MQEA55~pro~writer/Documents/"))
  (dired directory)
  (dired-preview-mode)))

#+end_src

* counsel-fd
** Usage
~M-x counsel-fd-dired-jump~ to jump to a subdirectory under current
directory

~M-x counsel-fd-file-jump~ to jump to a file under current directory

#+begin_src emacs-lisp
(use-package counsel-fd
  :defer t)
#+end_src


* consult-locate
Maybe to replace fasd?

#+begin_src emacs-lisp
(setq consult-locate-args "fasd -t -l -R")
(define-key key-minor-mode-map (kbd "C-x C-l") 'consult-locate)
#+end_src


* source current file
Doesn't work

#+begin_src emacs-lisp
(defun source-current-file ()
 "Source the current file in a shell."
 (interactive)
 (let* ((filename (buffer-file-name))
     (cmd (format "source %s" (shell-quote-argument filename)))
     (output (shell-command-to-string cmd)))
  (message "Output: %s" output)))
#+end_src


* fitness.org
#+begin_src emacs-lisp
;; The fitness.org file calls this function to eval the configuration source
;; block. This is the only function that needs to be defined outside of
;; fitness.org.

(defun ap/org-call-src-block (name)
 ;; Based on <http://kitchingroup.cheme.cmu.edu/blog/2014/08/11/Using-org-mode-outside-of-Emacs-sort-of/>
 ;; This works better than the org-sbe (aka sbe) macro, because it
 ;; calls the block upon expansion, making it difficult to bind to
 ;; a command to run later
 ;; TODO: Use `org-babel-goto-named-src-block'! I guess it's new...or not, it's from 2010!
 (org-with-wide-buffer
  (-when-let (src (org-element-map (org-element-parse-buffer) 'src-block
           (lambda (element)
            (when (string= name (org-element-property :name element))
             element))
           nil ;info
           t ))
   (goto-char (org-element-property :begin src))
   (let ((org-confirm-babel-evaluate nil))
    (org-babel-execute-src-block)))))
#+end_src


* ask me whether to move region or copy region
interactive tool for moving or copying text regions to another window in the Emacs environment. It is functionally correct and appears to be well-structured. Here are a few notes on the provided code.

Global variable initialization: At the start of each Emacs session, a global variable move-or-copy-mode is declared and set to nil. This variable is used to store the user's preference for either moving or copying text regions.

Interactive Mode Selection: The switch-between-move-mode-and-copy-mode function allows the user to specify their preference in an interactive manner. If move-or-copy-mode is nil (which will be true at the start of each session), this function is called to populate move-or-copy-mode with the user's choice.

Move or Copy Implementation: The move-or-copy-region-to-other-window function uses the value stored in move-or-copy-mode to determine whether to move or copy the selected region. If the value is "move", the function kills (cuts) the region and displays a message indicating the number of words moved. If the value is "copy", the function copies the region and displays a message indicating the number of words copied.

Region Handling: The code uses use-region-p to check if a region is currently active (selected). If not, a message is displayed to inform the user that no region is selected.

Text Insertion: After the text region has been either moved or copied, it is yanked (pasted) into the other window. The code also adds a newline character both before and after the inserted text for neat formatting.

First:
Set this varable to nil at the start of every Emacs session, so that switch-between-move-mode-and-copy-mode will prompt me about my preference:

#+begin_src emacs-lisp
(defvar move-or-copy-mode nil)
#+end_src

The first time I call move-or-copy-region-to-other-window, the unless statement sees that move-or-copy-mode is nil, so it calls select-copy-mode-or-move-mode.

The next time I call move-or-copy-region-to-other-window within the same Emacs session, move-or-copy-mode is no longer nil, because it now contains my previous choice. So the unless statement doesn't trigger, and select-copy-mode-or-move-mode is not called, hence I'm not prompted for my preference again.

When a new Emacs session starts, move-or-copy-mode is reset to nil, so I will again be prompted for Ir preference the first time I call move-or-copy-region-to-other-window in the new session.

Emacs sessions are independent of each other, so global variables like move-or-copy-mode don't persist across sessions.


#+begin_src emacs-lisp
(defun select-move-mode-or-copy-mode ()
 (interactive)
 (setq move-or-copy-mode
    (completing-read "Would you like to move this region or just copy it? (move or copy): " '("Move" "Copy"))))

(defun move-or-copy-region-to-other-window (start end)
 "Move or copy selected text to other window based on move-or-copy-mode."
 (interactive "r")
 (unless move-or-copy-mode
  (select-move-mode-or-copy-mode))
 (let ((count (count-words-region start end)))
 (save-excursion
  (if (string= move-or-copy-mode "Move")
   (progn
   (kill-region start end)
   (message "Moved %s words" count))
  (progn
   (copy-region-as-kill start end)
   (message "Copied %s words" count)))
  (other-window 1)
  (newline)
  (yank)
  (newline)
  (other-window -1))))

#+end_src



* refile or org-roam-refile
#+begin_src emacs-lisp
(defvar refile-or-roam-refile-mode nil)

(defun select-refile-mode ()
 (interactive)
 (setq refile-or-roam-refile-mode
    (completing-read "Would you like to refile this region or subtree to Org file or Org-roam file? (org-refile or org-roam-refile): " '("org-refile" "org-roam-refile"))))

(defun choose-refile-method-and-refile ()
 "Choose the refile method and refile the current subtree or region based on refile-or-roam-refile-mode."
 (interactive)
 (unless refile-or-roam-refile-mode
  (select-refile-mode))
 (if (use-region-p)
   (save-excursion
    (if (string= refile-or-roam-refile-mode "org-refile")
      (progn
       (refile-region-or-subtree)
       (message "Refiled to Org file"))
     (progn
      (org-roam-refile-region-or-subtree)
      (message "Refiled to Org-roam file"))))
  (let ((current-heading (org-get-heading t t t t)))
   (save-excursion
    (if (string= refile-or-roam-refile-mode "org-refile")
      (progn
       (refile-region-or-subtree)
       (message "Refiled to Org file %s" current-heading))
     (progn
      (org-roam-refile-region-or-subtree)
      (message "Refiled to Org-roam file %s" current-heading)))))))

#+end_src
* disable Olivetti on split
#+begin_SRC emacs-lisp
(defun activate-olivetti-in-split ()
 (when (not (bound-and-true-p disable-olivetti-auto-toggle))
  (if (< (window-width) 80)
    (olivetti-mode -1)
   (olivetti-mode 1))))


(add-hook 'org-mode-hook (lambda ()
              (add-hook 'window-configuration-change-hook 'activate-olivetti-in-split nil t)))

#+END_SRC

* helpful
[[https://github.com/Wilfred/helpful][Wilfred/helpful: A better Emacs *help* buffer]]

replacing Emacs built-in documenation
#+BEGIN_EXAMPLE emacs-lisp
;; Note that the built-in `describe-function' includes both functions
;; and macros. `helpful-function' is functions only, so we provide
;; `helpful-callable' as a drop-in replacement.
(global-set-key (kbd "M-h f") #'helpful-callable)

(global-set-key (kbd "M-h v") #'helpful-variable)
;; (global-set-key (kbd "M-h k") #'helpful-key)
(global-set-key (kbd "M-h x") #'helpful-command)

;; Lookup the current symbol at point. C-c C-d is a common keybinding
;; for this in lisp modes.
(global-set-key (kbd "C-c C-d") #'helpful-at-point)

;; Look up *F*unctions (excludes macros).
;;
;; By default, C-h F is bound to `Info-goto-emacs-command-node'. Helpful
;; already links to the manual, if a function is referenced there.
(global-set-key (kbd "M-h F") #'helpful-function)
#+END_EXAMPLE


* workgroups
[[https://github.com/pashinin/workgroups2][pashinin/workgroups2: Workgroups2 - Emacs session manager]]

** Usage
Use ~M-x wg-create-workgroup~ to save save window&buffer layout as a
work group.

Use ~M-x wg-open-workgroup~ to open an existing work group.

Use ~M-x wg-kill-workgroup~ to delete an existing work group.

*** Enable minor mode ~workgroups-mode~ (OPTIONAL)
Put below line at the bottom of ~.emacs~,

#+begin_example
(workgroups-mode 1)
#+end_example


* scroll
#+begin_src emacs-lisp
;; (global-yascroll-bar-mode 1)
#+end_src

* CTRLF
[[https://github.com/radian-software/ctrlf#customization][radian-software/ctrlf: ⌨️ Emacs finally learns how to ctrl+F.]]

Disabling because [[https://github.com/radian-software/ctrlf/issues/130][there's no isearch-repeat-forward]]? Update: found it.


#+begin_SRC emacs-lisp
(use-package ctrlf
  :defer)
;; (ctrlf-mode +1)
;; (define-key key-minor-mode-map (kbd "s-f") 'ctrlf-forward-default)
(define-key ctrlf-mode-map (kbd "s-g") 'ctrlf-next-match)
;; (define-key ctrlf-mode-map (kbd "s-g") 'ctrlf-next-match)
#+END_SRC


* ace-link
[[https://github.com/abo-abo/ace-link][abo-abo/ace-link: Quickly follow links in Emacs]]
In Help buffers, single key ~o~ to follow links

** Usage
Just press ~o~ when you're
in ~Info-mode~ or ~help-mode~ or ~woman-mode~ or ~eww-mode~ or ~compilation-mode~.

Here's a screencast of browsing Info using ~ace-link-info~:


#+begin_src emacs-lisp
(ace-link-setup-default)
#+end_src

** mwim
[[https://github.com/alezost/mwim.el][alezost/mwim.el: Move to the beginning/end of line, code or comment]]

Smart jump to beginning / end of lines.

#+begin_src emacs-lisp
(global-set-key (kbd "C-a") 'mwim-beginning)
(global-set-key (kbd "C-e") 'mwim-end)
#+end_src


* delete file
#+begin_src emacs-lisp
(defun delete-visited-file (buffer-name)
 "Delete the file visited by the buffer named BUFFER-NAME."
 (interactive "Delete file visited by buffer ")
 (let* ((buffer (get-buffer buffer-name))
     (filename (buffer-file-name buffer)))
  (when buffer
   (when (and filename
         (file-exists-p filename))
    (delete-file filename))
   (kill-buffer buffer))))
(defalias 'crux-delete-buffer-and-file #'delete-visited-file)

#+end_src

* jinx
#+begin_EXAMPLE emacs-lisp
(use-package jinx
:defer)
(dolist (hook '(text-mode-hook org-mode-hook conf-mode-hook))
 (add-hook hook #'jinx-mode))
#+END_EXAMPLE


* ox-timeline
#+begin_src emacs-lisp
(use-package ox-timeline

:config
 (setq org-timeline-source-url "/Users/jay/Dropbox/github/incandescentman.github.io/timeline/dist"))

(defun org-timeline-export-to-html-and-open ()
 "Export the current Org file to HTML using `org-timeline-export-to-html', then open the HTML file."
 (interactive)
 (let ((html-file (org-timeline-export-to-html)))
  (when html-file
   (browse-url (concat "file://" (expand-file-name html-file))))))

#+end_src


* ox-clip
#+begin_src emacs-lisp
'(ox-clip-osx-cmd
  "pandoc -f html -t markdown - | grep -v \"^:::\" | sed 's/{#.*}//g' | pbcopy")
(defalias 'copy-as-markdown 'ox-clip-formatted-copy)
#+end_src


* debug recentf
#+begin_src emacs-lisp
(defadvice recentf-save-list (around debug-recentf-save-list activate)
 (message "Saving recentf list...")
 ad-do-it
 (message "Saved recentf list"))

(defun my-update-recentf ()
 (copy-file "/Users/jay/emacs/recentf/recentf" "/Users/jay/.emacs.d/.cache/recentf" t))

(defadvice configuration-layer/update-packages
  (before my-update-recentf-before-update-packages activate)
 (copy-file "/Users/jay/emacs/recentf/recentf" "/Users/jay/.emacs.d/.cache/recentf" t))


#+end_src


* unpair <
If all else fails, as a last resort, you could use a keybinding to insert a "<" without triggering the auto-pairing. For instance:

#+begin_example emacs-lisp
(global-set-key (kbd "<") (lambda () (interactive) (insert "<")))
#+end_example

This tells Emacs to simply insert a "<" whenever you press that key, bypassing any other logic that might be attached to it.

* global Olivetti mode
#+begin_src emacs-lisp
(define-globalized-minor-mode olivetti-global-mode olivetti-mode
 (lambda ()
  (unless (minibufferp)
   (olivetti-mode 1))))

(olivetti-global-mode)
#+end_src


* org-mode timestamp format
#+begin_src emacs-lisp
(setq org-time-stamp-custom-formats '("<%a %m/%e/%Y>" . "<%a %B %e %l:%M %p>"))
(setq-default org-display-custom-times nil)
#+end_src

* smartparens
#+begin_src emacs-lisp
;; Ensure the library is loaded before keybinding
(use-package smartparens
  :defer nil                       ; <--- load immediately
  :config
(smartparens-mode 1)
(smartparens-global-mode 1)

(setq sp-escape-quotes-after-insert nil)

)
#+end_src


* archive tasks based on date
#+begin_src emacs-lisp

;; (setq org-archive-location
;;  (concat "/Users/jay/Dropbox/roam/notes/archive/"
;;   (format-time-string "%Y-%m" (current-time)) "-%s::* "(format-time-string "%Y-%m-%d" (current-time))))

(defun my/org-archive-file ()
 "Dynamically set `org-archive-location' based on the current file directory."
 (let* ((current-file-dir (file-name-directory (buffer-file-name)))
     (archive-dir (concat current-file-dir "archive/"))
     (archive-file (concat archive-dir
                (format-time-string "%Y-%m" (current-time))
                "-%s::"
                (format-time-string "%Y-%m-%d" (current-time)))))
  (setq org-archive-location archive-file)))

;; Run the above function before every org-archive operation
(add-hook 'org-archive-hook 'my/org-archive-file)


#+end_src


* unfill-region-keep-formatting
#+begin_src emacs-lisp
(defun unfill-paragraph-keep-formatting (start end)
 "Unfill the region, but preserve plain-text lists and org-mode SCHEDULED tasks."
 (interactive "*r")
 (let ((fill-column (point-max)))
  (unfill-paragraph start end)))

(defun should-unfill-p (start end)
 "Determine whether the region should be unfilled."
 (save-excursion
  (goto-char start)
  (not (or (looking-at "^\\s-*\\([-*+]\\|[0-9]+[.)]\\)\\s-+") ;; plain-text list
       (looking-at "^\\s-*SCHEDULED:")           ;; org-mode SCHEDULED task
       (looking-at "^\\s-*DEADLINE:")            ;; org-mode DEADLINE
       ))))


(defun unfill-region-smart (start end)
 "Unfill the region, but preserve plain-text lists and org-mode SCHEDULED tasks."
 (interactive "*r")
 (let ((pos start))
  (while (< pos end)
   (let ((next-pos (or (next-single-property-change pos 'hard) end)))
    (when (should-unfill-p pos next-pos)
     (unfill-region-keep-formatting pos next-pos))
    (setq pos next-pos)))))



#+end_src

* string to list
#+begin_src emacs-lisp
(defun region-to-numbered-list (start end)
  "Turn a region into a numbered list."
  (interactive "r")
  (let* ((s (buffer-substring-no-properties start end))
         (split-strings (split-string s "\\([0-9]+\\. \\)" t))
         (trimmed-strings (mapcar 'string-trim split-strings))
         (filtered-strings (cl-remove-if (lambda (x) (string= x "")) trimmed-strings))
         (numbered-strings
          (cl-loop for str in filtered-strings and i from 1
                   collect (concatenate 'string (number-to-string i) ". " str))))
    (delete-region start end)
    (insert (mapconcat 'identity numbered-strings "\n"))))
#+end_src

* indirect buffers

** clone-indirect-buffer-new-window-without-focus
#+begin_src emacs-lisp
(defun clone-indirect-buffer-new-window-without-focus ()
  "Clone the current buffer to another window *but keep focus* in the original window."
  (interactive)
  (let ((original-window (selected-window)))
    ;; This built-in command automatically creates an indirect buffer
    ;; for the current buffer, displays it in another window,
    ;; and SELECTS that new window.
    (clone-indirect-buffer-other-window nil t)

    ;; If you want to narrow in Org mode:
    (when (derived-mode-p 'org-mode)
      (org-narrow-to-subtree))

    ;; Now go back to the original window:
    (select-window original-window)))
#+end_src

** clone-indirect-buffer-new-window-and-focus
#+begin_src emacs-lisp
(defun clone-indirect-buffer-new-window-and-focus ()
  "Clone the current buffer to another window and KEEP focus in the new window."
  (interactive)
  ;; This will automatically create and select the new indirect buffer in another window
  (clone-indirect-buffer-other-window nil t)

  ;; Narrow if you wish:
  (when (derived-mode-p 'org-mode)
    (org-narrow-to-subtree))
  ;; Because clone-indirect-buffer-other-window already selects the new buffer,
  ;; you don't need to do anything else to maintain focus there.
)
#+end_src



* org-inline-tags
#+BEGIN_EXAMPLE emacs-lisp
(defface org-inline-tags-face
 '((t (:foreground "orange" :weight bold)))
 "Face for custom inline tags in plain list items.")

(font-lock-add-keywords 'org-mode
 '(("#\\(\\w+\\(-\\w+\\)*\\)" 0 'org-inline-tags-face)))


;;;***autoload
(defun org-inline-tags-search (tag)
 "Search for TAG in the current org file."
 (org-search-view nil (concat "\\" "#" tag)))

;;;***autoload
(defun org-inline-tags-search-buffer (tag)
 "Search for TAG in the current buffer."
 (consult-line (concat "\\" "#" tag)))

;;;***autoload
(defun org-inline-tags-search-project-wide ()
 "Search for inline TAG project-wide using consult-ripgrep if available, otherwise use occur."
 (interactive)
 (if (fboundp 'consult-ripgrep)
   (progn
    (message "Enter tag to search for (Please go to the beginning of the line and add a \\ before the # sign)")
    (sit-for 0.5) ; pause for 0.5 to 2 seconds, whatever you waaant
    (consult-ripgrep nil))
  (occur (read-string "Enter tag to search for (Please go to the beginning of the line and add a \\ before the # sign): #"))))

(defun org-inline-tags-return (&optional indent)
 "Check if point is on an inline tag, and if so, search for that tag.
Otherwise, call `org-return'."
 (interactive)
 (let ((tag (with-syntax-table (let ((st (make-syntax-table)))
                 (modify-syntax-entry ?# "_" st)
                 st)
        (thing-at-point 'symbol))))
  (if (and tag (string-prefix-p "#" tag))
    (org-inline-tags-search-project-wide)
   (smart-return indent))))



;;;***autoload
(defun org-inline-tags-insert ()
 "Prompt the user to choose a tag and insert it at the current cursor position."
 (interactive)
 (let* ((tag-alist '((?r . "review")
           (?b . "book")
           (?t . "todo")
           (?u . "urgent")
           (?p . "tweet")
           (?i . "insight")
           (?c . "cook-ideas-over-time")))
     (selected-key (read-char "Choose a tag:\n
r: review
b: book
t: todo
u: urgent
p: tweet
i: insight
c: cook-ideas-over-time\n")))
  (setq selected-tag (cdr (assoc selected-key tag-alist)))
  (if selected-tag
    (insert (format " #%s" selected-tag))
   (error "Invalid tag selection"))))


;; for org-html-export
(defun my-org-add-class-to-hash-tags (text backend info)
  "Add class to words starting with a '#' in HTML export."
  (when (org-export-derived-backend-p backend 'html)
    (replace-regexp-in-string "\\<#\\w+\\>"
                              "<span class=\"hash-tag\">\\&</span>"
                              text)))

(add-to-list 'org-export-filter-plain-text-functions
    'my-org-add-class-to-hash-tags)




;; (define-key org-mode-map (kbd "<return>") 'org-inline-tags-return)

;; (define-key key-minor-mode-map (kbd "<return>") 'org-inline-tags-return)

;; (define-key key-minor-mode-map (kbd "s-:") 'insert-inline-tag)
;; (define-key key-minor-mode-map (kbd "s-;") 'search-for-inline-tag-project-wide)

#+END_EXAMPLE


** auto-link notes
Doesn't work.

Development:
https://chat.openai.com/share/255cbba9-238a-4b8c-ae8e-76a2aadf70fe

#+begin_src emacs-lisp
(defun org-roam-auto-link-buffer ()
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (while (not (eobp))
      (let* ((word (thing-at-point 'word 'no-properties))
             (node (car (org-roam-db-query [:select [id] :from nodes :where (= title $s1)] word))))
        (if node
            (progn
              (push-mark)
              (forward-word)
              (let ((region (list (mark) (point))))
                (org-roam-link-set-region (car region) (cadr region) node))))))))
#+end_src


* New org-roam
#+begin_src emacs-lisp
(defun kb/find-node-backlink (arg &optional node choices)
 "Navigate notes by link. With universal ARG try to use only to navigate the tags of the current note. Optionally takes a selected NODE and filepaths CHOICES."
 (interactive "P")
 (let* ((depth (if (numberp arg) arg 1))
     (choices
     (or choices
       (when arg
        (-map #'org-roam-backlink-target-node (org-roam-backlinks-get (org-roam-node-from-id (or (ignore-errors (org-roam-node-id node))
                                                     (org-id-get-create))))))))
     (all-notes (org-roam-node--completions))
     (completions
     (or (--filter (-contains-p choices (cdr it)) all-notes) all-notes))
     (next-node
     ;; taken from org-roam-node-read
     (let* ((nodes completions)
         (node (completing-read
            "Node: "
            (lambda (string pred action)
             (if (eq action 'metadata)
               '(metadata
                (annotation-function . (lambda (title)
                             (funcall org-roam-node-annotation-function
                                 (get-text-property 0 'node title))))
                (category . org-roam-node))
              (complete-with-action action nodes string pred))))))
      (or (cdr (assoc node nodes))
        (org-roam-node-create :title node)))
     )
     )
  (if (equal node next-node)
    (org-roam-node-visit node)
   (kb/find-node-backlink nil next-node (cons next-node (-map #'org-roam-backlink-source-node (org-roam-backlinks-get next-node))))
   )))
#+end_src

* fontify checkboxes on org export to HTML
[[https://emacs.stackexchange.com/questions/33382/replace-checkbox-with-glyph-via-font-lock][org mode - replace checkbox with glyph via font-lock - Emacs Stack Exchange]]
#+begin_src emacs-lisp
(setq org-html-checkbox-type 'unicode)
(setq org-html-checkbox-types
 '((unicode (on . "<span class=\"task-done\">&#x2611;</span>")
   (off . "<span class=\"task-todo\">&#x2610;</span>")
   (trans . "<span class=\"task-in-progress\">&#x25eb;</span>"))))
#+end_src



* Skim PDF: Capture page title correctly
In org-mode for Emacs, we often want to create links to specific resources. One such resource could be a PDF file that is being viewed in Skim.app, a popular PDF reader for macOS. The initial implementation of this functionality allowed for the creation of a link directly to a specific page in a PDF file. However, the link was not easily readable, as it only contained the file path and the page number.

We've updated this functionality to enhance the readability and usability of these links. Now, the link will also display the title of the file (which is generally more readable than a filepath). The link still points to the specific page in the PDF file, but when viewed in org-mode, it will be displayed with the title of the PDF file.

If I encounter more errors, pls refer to this:
https://chat.openai.com/share/84fdc7cc-f6d1-410b-85e8-efffb249ed36

#+begin_SRC emacs-lisp

(defun org-mac-link-skim-insert-page ()
  "Insert the link to the page in the Skim.app. Include the page number.

  This function calls the org-mac-link-skim-get-page function to get
  a formatted org-mode link to the current page in the Skim.app PDF file.
  The resulting link is then inserted at the current point."
  (interactive)
  (insert (org-mac-link-skim-get-page)))




(defun org-mac-link-applescript-get-skim-page-link ()
 "AppleScript to get the link to the page in the Skim.app."
 (do-applescript
 (concat
 "tell application \"Skim\"\n"
 "set theDoc to front document\n"
 "set theTitle to (name of theDoc) as string\n"
 "set thePath to (path of theDoc) as string\n"
 "set thePage to (get index of current page of theDoc) as string\n"
 "set theSelection to selection of theDoc\n"
 "set theContent to contents of (get text of theSelection) as string\n"
 "if theContent is missing value or theContent is \"\" then\n" ;; Check for missing value or empty string
 " set theContent to theTitle & \", p. \" & thePage\n"
 "end if\n"
 "if theTitle ends with \".pdf\" then\n" ;; Check for .pdf at the end of the title
 " set theTitle to text 1 thru -5 of theTitle\n" ;; Remove the last 4 characters (.pdf)
 "end if\n"
 "set theLink to thePath & \"::\" & thePage\n" ;; Removed extra space before ::split::

 "end tell\n"
 "return theLink & \" ::split::\" & theTitle & \", p. \" & thePage as string\n"))) ;; Separated link and content


(defun org-mac-link-skim-get-page ()
 "Get the link to the page in the Skim.app."
 (interactive)
 (message "Applescript: Getting Skim page link...")
 (let* ((result (org-mac-link-applescript-get-skim-page-link))
   (result-parts (split-string result "::split::"))
   (link (car result-parts))
   (description (cadr result-parts)))
 ;; Remove starting and ending quotes from the link
 (when (string-prefix-p "\"" link)
  (setq link (substring link 1)))
 (when (string-suffix-p "\"" link)
  (setq link (substring link 0 -1)))
 ;; Remove leading and trailing whitespace from the link
  (setq link (string-trim link))
 ;; Remove starting and ending quotes from the description
 (when (string-prefix-p "\"" description)
  (setq description (substring description 1)))
 (when (string-suffix-p "\"" description)
  (setq description (substring description 0 -1)))
;; Trim leading and trailing whitespace from the description
 (setq description (string-trim description))
 ;; Remove .pdf from the description
 (when (string-suffix-p ".pdf" description)
  (setq description (substring description 0 -4)))
 ;; Replace underscores with spaces in the description
(setq description (replace-regexp-in-string "_" " " description))

 ;; Format the link
 (format "[[%s][%s]]" link description))) ;; Org-mode link format

(defun org-mac-link-skim-get-document ()
 "Get the link to the document in the Skim.app, without page number."
 (interactive)
 (message "Applescript: Getting Skim document link...")
 (let* ((result (org-mac-link-applescript-get-skim-page-link))
     (result-parts (split-string result "::split::"))
     (link (car result-parts))
     (description (cadr result-parts)))
  ;; Remove starting and ending quotes from the link
  (when (string-prefix-p "\"" link)
   (setq link (substring link 1)))
  (when (string-suffix-p "\"" link)
   (setq link (substring link 0 -1)))
  ;; Remove leading and trailing whitespace from the link
  (setq link (string-trim link))
  ;; Remove starting and ending quotes from the description
  (when (string-prefix-p "\"" description)
   (setq description (substring description 1)))
  (when (string-suffix-p "\"" description)
   (setq description (substring description 0 -1)))
;; Trim leading and trailing whitespace from the description
 (setq description (string-trim description))
  ;; Remove .pdf from the description
  (when (string-suffix-p ".pdf" description)
   (setq description (substring description 0 -4)))
  ;; Replace underscores with spaces in the description
(setq description (replace-regexp-in-string "_" " " description))
  ;; Remove page number from the description
  (when (string-match ", p\\. \\([0-9]+\\)" description)
   (setq description (replace-match "" nil nil description)))
  ;; Format the link
  (format "[[%s][%s]]" link description)))

(defun org-mac-link-skim-insert-document ()
 "Insert the link to the document in the Skim.app, without page number."
 (interactive)
 (insert (org-mac-link-skim-get-document)))

;; Skim insert link to PDF (or with C-u prefix, insert link to PDF including page number)
(defun org-mac-link-skim-insert (&optional arg)
 "Insert a link to the current Skim document or page.
With a universal argument, insert a link to the current page including page number."
 (interactive "P")
 (if arg
   (org-mac-link-skim-insert-page)
  (org-mac-link-skim-insert-document)))

#+END_SRC


Fixed and working:
https://chat.openai.com/share/84fdc7cc-f6d1-410b-85e8-efffb249ed36

* org-timeblocking
#+begin_EXAMPLE emacs-lisp
(add-to-list 'load-path "/users/jay/emacs/external-packages/org-timeblock/")
(use-package org-timeblock
:defer)
#+END_EXAMPLE

* later list
#+begin_src emacs-lisp
(defun later-list ()
 (interactive)
 (find-file "/Users/jay/Dropbox/roam/notes/20230728235900-later_list.org"))
#+end_src

* red bold
#+begin_src emacs-lisp
(defun redbold ()
  (interactive)
  (custom-set-faces
'(bold ((t (:inherit font-lock-warning-face :foreground "red" :weight bold)))))
  )

(add-hook 'org-mode-hook (lambda ()
       (redbold)))

#+end_src


* Claire share
#+begin_src emacs-lisp
(defun claire-share-export-subtree-to-html ()
 (interactive)
 (let* ((title (file-name-sans-extension (buffer-name)))
     (path "/users/jay/dropbox/roam/claire/")
     (export-line (concat "#+EXPORT_FILE_NAME: " path title ".html")))
  (save-excursion
   (goto-char (point-min))
   (forward-line 3)
   (unless (looking-at "#\\+EXPORT_FILE_NAME:")
    (insert (concat export-line "\n"))))
  (org-export-dispatch)))

#+end_src


* embark vertico
#+begin_src emacs-lisp
(with-eval-after-load 'vertico
(define-key key-minor-mode-map (kbd "C-M-S-s-o") 'embark-act)
;; (define-key vertico-map (kbd "M-o") 'embark-act)
)

#+end_src

* copy-region-as-kill-and-push-to-clipboard

#+begin_src emacs-lisp
(defun copy-region-as-kill-and-push-to-clipboard (beg end)
  "Copy the region as kill and push it to the macOS clipboard.
BEG and END define the region to copy."
  (interactive "r")
  (copy-region-as-kill beg end)
  (push-kill-ring-pasteboard-to-MacOS-clipboard))
#+end_src


#+begin_src emacs-lisp
;; Simpler version - directly copies clipboard to kill ring
(defun clipboard-to-kill-ring ()
"Copies clipboard contents directly to kill ring."
(interactive)
(let ((clipboard-content (shell-command-to-string "pbpaste")))
(unless (string-equal clipboard-content "")
(kill-new clipboard-content))))

;; More complex version - strips trailing newline
(defun clipboard-to-kill-ring-and-strip-trailing-newlines ()
"Strips trailing newline from clipboard before copying to kill ring."
(interactive)
(let ((clipboard-content (shell-command-to-string "pbpaste")))
;; Check for non-empty clipboard contents
(when clipboard-content

  ;; Strip trailing newline if present
  (setq clipboard-content
        (if (string-match "\n\\'" clipboard-content)
            (replace-match "" t t clipboard-content)
          clipboard-content))

   ;; Copy to kill ring unless empty
   (unless (string-equal clipboard-content "")
     (kill-new clipboard-content)))))
#+end_src


* switch two classic keybindings
#+begin_src emacs-lisp
(define-key key-minor-mode-map (kbd "M-%") 'eval-expression)
(define-key key-minor-mode-map (kbd "M-:") 'query-replace)
#+end_src


* TOC in org file
[[https://github.com/alphapapa/org-make-toc][alphapapa/org-make-toc: Automatic tables of contents for Org-mode files]]

Usage:
A document may have any number of tables of contents (TOCs), each of
which may list entries in a highly configurable way.

To make a basic TOC, follow these steps:

1. Choose a heading to contain a TOC and move the point to it.
2. Run command ~org-make-toc-insert~, which inserts
   a ~:CONTENTS:~ drawer and sets TOC properties. Set
   the ~include~ property to ~all~.
3. Run the command ~org-make-toc~ to update all TOCs in the document.

Use command ~org-make-toc-set~ to change TOC properties for the entry at
point with completion.

#+begin_EXAMPLE emacs-lisp
(use-package org-make-toc
:defer
:config
 ;; Add 'org-make-toc-mode' to 'org-mode-hook'
 ;; This ensures 'org-make-toc-mode' is enabled every time 'org-mode' is activated
 (add-hook 'org-mode-hook #'org-make-toc-mode))
#+END_EXAMPLE


* display online images
** 1
Display online images in new buffer on return

#+begin_src emacs-lisp
(use-package url
  :defer)

#+end_src

** 2
[[https://emacs.stackexchange.com/questions/42281/org-mode-is-it-possible-to-display-online-images][Org mode: is it possible to display ONLINE images? - Emacs Stack Exchange]]

And again we have a use-case for image data not stored on harddisk. (The other two use-cases are [[https://emacs.stackexchange.com/questions/41544/is-it-possible-to-include-a-base64-image-in-org-file][base64 encoded images in org buffers]] and [[https://emacs.stackexchange.com/q/38098/2370][displaying previews of youtube videos]].)

Get [[https://github.com/TobiasZawada/org-yt][~org-yt~]] and paste the following elisp code into your [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Init-File.html][init-file]].

After evaluating your init-file you can use links analog to the example:

~[[imghttp://tn-home.de/Pic/tn-home.png]]~




#+BEGIN_EXAMPLE emacs-lisp
(autoload 'org-yt-follow "org-yt")


(defun org-image-link (protocol link _description)
 "Interpret LINK as base64-encoded image data."
 (cl-assert (string-match "\\`img" protocol) nil
       "Expected protocol type starting with img")
 (let ((buf (url-retrieve-synchronously (concat (substring protocol 3) ":" link))))
  (cl-assert buf nil
        "Download of image \"%s\" failed." link)
  (with-current-buffer buf
   (goto-char (point-min))
   (re-search-forward "\r?\n\r?\n")
   (buffer-substring-no-properties (point) (point-max)))))

(org-link-set-parameters
 "imghttp"
 :image-data-fun #'org-image-link)

(org-link-set-parameters
 "imghttps"
 :image-data-fun #'org-image-link)
#+END_EXAMPLE


* Insert image link from clipboard
#+begin_src emacs-lisp
(defun insert-image-link-from-clipboard ()
  "Inserts an org-mode image link using the clipboard content as the image URL."
  (interactive)
  (let* ((mac-clipboard-content (gui-selection-value))
         (clip-content (if mac-clipboard-content
                           (progn
                             (kill-new mac-clipboard-content)
                             mac-clipboard-content)
                         (substring-no-properties (current-kill 0)))))
    (if clip-content
        (if (string-match-p "^http" clip-content)
            (progn
              (insert (format "[[img%s]]" clip-content))
              (org-display-inline-images))
          (message "Clipboard content does not start with 'http'."))
      (message "Clipboard is empty."))))
#+end_src

* Insert local file link from clipboard
#+begin_SRC emacs-lisp
(defun insert-local-file-link-from-clipboard ()
  "Inserts an org-mode link using the clipboard content as the file path."
  (interactive)
  (clipboard-to-kill-ring)
  (let* ((clip-content (substring-no-properties (current-kill 0)))
         (file-name (file-name-nondirectory clip-content))
         (file-name-base (file-name-sans-extension file-name))
         (hyphen-and-underscore-replaced (replace-regexp-in-string "[-_]" " " file-name-base))
         (no-leading-numbers (replace-regexp-in-string "^[0-9]*" "" hyphen-and-underscore-replaced))
         (start-pos (point)))
    (insert (format "[[file+emacs:%s][📄 %s]]" clip-content (string-trim no-leading-numbers)))
    (goto-char start-pos)
    (search-forward "[[" nil t)
    (search-forward "[" nil t)
    (let ((title-start (point)))
      (search-forward "]" nil t)
      (backward-char)
      (capitalize-region title-start (point)))
    (goto-char (+ 2 start-pos))
    (search-forward "[" nil t)
    (search-forward "]" nil t))
  nil)  ; Explicitly return nil
#+END_SRC

* Insert directory link from clipboard
#+begin_SRC emacs-lisp
(defun insert-directory-link-from-clipboard ()
 "Inserts an org-mode directory link using the clipboard content as the directory path."
 (interactive)
 (clipboard-to-kill-ring)
 (let* ((clip-content (substring-no-properties (current-kill 0)))
     (dir-name (file-name-nondirectory (directory-file-name clip-content)))
     (hyphen-and-underscore-replaced (replace-regexp-in-string "[-_]" " " dir-name))
     (start-pos (point)))
  (insert (format "[[%s][📁 %s]]" clip-content (string-trim hyphen-and-underscore-replaced)))
  (goto-char start-pos)
  (search-forward "[[" nil t)
  (search-forward "[" nil t)
  (let ((title-start (point)))
   (search-forward "]" nil t)
   (backward-char)
   (capitalize-region title-start (point)))
  (goto-char (+ 2 start-pos))
  (search-forward "[" nil t)
  (search-forward "]" nil t))
 nil) ; Explicitly return nil
 #+END_SRC

* save frame size and position
#+begin_EXAMPLE emacs-lisp

(defun save-frame-size-and-position ()
 "Save the current frame's size and position."
 (interactive)
 (setq saved-frame-parameters
    (list (cons 'left (frame-parameter nil 'left))
       (cons 'top (frame-parameter nil 'top))
       (cons 'width (frame-parameter nil 'width))
       (cons 'height (frame-parameter nil 'height)))))

(defun restore-frame-size-and-position ()
 "Restore the frame's size and position."
 (interactive)
 (when saved-frame-parameters
  (modify-frame-parameters nil saved-frame-parameters)))

(defun restore-frame-to-external-minotaur-two-thirds-size-and-position ()
  "Restore the frame's size and position to specific values."
  (interactive)
  (let ((specific-frame-parameters '((left . 1280)
                                     (top . 25)
                                     (width . 182)
                                     (height . 68))))
    (modify-frame-parameters nil specific-frame-parameters)))

(defun restore-frame-to-laptop-two-thirds-size-and-position ()
  "Restore the frame's size and position to specific values."
  (interactive)
  (let ((specific-frame-parameters '((left . 685)
                                     (top . 44)
                                     (width . 113)
                                     (height . 47))))
    (modify-frame-parameters nil specific-frame-parameters)))


(define-key key-minor-mode-map (kbd "s-k f e") 'restore-frame-to-external-minotaur-two-thirds-size-and-position)
(define-key key-minor-mode-map (kbd "s-k f l") 'restore-frame-to-laptop-two-thirds-size-and-position)



(define-key key-minor-mode-map (kbd "s-k f e") 'restore-frame-to-external-minotaur-two-thirds-size-and-position)
(define-key key-minor-mode-map (kbd "s-k f l") 'restore-frame-to-laptop-two-thirds-size-and-position)


#+END_EXAMPLE



* indent level
#+begin_src emacs-lisp
(setq org-indent-indentation-per-level 2)
#+end_src

* right-click
[[https://oylenshpeegul.gitlab.io/blog/posts/20230129/][Context menus in Emacs 28! · oylenshpeegul]]

[[http://yummymelon.com/devnull/customizing-the-emacs-context-menu.html][nfdn: Customizing the Emacs Context Menu]]

#+begin_src emacs-lisp
(add-hook 'text-mode-hook 'context-menu-mode)
(add-hook 'shell-mode-hook 'context-menu-mode)
(add-hook 'dired-mode-hook 'context-menu-mode)
(add-hook 'org-mode-hook 'context-menu-mode)

; (add-hook 'context-menu-functions #'my-context-menu)

#+end_src



* garbage collection
[[/Users/jay/Dropbox/roam/emacs/20231030235900-garbage_collection_emacs.org][📄 Garbage Collection Emacs]]

[[https://github.com/doomemacs/doomemacs/issues/3108][org-mode slow but fixed with garbage collection delay on mac · Issue #3108 · doomemacs/doomemacs · GitHub]]
#+begin_src emacs-lisp
#+end_src


* remove filler words
Dev:
https://chat.openai.com/share/a0491b12-f038-4ba7-aa2a-e8a94073d4a8

Philosophy:
[[https://help.descript.com/hc/en-us/articles/10164806394509-Removing-filler-words#h_01H8Y6XQ6N0WYCXKSKZRRDT0QD][Removing filler words – Descript Help]]


"mmm"	"mmm"	"mmm"
"um"	"um"	"um"
"uh"	"uh"	"uh"
"hm"	"hm"	"hm"
 	 	"but you know"
 	 	"I guess"
 	 	"I mean"
 	 	"I suppose"
 	 	"kind of"
 	 	"like"
 	 	"or something"
 	 	"so"
 	 	"sort of"
 	 	"well"
 	 	"you know"
 	 	"you know what I mean"
 	 	"you see"

.............................................


#+BEGIN_EXAMPLE emacs-lisp
;; Configurable variable for filler word replacements.
(defvar my-filler-word-replacements
  ;; Each one is a full regex that accounts for punctuation/spaces:
  '(("\\bkind of like\\b[[:punct:]]*\\s-*" . "")
    ("\\byou know\\b[[:punct:]]*\\s-*"     . "")
    ("\\bI mean\\b[[:punct:]]*\\s-*"       . "")
    ;; ...
    ("\\bok\\b" . "OK")
    ("\\bOK\\b" . "OK")
    ("\\b\\(um\\|umm\\|uh\\)\\b" . "")
    (", right[.?!]\\b" . "."))
  "A list of filler regex -> replacement pairs.")

(defun remove-filler-words ()
  "Remove filler words from the text and report what was removed."
  (interactive)
  (let ((counts (make-hash-table :test 'equal))
        (report-string ""))
    (save-excursion
      (let ((case-fold-search t))  ; case-insensitive
        (dolist (filler my-filler-word-replacements)
          (goto-char (point-min))
          (let ((count 0))
            (while (re-search-forward (car filler) nil t)
              (setq count (1+ count))
              (replace-match (cdr filler)))
            (when (> count 0)
              (puthash (car filler) count counts))))))

    (while (cleanup-doubled-punctuation))

    ;; Construct the report string
    (maphash
     (lambda (key value)
       (setq report-string
             (concat report-string
                     (format "Removed %d instances of %s.\n"
                             value key))))
     counts)
    (if (string= report-string "")
        (message "No filler words found.")
      (message report-string))))


(defun cleanup-doubled-punctuation ()
  "Clean up doubled punctuation. Returns t if a replacement was made."
  (let ((replaced nil))
    (dolist (pair '((",," . ",")
                    (".," . ".")
                    (" , " . ", ")
                    ("  " . " ")))
      (goto-char (point-min))
      (while (search-forward (car pair) nil t)
        (replace-match (cdr pair))
        (setq replaced t)))
    replaced))

(defconst duplicate-word-exclusions
  '("that" "go" "no" "yes" "very" "really" "so" "chop" "please" "now" "stop" "sorry" "never" "ever" "more" "ha" "wait" "he" "oh" "help" "hi" "hello" "wow" "yum" "yo" "run" "bravo" "aha" "long" "always" "tap" "knock" "hurry" "bye" "love" "hate" "like" "way" "big" "best" "pretty" "well" "totally" "yeah" "blah")
  "A list of words to exclude from duplicate removal.")

(defun remove-duplicated-words ()
  "Remove duplicated words, excluding certain grammatical duplicates.
Performs case-insensitive matching to catch all variations."
  (interactive)
  (let ((removed-words (make-hash-table :test 'equal))
        (report-string ""))
    (save-excursion
      (let ((case-fold-search t))  ; Enable case-insensitive matching
        (goto-char (point-min))
        (while (re-search-forward "\\b\\(\\w+\\)\\b\\s-+\\1\\b" nil t)
          (let ((matched-word (match-string 1)))
            (unless (member matched-word duplicate-word-exclusions)
              (puthash matched-word (1+ (gethash matched-word removed-words 0)) removed-words)
              (replace-match matched-word))))))
    ;; Construct and display the report
    (maphash (lambda (key value)
               (setq report-string (concat report-string (format "\"%s\" %d times, " key value))))
             removed-words)
    (if (string= report-string "")
        (message "No duplicated words removed.")
      (message (concat "Removed duplicated words: " (substring report-string 0 -2) ".")))))

(defalias 'remove-doubled-words 'remove-duplicated-words)

(defun whittle ()
  "Perform text cleanup by removing filler words and duplicated words.
Note: The duplicate word removal is invoked only once to avoid redundancy."
  (interactive)
  (remove-filler-words)
  (remove-duplicated-words))
#+END_EXAMPLE
* remove redundant bold tags from org headings
#+begin_src emacs-lisp
(defun redundant-delete-redundant-asterisks-in-org-headings ()
  "Remove redundant asterisks in Org-mode headings within the current buffer or selected region."
  (interactive)
  (let ((start (if (use-region-p) (region-beginning) (point-min)))
        (end (if (use-region-p) (region-end) (point-max))))
    (save-excursion
      (goto-char start)
      (while (re-search-forward "^\\(*+\\) \\(.*?\\)\\(*+\\)?\\s-*$" end t)
        (let ((stars (match-string 1))
              (heading (match-string 2)))
          (replace-match (concat stars " " (replace-regexp-in-string "\\*+" "" heading))))))))
#+end_src


* weeklies
#+begin_src emacs-lisp
(defun open-weeklies ()
  (interactive)
  (find-file "/Users/jay/Dropbox/roam/accountability/weeklies.txt")
  )
#+end_src



* split window left
#+begin_src emacs-lisp
(defun split-window-left (&optional size)
 "Like split-window-right, with selected window on the right."
 (interactive "P")
 (split-window-right size)
 (other-window 1))

#+end_src


* export to PDF and prepend cover page
#+begin_src emacs-lisp
(defun export-to-pdf-and-prepend-cover-page ()
 "Export the current Org document to PDF and prepend a cover page located in the same directory. Then open the resulting PDF."
 (interactive)
 (let* ((output-pdf (concat (file-name-sans-extension (buffer-file-name)) ".pdf"))
     (cover-page (concat (file-name-directory (buffer-file-name)) "cover-page.pdf"))
     (final-pdf (concat (file-name-sans-extension (buffer-file-name)) "_with-cover.pdf")))
  (org-latex-export-to-pdf)
  (shell-command (format "pdftk %s %s cat output %s"
              (shell-quote-argument cover-page)
              (shell-quote-argument output-pdf)
              (shell-quote-argument final-pdf)))
  (message "PDF exported and combined with cover page: %s" final-pdf)
  ;; Open the resulting PDF
  (cond
   ((string-equal system-type "darwin") ; macOS
   (shell-command (format "open %s" (shell-quote-argument final-pdf))))
   ((string-equal system-type "gnu/linux") ; Linux
   (shell-command (format "xdg-open %s" (shell-quote-argument final-pdf))))
   ((string-equal system-type "windows-nt") ; Windows
   (shell-command (format "start %s" (shell-quote-argument final-pdf)))))))

#+end_src


* org-mode security vulnerability
[[https://list.orgmode.org/87o7b3eczr.fsf@bzg.fr/T/#t][[ANN] Emergency bugfix release: Org mode 9.6.23]]

Only required if Emacs < 29.3.

#+begin_src emacs-lisp
;; (setq org-preview-latex-default-process 'verbatim)
#+end_src


* detect and open street addresses
#+begin_src emacs-lisp
(defun open-labeled-address-in-google-maps ()
  "Find and open a labeled address in Google Maps, displaying the address in the minibuffer."
  (interactive)
  (save-excursion
    (let (address start end)
      (if (re-search-backward "^\\s-*\\(?:address:\\|Address:\\)\\s-*" nil t)
          (progn
            ;; Move past the label
            (goto-char (match-end 0))
            ;; Skip empty lines after the label
            (while (looking-at-p "^\\s-*$")
              (forward-line 1))
            (setq start (point))
            ;; Search forward for a ZIP code line ending
            (if (re-search-forward "\\b[0-9]\\{5\\}\\b\\s-*$" nil t)
                (progn
                  (setq end (match-end 0))
                  (setq address (buffer-substring-no-properties start end))
                  (setq address (replace-regexp-in-string "[ \t\n]+" " " (string-trim address)))
                  (message "Opening address: %s" address)
                  (browse-url (concat "https://www.google.com/maps/search/?api=1&query="
                                      (url-hexify-string address))))
              (message "ZIP code not found after address label!")))
        (message "No address label found!")))))
#+end_src


* org-transclusion
** org-transclusion-config
#+begin_src emacs-lisp
(use-package org-transclusion
  :config
  (setq org-transclusion-exclude-elements '(property-drawer))
  (setq org-transclusion-include-first-section nil)
  '(org-transclusion-extensions
    '(org-transclusion-src-lines org-transclusion-font-lock org-transclusion-indent-mode))
(custom-set-faces
 '(org-transclusion-fringe ((t (:background "yellow" :foreground "yellow")))))

;; Ensure that load-path to org-transclusion is already added
;; If you installed it with the built-in package.el, this should be already done.
;; (add-to-list 'load-path "path/to/org-transclusion/")
(add-to-list 'org-transclusion-extensions 'org-transclusion-indent-mode)
(require 'org-transclusion-indent-mode)
)

;; Customize the appearance of transclusion fringes
(set-face-attribute
 'org-transclusion-fringe nil
 :foreground "yellow"
 :background "yellow")


(load "/Users/jay/emacs/external-packages/org-transclusion-power-pack/org-transclusion-power-pack.el")

#+end_src


* flycheck
#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :ensure t
  :init
  (global-flycheck-mode)  ; Enable Flycheck globally
  :config
  ;; Turn off Flycheck in Org mode:
  (add-hook 'org-mode-hook (lambda () (flycheck-mode -1))))
#+END_SRC


** flycheck-mode-line
#+begin_src emacs-lisp
(setq flycheck-mode-line nil)

#+end_src








* smartparens fix
#+begin_src emacs-lisp
;; smartparens configuration
(use-package smartparens-config
:defer t)
(smartparens-global-mode t)
(show-smartparens-global-mode t)

;; web-mode configuration
;;(require 'web-mode)
;;(add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))

;; (add-hook 'web-mode-hook
;;      (lambda ()
;;       (setq web-mode-enable-auto-pairing nil)
;;       (setq web-mode-enable-auto-closing nil)))

;; Disable smartparens in web-mode
(add-hook 'web-mode-hook 'turn-off-smartparens-mode)
#+end_src


* pasteboard-copy-large-file
#+begin_src emacs-lisp
(defun pasteboard-copy-large-file ()
 "Copy the current region to the pasteboard using a temporary file."
 (interactive)
 (let* ((txt (buffer-substring (region-beginning) (region-end)))
     (temp-file (make-temp-file "emacs-pasteboard")))
  (with-temp-file temp-file
   (insert txt))
  (shell-command-to-string (format "cat %s | pbcopy" (shell-quote-argument temp-file)))
  (delete-file temp-file)))

(global-set-key (kbd "C-c C-c") 'pasteboard-copy)
#+end_src

* Make Emacs use MacOS Trash instead of rm
When deleting a file, don't use vc-delete-file
#+begin_src emacs-lisp
(defun crux-delete-file-and-buffer ()
 "Kill the current buffer and deletes the file it is visiting."
 (interactive)
 (let ((filename (buffer-file-name)))
  (when filename
   (when (y-or-n-p (format "Are you sure you want to delete %s? " filename))
    (let ((vc-backend (vc-backend filename)))
     (when vc-backend
      (vc-delete-file filename))
     (call-process "/opt/homebrew/Cellar/trash/0.9.2/bin/trash" nil nil nil filename)
     (message "Moved file %s to your MacOS Trash 🗑️" filename)
     (kill-buffer))))))
#+end_src

* query replace all files in current directory
#+begin_src emacs-lisp
(defun replace-in-all-files-in-current-directory (from-string to-string &optional regexp-flag)
  "Replace FROM-STRING with TO-STRING in every file under `default-directory'.

With a *prefix argument* (\\[universal-argument]) treat FROM-STRING as a
regular expression; otherwise perform a literal search/replace.

The command visits each regular file recursively, performs a
non-interactive query replace (i.e. no prompts while it works), saves
the buffer, and kills it when done."
  (interactive
   (let ((from (read-string "Replace: "))
         (to   (read-string "With: "))
         (regexp current-prefix-arg))      ;; C-u → regexp mode
     (list from to regexp)))

  (let* ((dir   default-directory)
         (files (directory-files-recursively dir ".*" nil)))
    (dolist (file files)
      (when (file-regular-p file)
        (find-file file)
        (save-excursion
          (goto-char (point-min))
          (if regexp-flag
              (progn (message "Regexp replacing in %s..." file)
                     (while (re-search-forward from-string nil t)
                       (replace-match to-string)))
            (message "Replacing in %s..." file)
            (while (search-forward from-string nil t)
              (replace-match to-string))))
        (save-buffer)
        (kill-buffer)))))

;; Optional convenient alias:

;; (define-key dired-mode-map (kbd "s-H") 'query-replace-all-files-in-current-directory)

;; (add-hook 'dired-mode-hook
;;           (lambda ()
;;             (define-key dired-mode-map (kbd "s-H") 'query-replace-all-files-in-current-directory)))
#+end_src


* fix buffers
#+begin_src emacs-lisp
(setq split-height-threshold nil)
(setq split-width-threshold 0)

(defun force-split-window-vertically (&optional window)
 "Force splitting windows vertically."
 (let ((window (or window (selected-window))))
  (or (and (window-splittable-p window t)
       (with-selected-window window
        (split-window-right)))
    (split-window-sensibly window))))

(setq split-window-preferred-function #'force-split-window-vertically)

(setq org-roam-buffer-display-properties '((side . right) (slot . 1) (window-width . 0.3)))

(purpose-mode -1)

(setq max-lisp-eval-depth 10000)



#+end_src


* paste and copy all
#+begin_src emacs-lisp
(defun expand-outreach-snippet ()
 "Expand the yasnippet with key 'outreach'."
 (interactive)
 (yas-expand-snippet (yas-lookup-snippet "outreach")))

(defun expand-outreach-snippet-paste-copy-all ()
 "Expand the 'outreach' snippet, paste clipboard text into the buffer using `pasteboard-paste-adaptive`, and then select the entire buffer and copy it."
 (interactive)
 ;; Expand the snippet
 (expand-outreach-snippet)
 ;; Wait a moment to ensure snippet expansion completes
 (run-at-time "0.1 sec" nil
        (lambda ()
         ;; Paste clipboard text into buffer
         (pasteboard-paste-adaptive)
         ;; Select the entire buffer
         (goto-char (point-min))
         (push-mark (point-max) nil t)
         (activate-mark)
         ;; Copy the entire buffer to clipboard
         (pasteboard-copy))))

(defun expand-outreach-snippet-paste-copy-all-and-submit-ChatGPT ()
 "Expand the 'outreach' snippet, paste clipboard text into the buffer using `pasteboard-paste-adaptive`, and then select the entire buffer and copy it."
 (interactive)
 ;; Expand the snippet
 (expand-outreach-snippet)
 ;; Wait a moment to ensure snippet expansion completes
 (run-at-time "0.1 sec" nil
        (lambda ()
         ;; Paste clipboard text into buffer
         (pasteboard-paste-adaptive)
         ;; Select the entire buffer
         (goto-char (point-min))
         (push-mark (point-max) nil t)
         (activate-mark)
         ;; Copy the entire buffer to clipboard
         (pasteboard-copy)
         ;; Execute AppleScript to paste into ChatGPT
         (do-applescript
         "tell application \"ChatGPT\" to activate
          tell application \"System Events\"
           keystroke \"n\" using command down
           delay 1
           keystroke \"v\" using command down
           delay 1
           keystroke return
          end tell"))))

(define-key key-minor-mode-map (kbd "s-k e m") 'expand-outreach-snippet-paste-copy-all-and-submit-ChatGPT)
#+end_SRC


* suppress warnings
#+begin_src emacs-lisp
(with-eval-after-load 'yasnippet
 (add-to-list 'warning-suppress-types '(yasnippet backquote-change)))

#+end_src

* replace add em dashes
#+begin_src emacs-lisp
(defun replace-dashes-with-em-dashes ()
  "Replace all occurrences of '---' or '--' with em dashes in the current buffer."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    ;; First, replace all occurrences of '---' with em dashes
    (while (search-forward "---" nil t)
      (replace-match "—" nil t))
    ;; Then, replace all occurrences of '--' with em dashes
    (goto-char (point-min))
    (while (search-forward "--" nil t)
      (replace-match "—" nil t))))
#+end_src



* use shell environment
** Set Path environment
I duplicated the below to /Users/jay/emacs/emacs-settings/spacemacs.d/init.el
and now it works. Don't understand why it was getting overwritten before, but whatever, it's working now.

#+begin_src emacs-lisp
;; Define a list of additional paths
(defvar my-additional-paths
  '("/usr/local/bin"
    "/opt/homebrew/bin"
    "/Applications/Firefox.app/Contents/MacOS"))

;; Update PATH environment variable
(setenv "PATH"
        (concat (getenv "PATH") ":"
                (mapconcat 'identity my-additional-paths ":")))

;; Update exec-path
(dolist (path my-additional-paths)
  (add-to-list 'exec-path path))



;; Rest of your configuration
(message "Final PATH: %s" (getenv "PATH"))
#+end_src


* Jay Call
#+begin_src emacs-lisp
(defun org-to-html-to-clipboard-hardcoded ()
  "Convert hardcoded org-mode text to HTML and copy it to the MacOS clipboard as HTML."
  (interactive)
  (let* ((org-content "Feel free to suggest some times that work for you or book time with me directly [[https://calendar.app.google/aSu61Nzz3PmxeYVaA][here]].")
         (html-content (org-export-string-as org-content 'html t))
         (temp-file (make-temp-file "clipboard-html-" nil ".html")))
    ;; Write the HTML content to a temporary file
    (with-temp-file temp-file
      (insert html-content))
    ;; Use AppleScript to read the file and set the clipboard
    (let ((script (format "set the clipboard to (read (POSIX file \"%s\")) as «class HTML»" temp-file)))
      (do-applescript script))
    ;; Delete the temporary file
    (delete-file temp-file)))
#+end_src


* timestamp export format
Remove the remove <> surrounding timestamps

#+BEGIN_SRC emacs-lisp
(add-to-list 'org-export-filter-timestamp-functions
       #'endless/filter-timestamp)
(defun endless/filter-timestamp (trans back _comm)
 "Remove <> around time-stamps."
 (pcase back
  ((or `jekyll `html)
   (replace-regexp-in-string "&[lg]t;" "" trans))
  (`latex
   (replace-regexp-in-string "[<>]" "" trans))))
#+END_SRC

we can still make it better. The YYYY-MM-DD weekday format isn't commonly used in prose, so let's switch that as well.

#+BEGIN_SRC emacs-lisp
(setq-default org-display-custom-times t)
;; Before you ask: No, removing the <> here doesn't work.
(setq org-time-stamp-custom-formats '("%B %d, %Y" . "%d/%m/%Y %a %H:%M"))
#+END_SRC

Source: [[http://endlessparentheses.com/better-time-stamps-in-org-export.html][Better time-stamps in org-export with Emacs - Endless Parentheses]]

Hmm maybe look at this too: [[http://stackoverflow.com/questions/23297422/org-mode-timestamp-format-when-exported][datetime - Org mode timestamp format when exported - Stack Overflow]]




* org element parser error
#+begin_src emacs-lisp
(setq debug-on-message "org-element--cache: Added org-data parent to non-headline element")

(with-eval-after-load 'smartparens
  (sp-local-pair 'org-mode "'" nil :actions nil)  ;; example: disable quote pairing
  (remove-hook 'org-mode-hook #'show-smartparens-mode))


; or more drastically:
; (remove-hook 'post-command-hook 'sp-show--pair-function)
#+end_src


* top level heading
What This Does:
This makes level 1 Org headings (**) export as <h1> instead of <h2>.
The document title (from #+TITLE: or the filename) remains in the <title> tag but is not included as an additional <h1>.

#+begin_src emacs-lisp
(setq org-html-toplevel-hlevel 1)
#+end_src

* org config files mode
#+begin_src emacs-lisp
(define-minor-mode my-org-config-mode
  "Minor mode for my custom Org file config."
  :init-value nil
  :lighter " myOrgCfg"
  (if my-org-config-mode
      (progn
        (define-key org-mode-map (kbd "<SPC>") #'insert-space)
        (make-local-variable 'abbrev-mode)
        (setq abbrev-mode nil)
        (setq-local org-config-files-local-mode t))
    ;; Optionally, unset org-config-files-local-mode when disabling:
    (kill-local-variable 'org-config-files-local-mode)))

(provide 'my-org-config-mode)
#+end_src

* Local Variables & The End
#+BEGIN_SRC emacs-lisp
(setq debug-on-message
      "org-element--cache: Added org-data parent to non-headline element")

;; put in dotspacemacs/user-init
(setq org-element-cache-persistent nil)   ; rebuild cache on each startup
#+END_SRC



* Org element errors

#+begin_src emacs-lisp
;; (remove-hook 'before-save-hook #'org-roam-link-replace-all)
#+end_src


* isearch-forward-word-at-point
#+begin_src emacs-lisp
(defun isearch-forward-word-at-point ()
  "Search forward for the next occurrence of the word at point.
If invoked again, move to the next instance of the word."
  (interactive)
  (let ((word (thing-at-point 'word t)))  ;; Get word at point, non-nil for empty words
    (if (not word)
        (message "No word at point")
      (if (eq last-command this-command)
          (isearch-repeat-forward)  ;; Continue searching if repeated
        (progn
          (isearch-forward nil 1)
          (isearch-yank-string word))))))
#+end_src

* Diary
#+BEGIN_SRC emacs-lisp
(setq diary-file "/Users/jay/Dropbox/github/timeless/jay-diary.md"
      calendar-mark-diary-entries-flag t
      calendar-view-diary-initially-flag t
      diary-display-function 'diary-fancy-display
      diary-comment-start "#"
      diary-comment-end "")

;; Monday is the first day of the week (since the weekend, obviously, is a unit)
(setq calendar-week-start-day 1)

(setq calendar-month-header
      '(propertize
        (format "%s %d"
                (calendar-month-name month)
                year)
        'font-lock-face 'calendar-month-header))


(defun my-calendar-jump-to-diary-entry ()
  "Open the diary file at the date under the cursor in the Calendar."
  (interactive)
  (let* ((calendar-window (selected-window))
         (date (calendar-cursor-to-date))  ;; gets the date at point in the Calendar
         (month (number-to-string (nth 0 date)))
         (day   (number-to-string (nth 1 date)))
         (year  (number-to-string (nth 2 date)))
         (date-str (format "%s/%s/%s" month day year)))
    (find-file-other-window diary-file)
    (goto-char (point-min))
    (if (search-forward date-str nil t)
        (beginning-of-line)
      (message "🟡 Could not find entry for %s" date-str))
    (select-window calendar-window)))

(with-eval-after-load 'calendar
  ;; Make "RET" show diary entries
  (define-key calendar-mode-map (kbd "RET") #'diary-view-entries)

  ;; Make "o" jump to the date under cursor
  (define-key calendar-mode-map (kbd "o") #'my-calendar-jump-to-diary-entry)

  ;; Make "t" jump to today, then jump to diary entry
  (define-key calendar-mode-map (kbd "t")
    (lambda ()
      (interactive)
      (calendar-goto-today)
      (my-calendar-jump-to-diary-entry))))
#+END_SRC


* Markdown customizations
#+begin_src emacs-lisp


;;; Markdown and Calendar Setup

;; --------------------------------------------------------------------
;; 1) markdown-mode + bullet behavior
;; --------------------------------------------------------------------
(use-package markdown-mode
  :ensure t
  :mode ("\\.md\\'" . markdown-mode)
  :config
  ;; Indentation for lists
  (setq markdown-list-indent-width 2)
  (define-key markdown-mode-map (kbd "RET") #'my-markdown-newline-with-bullet)
  (define-key markdown-mode-map (kbd "<tab>") #'my-markdown-cycle))


(defvar my-markdown--last-command-removed-bullet nil
  "Non-nil if the last call to `my-markdown-newline-with-bullet'
removed an empty bullet line.")

(defun my-markdown-newline-with-bullet ()
  "Insert or remove Markdown bullets intelligently.
- If line is an empty bullet (`  - `), remove it completely and leave one blank line.
- If line is a bullet plus text, insert another bullet on the next line.
- If the previous command removed a bullet and we're now on a blank line,
  do nothing extra (second Enter press).
- Otherwise, call `markdown-enter-key'."
  (interactive)
  (cond
   ;; -----------------------------
   ;; (1) Empty bullet line: remove entirely
   ;; -----------------------------
   ((save-excursion
      (beginning-of-line)
      (looking-at "^  -\\s*$"))
    ;; Remove the line including its trailing newline
    (delete-region (line-beginning-position)
                   (progn (forward-line 1) (point)))
    ;; If the next line is not empty, insert a blank line
    (unless (or (eobp) (looking-at "^\\s-*$"))
      (newline))
    (setq my-markdown--last-command-removed-bullet t))

   ;; -----------------------------
   ;; (2) Bullet plus text: continue the list
   ;; -----------------------------
   ((save-excursion
      (beginning-of-line)
      (looking-at "^  - +[^[:space:]]"))
    (end-of-line)
    (newline)
    (insert "  - ")
    (setq my-markdown--last-command-removed-bullet nil))

   ;; -----------------------------
   ;; (3) Second Enter press on the newly blank line: do nothing
   ;; -----------------------------
   ((and (or (bobp) (save-excursion
                      (beginning-of-line)
                      (looking-at "^\\s-*$")))
         my-markdown--last-command-removed-bullet)
    (setq my-markdown--last-command-removed-bullet nil)
    (message "Escaped bullet list."))

   ;; -----------------------------
   ;; (4) Fallback
   ;; -----------------------------
   (t
    (setq my-markdown--last-command-removed-bullet nil)
    (markdown-enter-key))))

  ;; Wrap lines visually (no hard breaks)
  (add-hook 'markdown-mode-hook #'visual-line-mode)

  ;; Outline settings: treat #, ##, ### as headings
  (setq outline-regexp "^\$begin:math:text$#+\\$end:math:text$ "
        outline-level
        (lambda ()
          (save-excursion
            (looking-at "^\$begin:math:text$#+\\$end:math:text$")
            (length (match-string 1)))))
  (add-hook 'markdown-mode-hook #'outline-minor-mode)


  ;; Highlight dates like "3/30/2025" in a special face
  (defface markdown-date-face
    '((t (:inherit font-lock-keyword-face :height 1.1 :weight bold)))
    "Face for date entries in markdown calendar.")
  (font-lock-add-keywords
   'markdown-mode
   '(("^[0-9]+/[0-9]+/[0-9]+" . 'markdown-date-face)))


;; --------------------------------------------------------------------
;; 3) (Optional) Visual Indentation with Overlays
;; --------------------------------------------------------------------
(defun my-markdown-current-level ()
  "Return the heading level of the nearest markdown heading above this line.
If none found, returns 1."
  (save-excursion
    (let ((level 1))
      (while (and (not (bobp)) (>= (point) (point-min)))
        (when (looking-at "^\$begin:math:text$#+\\$end:math:text$ ")
          (setq level (length (match-string 1)))
          (goto-char (point-min)))  ;; Stop after finding one
        (forward-line -1))
      level)))

(defun my-markdown-visual-indent ()
  "Visually indent lines under Markdown headings using overlays.
Indents each line by 2*(heading-level-1) spaces if inside a heading."
  (interactive)
  (let ((inhibit-read-only t))
    (remove-overlays (point-min) (point-max) 'my-markdown-indent t)
    (save-excursion
      (goto-char (point-min))
      (while (not (eobp))
        (let ((level (my-markdown-current-level)))
          (when (> level 1)
            (let* ((spaces (make-string (* 2 (1- level)) ?\s))
                   (ov (make-overlay (point) (point))))
              (overlay-put ov 'my-markdown-indent t)
              (overlay-put ov 'display spaces)))
          (forward-line 1))))))

(defun my-markdown-visual-indent-refresh (_beg _end _len)
  (when (eq major-mode 'markdown-mode)
    (my-markdown-visual-indent)))

(add-hook 'markdown-mode-hook #'my-markdown-visual-indent)
(add-hook 'after-change-functions #'my-markdown-visual-indent-refresh)

;; --------------------------------------------------------------------
;; 4) Optional: Custom <tab> folding
;; --------------------------------------------------------------------
(defun my-markdown-cycle ()
  "Toggle visibility of current heading's children in markdown."
  (interactive)
  (if (outline-on-heading-p)
      (outline-toggle-children)
    (outline-back-to-heading)))
#+end_src


* Ricing
[[https://lucidmanager.org/productivity/ricing-org-mode/][Ricing Org Mode: A Beautiful Writing Environment]]

#+BEGIN_EXAMPLE emacs-lisp
(load "/Users/jaydixit/emacs/emacs-settings/org-visual-style.el")
#+END_EXAMPLE


* Emacs info
#+begin_src emacs-lisp
(setq Info-directory-list '("/opt/homebrew/share/info"))
(setq Info-default-directory-list '("/opt/homebrew/share/info"))
(defun my/open-latest-emacs-manual ()
  (interactive)
  (info "/Users/jaydixit/Downloads/emacs/doc/emacs/emacs.info"))

(define-key key-minor-mode-map (kbd "M-h i") 'my/open-latest-emacs-manual)


;; Override the default Emacs manual path in Info
(with-eval-after-load 'info
  (let ((my-emacs-manual "/Users/jaydixit/Downloads/emacs/doc/emacs/emacs.info"))
    ;; Remove any existing "emacs" entry that might be outdated
    (setq Info-directory-list
          (delete "/opt/homebrew/share/info" Info-directory-list))
    ;; Add the directory containing your custom manual
    (add-to-list 'Info-directory-list
                 (file-name-directory my-emacs-manual))
    ;; Override the Emacs manual menu entry
    (defun info-emacs-manual ()
      "Go to the Emacs manual."
      (interactive)
      (info my-emacs-manual))))
#+end_src

* A hacky way to not clobber final bullet of buffer in bulleted lists on save
#+begin_src emacs-lisp

(defun cleanup-buffer-safe ()
 "Perform a bunch of safe operations on the whitespace content of a buffer.
Does not indent buffer, because it is used for a before-save-hook, and that
might be bad."
 (interactive)
 (untabify-buffer)
 ;; Replace the standard delete-trailing-whitespace with our custom version
 (my-delete-trailing-whitespace-except-final-and-point-line)
 (set-buffer-file-coding-system 'utf-8))

(defun cleanup-buffer ()
  "Perform a bunch of operations on the whitespace content of a buffer.
Including indent-buffer, which should not be called automatically on save."
  (interactive)
  (cleanup-buffer-safe)
  (indent-region (point-min) (point-max)))

(global-set-key (kbd "C-c n") 'cleanup-buffer)

;; Also update the before-save-hook if you have it
(defun my-before-save-hook ()
  (unless (eq major-mode 'markdown-mode) ;; Optional: exclude certain modes
    (my-delete-trailing-whitespace-except-final-and-point-line)))

(defun my-delete-trailing-whitespace-except-final-and-point-line ()
  "Delete trailing whitespace but preserve:
1) A single space at the very end of the buffer (if it was there),
2) A single trailing space on the line where `point' is, if it existed."
  (interactive)
  (save-excursion
    (let* ((orig-point (point))
           (keep-final-space
            ;; Was there exactly one space at the end of the buffer?
            (save-excursion
              (goto-char (point-max))
              (and (eq (char-before) ?\s)
                   (or (bobp) (not (eq (char-before (1- (point))) ?\s))))))

           (keep-point-line-space
            ;; If point is at a line that ends with exactly one space,
            ;; remember to restore it. (Doesn't matter if point is physically at the end,
            ;; as long as the line itself ended with one space.)
            (save-excursion
              (end-of-line)
              (and (> (point) (line-beginning-position))
                   (eq (char-before) ?\s)
                   (or (bolp) (not (eq (char-before (1- (point))) ?\s))))
              )))

      ;; Remove all trailing whitespace in the buffer
      (delete-trailing-whitespace)

      ;; Restore final space if it was there
      (when keep-final-space
        (goto-char (point-max))
        (unless (eq (char-before) ?\s)
          (insert " ")))

      ;; Restore a single space at the end of the line where point is
      ;; if it previously ended with exactly one space.
      (when keep-point-line-space
        (goto-char orig-point)
        (end-of-line)
        (unless (eq (char-before) ?\s)
          (insert " "))))))

(add-hook 'before-save-hook 'my-before-save-hook)
#+end_src


* Date and time

** Better time-stamps in org-export
#+begin_EXAMPLE emacs-lisp
(add-to-list 'org-export-filter-timestamp-functions
             #'endless/filter-timestamp)
(defun endless/filter-timestamp (trans back _comm)
  "Remove <> around time-stamps."
  (pcase back
    ((or `jekyll `html)
     (replace-regexp-in-string "&[lg]t;" "" trans))
    (`latex
     (replace-regexp-in-string "[<>]" "" trans))))

(setq-default org-display-custom-times t)
;;; Before you ask: No, removing the <> here doesn't work.
(setq org-time-stamp-custom-formats
   '("<%A %b %e, %Y>" . "<%d/%m/%y %a %H:%M>"))

#+END_EXAMPLE


** Org-mode Timestamp Format Helper
 - Defines global custom timestamp formats for Org-mode files.
 - Provides an interactive command to insert timestamp format customizations locally.
 - Offers two timestamp styles: a concise format and a detailed format.
 - Inserts file-local variables at buffer end, enabling custom date display per file.

#+begin_src emacs-lisp
(defun jay/org-export-date-format-chooser ()
  "Interactively choose an Org-mode date format, set it globally, copy file-local definition to clipboard, and optionally insert as file-local variable."
  (interactive)
  (let* ((formats '("U.S. short: 12/25"
                    "U.S. numeric: 12/25/2025"
                    "ISO standard: 2025-12-25"
                    "Short: Dec 25, 2025"
                    "Medium: Mon Dec 25, 2025"
                    "Full: Monday Dec 25, 2025"
                    "Long: Monday December 25, 2025"))
         (choice (completing-read "Choose date format: " formats nil t))
         (format-string (pcase choice
                          ("U.S. short: 12/25" "%m/%d")
                          ("U.S. numeric: 12/25/2025" "%m/%d/%Y")
                          ("ISO standard: 2025-12-25" "%Y-%m-%d")
                          ("Short: Dec 25, 2025" "%b %d, %Y")
                          ("Medium: Mon Dec 25, 2025" "%a %b %d, %Y")
                          ("Full: Monday Dec 25, 2025" "%A %b %d, %Y")
                          ("Long: Monday December 25, 2025" "%A %B %d, %Y")))
         (file-local (format "# %s Variables:\n# org-export-date-timestamp-format: \"%s\"\n# %s:\n"
                             "Local" format-string "End")))

    ;; Set global variable
    (setq org-export-date-timestamp-format format-string)
    (message "Global Org export date format set to '%s'" format-string)

    ;; Copy file-local definition to clipboard
    (call-process-shell-command (format "echo -n '%s' | pbcopy" file-local))
    (message "File-local variable copied to clipboard.")

    ;; Prompt to insert into buffer
    (when (string= (completing-read "Insert file-local variable into buffer? " '("no" "yes") nil t nil nil "no") "yes")
      (save-excursion
        (goto-char (point-max))
        (insert (concat "\n" file-local)))
      (message "Inserted file-local variable for date format '%s'" format-string))))
#+end_src


** date/time format chooser
|--------------+--------------------------+--------------|
| Name         | Example                  | Format       |
|--------------+--------------------------+--------------|
| U.S. short   | 12/25                    | %m/%d        |
| U.S. numeric | 12/25/2025               | %m/%d/%Y     |
| ISO standard | 2025-12-25               | %Y-%m-%d     |
| Short        | Dec 25, 2025             | %b %d, %Y    |
| Medium       | Mon Dec 25, 2025         | %a %b %d, %Y |
| Full         | Monday Dec 25, 2025      | %A %b %d, %Y |
| Long         | Monday December 25, 2025 | %A %B %d, %Y |
|--------------+--------------------------+--------------|


#+begin_src emacs-lisp
;; Stop org-expiry from stamping a CREATED property on new headings
(setq org-expiry-insert-created nil)
(remove-hook 'org-insert-heading-hook #'org-expiry-insert-created)

(defconst jay/org-date-formats
  '(("U.S. short: 12/25"              . "%m/%d")
    ("U.S. numeric: 12/25/2025"       . "%m/%d/%Y")
    ("ISO standard: 2025-12-25"       . "%Y-%m-%d")
    ("Short: Dec 25, 2025"            . "%b %d, %Y")
    ("Medium: Mon Dec 25, 2025"       . "%a %b %d, %Y")
    ("Full: Monday Dec 25, 2025"      . "%A %b %d, %Y")
    ("Long: Monday December 25, 2025" . "%A %B %d, %Y"))
  "Menu labels (with examples) → `format-time-string' specs.")

(defun jay/org-date-format-chooser ()
  "Set Org date formats for export, overlays, or both—always showing
time as \"7:00pm\" when the timestamp includes a clock."
  (interactive)
  (let* ((target (completing-read
                  "Configure: " '("export" "overlays" "both") nil t nil nil "both"))
         (need-export  (member target '("export" "both")))
         (need-overlay (member target '("overlays" "both")))
         (exp-fmt (and need-export
                       (cdr (assoc (completing-read
                                    "Export format: "
                                    (mapcar #'car jay/org-date-formats) nil t)
                                   jay/org-date-formats))))
         (ov-fmt  (and need-overlay
                       (cdr (assoc (completing-read
                                    "Overlay format: "
                                    (mapcar #'car jay/org-date-formats) nil t)
                                   jay/org-date-formats))))
         (block "# Local Variables:\n"))
    ;; ── apply selections ───────────────────────────────────────────
    (when need-export
      (setq org-export-date-timestamp-format exp-fmt)
      (setq block (concat block
                          (format "# org-export-date-timestamp-format: \"%s\"\n"
                                  exp-fmt))))
    (when need-overlay
      (setq org-display-custom-times t)
      (let* ((date-only ov-fmt)
             (date-time (concat ov-fmt " %-I:%M%P"))) ; 7:00pm
        (setq org-time-stamp-custom-formats
              (cons (format "<%s>" date-only)
                    (format "<%s>" date-time)))
        (setq block (concat block
                            (format "# org-time-stamp-custom-formats: '(\"<%s>\" . \"<%s>\")\n"
                                    date-only date-time)))))
    (setq block (concat block "# End:\n"))
    ;; ── clipboard + optional insert ───────────────────────────────
    (kill-new block)
    (when (yes-or-no-p "Insert Local Variables block here? ")
      (save-excursion
        (goto-char (point-max))
        (insert "\n" block)))
    (message "Updated %s format%s. Block copied (M-y to yank)."
             target (if (string= target "both") "s" ""))))
#+end_src



* Open in Safari
For banks etc that require text message verification, since Safari integrates with Messages and Chrome doesn't.

Example link format:
- [[safari:https://www.equifax.com/personal/help/place-lift-remove-security-freeze/][Equifax]]
- [[safari:https://www.experian.com/blogs/ask-experian/how-to-add-a-security-freeze-to-your-credit-file/][Experian]]
- [[safari:https://www.transunion.com/credit-freeze/credit-freeze-faq#adding-freeze-0][TransUnion]]

To insert link from chrome in Safari link format:
c-u s-L



#+begin_src emacs-lisp
(org-link-set-parameters "safari"
                         :follow (lambda (url)
                                   (start-process "open-safari" nil "open" "-a" "Safari" url))
                         :export (lambda (url description backend)
                                   (format "<a href=\"%s\">%s</a>" url (or description url))))
#+end_src


* org-roam fail gracefully
#+BEGIN_EXAMPLE emacs-lisp
(condition-case err
    (progn
      (org-roam-setup)
      (org-roam-db-autosync-enable))
  (error
   (warn "Org-roam setup failed: %s" (error-message-string err))))


#+END_EXAMPLE



* Trust local variables

#+begin_src emacs-lisp

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Allow local variables to be set without prompting:
(setq enable-local-variables :all)

;; 1) Mark `enable-local-eval` as safe (boolean).
(put 'enable-local-eval 'safe-local-variable #'booleanp)

;; 2) Mark `org-config-files-local-mode` as safe (boolean).
(put 'org-config-files-local-mode 'safe-local-variable #'booleanp)

;; 3) Mark `lexical-binding` as safe (boolean).
(put 'lexical-binding 'safe-local-variable #'booleanp)

;; 4) Whitelist exact eval forms (Emacs compares them using `equal`).
(add-to-list 'safe-local-eval-forms '(org-config-files-local-mode 1))
(add-to-list 'safe-local-eval-forms '(org-config-files-local-mode t))
(add-to-list 'safe-local-eval-forms '(org-config-files-local-mode))
(add-to-list 'safe-local-eval-forms '(when (fboundp 'rainbow-mode) (rainbow-mode 1)))

;; 5) If you still want to mark other local variables as safe by value:
(dolist (var '((org-config-files-local-mode . t)
               (enable-local-eval . t)
               (lexical-binding . t)
               (org-export-allow-bind-keywords . t)
               (org-timestamp-custom-formats "%a %b %d:" . "<%d/%m/%Y %a %H:%M>")
               (org-timestamp-custom-formats "<%B %d" . "<%d/%m/%Y %a %H:%M>")))
  (add-to-list 'safe-local-variable-values var))

;; 6) Mark remote Org resources as safe (unrelated to eval, but good to keep).
(setq org-safe-remote-resources
      '("\\`https://fniessen\\.github\\.io/org-html-themes/org/theme-bigblow\\.setup\\'"))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#+end_src

* fix footnotes
#+begin_src emacs-lisp
(defun jay/fix-org-footnotes ()
  "Convert ‘([[fn:: URL][LABEL]])’ → ‘[fn:: [[URL][LABEL]]]’ in the
current Org buffer."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    ;; 1 = URL, 2 = label
    (let ((re "(\\[\\[fn::\\s-*\\([^]]+\\)\\]\\[\\([^]]+\\)\\]\\]\\))"))
      (while (re-search-forward re nil t)
        (replace-match "[fn:: [[\\1][\\2]]]" t nil)))))
#+end_src

* Trying to fix Roam startup errors
#+begin_src emacs-lisp
(setq debug-on-quit nil)
(add-to-list 'debug-ignored-errors 'minibuffer-quit)

(add-to-list 'debug-ignored-errors 'outline-before-first-heading)

#+end_src

* C-g to escape
#+begin_src emacs-lisp
;; Let C-g always abort in minibuffer, even under Evil
(with-eval-after-load 'evil
  (define-key minibuffer-local-map (kbd "C-g") #'keyboard-quit)
  (define-key evil-normal-state-map (kbd "C-g") #'keyboard-quit)) ; optional
#+end_src


* Org-roam debugging
#+BEGIN_EXAMPLE emacs-lisp
(let* ((dir "/Users/jay/Dropbox/roam-hold/book/")      ; folder to scan
       (log "/Users/jay/Downloads/org-roam-parse.log") ; progress file
       (timeout 8))                                    ; seconds per file
  ;; --- wipe or create the log file ---
  (when (file-exists-p log)
    (delete-file log))
  (write-region "" nil log nil 'silent)                ; touch empty file

  ;; --- scan each .org file ---
  (dolist (f (directory-files-recursively dir "\\.org$"))
    (write-region (format "START %s\n" f) nil log 'append 'silent)
    (with-temp-buffer
      (insert-file-contents f)
      (let ((status
             (condition-case err
                 (with-timeout (timeout 'timeout)
                   (org-element-parse-buffer)
                   'done)       ; parsed in time
               (error err))))   ; Lisp error
        (write-region
         (format "%s %s\n"
                 (if (eq status 'done) "DONE" "ERR")
                 (if (eq status 'done) f status))
         nil log 'append 'silent))))
  (write-region "SCAN-COMPLETE\n" nil log 'append 'silent)
  (message "Finished --- inspect %s" log))
#+END_EXAMPLE

#+begin_src emacs-lisp
(defun jay/debug-find-corrupted-file (&optional file)
  "Prompt for an Org file (default ~/Downloads) and try to parse it.

If `org-element-parse-buffer` signals an error, print the error.
Otherwise report success and, on confirmation, move the file to
~/Dropbox/roam/notes/ (directory must already exist)."
  (interactive
   (list
    (read-file-name
     "Org file to test: "
     "~/Downloads/"            ;; start here
     nil t                     ;; must exist, no default
     nil                       ;; no initial input
     (lambda (f) (string-match-p "\\.org\\'" f))))) ;; only .org files
  (let* ((debug-on-error nil)            ;; don't drop into debugger
         (result
          (with-temp-buffer
            (insert-file-contents file)
            (condition-case err
                (progn (org-element-parse-buffer) 'ok)
              (error err)))))
    (cond
     ;; ✅ parsed fine - maybe move it
     ((eq result 'ok)
      (message "✅  %s parsed with no errors" file)
      (when (yes-or-no-p "Move it to ~/Dropbox/roam/notes/? ")
        (let* ((dest-dir  "~/Dropbox/roam/notes/")
               (dest-file (expand-file-name (file-name-nondirectory file)
                                            dest-dir)))
          (rename-file file dest-file 1) ;; 1 = overwrite with confirmation
          (message "Moved to %s" dest-file))))
     ;; ❌ parse error - show the error object
     (t
      (message "❌  %s --- %S" file result)))))


(defun jay/debug-scan-org-tree (root)
  "Recursively scan ROOT for *.org files that choke `org-element-parse-buffer'.
Print a quick report in *Messages* and return a list of problematic files."
  (interactive "DDirectory to scan: ")
  (require 'org)                         ;; make sure Org is loaded
  (let ((bad nil)
        (total 0))
    (dolist (file (directory-files-recursively root "\\.org\\'"))
      (setq total (1+ total))
      (with-temp-buffer
        (insert-file-contents file nil nil nil 'replace)
        (condition-case err
            (org-element-parse-buffer)
          (error
           (push (cons file err) bad)))))
    (if bad
        (progn
          (message "❌  %d / %d Org files failed to parse:" (length bad) total)
          (dolist (p (reverse bad))
            (message "    %s  ---  %S" (car p) (cdr p))))
      (message "✅  All %d Org files parsed cleanly" total))
    bad))


(defun jay/debug-current-buffer ()
  "Parse the current Org buffer and echo success or first error."
  (interactive)
  (condition-case err
      (progn (org-element-parse-buffer) (message "✅ no parse errors"))
    (error (message "❌ %S" err))))

(defun jay/find-suspect-lines (&optional max-indent max-len)
  "Echo line numbers with very deep bullet indent or very long length.
Defaults: MAX-INDENT = 40 spaces, MAX-LEN = 800 chars."
  (interactive)
  (let* ((max-indent (or max-indent 40))
         (max-len   (or max-len   800))
         (re-bullet "^[ \t]*[-+*]\\|^[ \t]*[0-9]+[.)]"))
    (save-excursion
      (goto-char (point-min))
      (while (not (eobp))
        (let* ((bol (point))
               (eol (line-end-position))
               (len (- eol bol))
               (indent (progn
                         (skip-chars-forward " \t")
                         (current-column))))
          (when (or (and (looking-at re-bullet) (>= indent max-indent))
                    (> len max-len))
            (message "⚠️  line %d: indent %d, length %d"
                     (line-number-at-pos) indent len)))
        (forward-line 1)))))

#+end_src


That little when-let is not something you normally keep sitting in your init file---it's a throw-away helper you run once (or whenever you want to hunt down the next corrupt file).
Pick whichever workflow feels most natural:

Goal Where / how to run it Steps
One-off check right now M-: (eval-expression) - Hit M-: ↵  - Paste the two-line form - RET
Run from scratch *scratch* buffer - Open *scratch*  (C-x b *scratch*)- Paste the formPut point after it and C-j (or select the region and C-M-x)
Reusable command Add a wrapper to your config elisp (defun jay/scan-roam-and-open-first-bad () (interactive) (when-let ((bad (jay/debug-scan-org-tree "~/Dropbox/roam"))) (find-file (caar bad))))  Restart (or M-x eval-buffer) and invoke with M-x jay/scan-roam-and-open-first-bad.  Bind it to a key if you like.
Automatic run at startup after-init-hook (only if you really want that) elisp (add-hook 'after-init-hook (lambda () (when-let ((bad (jay/debug-scan-org-tree "~/Dropbox/roam"))) (find-file (caar bad)))))

Most people just evaluate it ad-hoc (first or second row).
If you turn it into a command (third row), you keep your init file tidy and gain an easy way to re-run the check whenever you suspect the parser is choking again.

Let me know if you'd like a key-binding or projectile-style transient menu for it!


It returns a list, so you can later jump to the first culprit:


#+begin_example emacs-lisp
(when-let ((bad (jay/debug-scan-org-tree "~/Dropbox/roam")))
  (find-file (caar bad)))   ;; opens the first offending file

#+end_example

* Amx
#+begin_src emacs-lisp

(use-package amx
  :ensure t
  :init
  ;; Tell AMX *before it loads* which back-ends to use.
  (setq amx-backend 'standard; no Ido/Vertico
        amx-history-length 99                     ; keep 99 commands
        amx-save-file     (locate-user-emacs-file "amx-items"))
  :config
  (amx-mode 1)     ; replace default M-x
  (savehist-mode 1))
(setq amx-save-file "/Users/jay/emacs/local-emacs-config/amx-items")
(setq package-quickstart-file
     "/Users/jay/emacs/local-emacs-config/package-quickstart.el")
#+end_src


* Fix minibuffer

#+begin_src emacs-lisp
;; (setq debug-on-quit nil)

(dolist (map '(minibuffer-local-map
               minibuffer-local-ns-map
               minibuffer-local-completion-map
               minibuffer-local-must-match-map
               minibuffer-local-isearch-map
;;  ivy-minibuffer-map
))      ; drop this line if not using Ivy
  (when (boundp map)
    (define-key (symbol-value map) (kbd "C-g") #'minibuffer-keyboard-quit)))
#+end_src

* Prevent org-roam parsing crashes
#+begin_src emacs-lisp
(setq org-element--cache-self-verify 'backtrace) ; default is nil


#+end_src

* Fix indent error
#+begin_src emacs-lisp
;; ────────────────────────────────────────────────────────────
;; Guard org-indent's idle timer against rare parser errors
;; ────────────────────────────────────────────────────────────
(with-eval-after-load 'org-indent
  (defun my/org-indent-safe-agent (orig-fn &rest args)
    "Run ORIG-FN but ignore the occasional parser error."
    (ignore-errors
      (apply orig-fn args)))

  (ignore-errors                    ; remove duplicate wrapper, if any
    (advice-remove 'org-indent-initialize-agent
                   #'my/org-indent-safe-agent))

  (advice-add 'org-indent-initialize-agent
              :around #'my/org-indent-safe-agent))

#+end_src

* Disable annoying cache warnings
#+begin_src emacs-lisp
(setq org-element-cache-diagnostic-output nil)
#+end_src

* Display emoji correctly
#+begin_src emacs-lisp
(run-with-timer 1 nil
  (lambda ()
    (when (display-graphic-p)
      (set-fontset-font t 'emoji (font-spec :family "Apple Color Emoji") nil 'prepend)
      (set-fontset-font t 'unicode (font-spec :family "Apple Color Emoji") nil 'prepend))))
#+end_src

* open faster
#+begin_src emacs-lisp
;; Speed up macOS open events
(setq ns-pop-up-frames nil)  ; Don't create new frames

#+end_src

* silence warnings
#+begin_src emacs-lisp
;; Native comp quality-of-life
(setq native-comp-async-report-warnings-errors 'silent  ; hide noisy byte-native diffs
      comp-deferred-compilation           t           ; JIT-compile packages in the background
      comp-deferred-compilation-black-list '("/mu4e.*\\.el$")) ; skip anything poky

(global-display-line-numbers-mode 1)


(setq native-comp-jit-compilation t
package-native-compile    t)
#+end_src

* Panic button
#+begin_src emacs-lisp

;;; --- Emergency exit --------------------------------------------------------
;; Panic button: C-c C-! to save and exit
(global-set-key (kbd "C-c C-!")
                (lambda () (interactive)
                  (save-some-buffers t)
                  (kill-emacs)))
#+end_src

* debug on error
#+begin_src emacs-lisp
(setq debug-on-error 1)
#+end_src

* quickstart
#+begin_src emacs-lisp
(defun jd/maintain-quickstart ()
  "Regenerate `package-quickstart.el' whenever package list changes."
  (let* ((qs-file package-quickstart-file)
         (stamp   (file-attribute-modification-time
                   (file-attributes qs-file))))
    ;; Refresh if file is missing or older than 24 h
    (when (or (not (file-exists-p qs-file))
              (> (float-time (time-subtract (current-time) stamp))
                 (* 24 60 60)))
      (message "⟳  Refreshing package-quickstart...")
      (package-quickstart-refresh))))

;; Run once per boot, after packages are loaded:
(add-hook 'after-init-hook #'jd/maintain-quickstart)


;; Auto-refresh quickstart after package operations
(advice-add 'package-install :after
            (lambda (&rest _) (package-quickstart-refresh)))
(advice-add 'package-delete :after
            (lambda (&rest _) (package-quickstart-refresh)))
#+end_src

* counsel
#+begin_src emacs-lisp
(use-package counsel :defer t)
#+end_src

* convert footnotes to org format
#+begin_src emacs-lisp
;;; footnotes--convert-markdown-footnotes-to-org.el --- convert reference footnotes → Org  -*- lexical-binding: t; -*-
;; Author: you
;; Usage: mark region or use whole buffer, then  M-x footnotes--convert-markdown-footnotes-to-org
(require 'subr-x)                            ; for `string-trim'
(defun footnotes--convert-markdown-footnotes-to-org (&optional beg end)
  "Convert reference-style Markdown footnotes to Org-mode footnotes.
Inline examples:
   ([anthropic.com][8], [anthropic.com][7])  →  [fn:8], [fn:7]
   ( [foo][1] )                              →  [fn:1]
Definition examples:
   [8]: https://example.com \"Title\"        →  [fn:8] [[https://example.com][Title]]
With an active region, operate only on that region; otherwise
process the whole buffer."
  (interactive (when (use-region-p)
                 (list (region-beginning) (region-end))))
  (save-excursion
    (save-restriction
      (when beg (narrow-to-region beg end))
      ;; ------------------------------------------------------------
      ;; 1. INLINE MARKERS   [text][N]  →  [fn:N]
      ;; ------------------------------------------------------------
      (goto-char (point-min))
      (while (re-search-forward
              (rx "[" (+? (not "]")) "]"
                  "[" (group (+ digit)) "]")
              nil t)
        (replace-match (format "[fn:%s]" (match-string 1)) t t))
      ;; ------------------------------------------------------------
      ;; 2. STRIP PARENTHESES AROUND FOOTNOTE REFERENCES
      ;;    ([fn:8])  →  [fn:8]
      ;;    ([fn:8], [fn:7])  →  [fn:8], [fn:7]
      ;; ------------------------------------------------------------
      (goto-char (point-min))
      (while (re-search-forward
              ;; Match parentheses containing one or more [fn:N] references
              (rx "("
                  (group (0+ space)
                         "[fn:" (+ digit) "]"
                         (0+ (seq (0+ space) "," (0+ space) "[fn:" (+ digit) "]"))
                         (0+ space))
                  ")")
              nil t)
        (replace-match (match-string 1) t t))
      ;; ------------------------------------------------------------
      ;; 3. FOOTNOTE DEFINITIONS   [N]: URL \"Title\"  →  Org form
      ;; ------------------------------------------------------------
      (goto-char (point-min))
      (while (re-search-forward
              (rx line-start
                  "[" (group (+ digit)) "]:"
                  (+ blank)
                  (group (+ (not (any blank))))          ; URL
                  (? (+ blank) "\"" (group (+? (not "\""))) "\""))
              nil t)
        (let* ((num   (match-string 1))
               (url   (match-string 2))
               (title (string-trim (or (match-string 3) url))))
          (replace-match
           (format "[fn:%s] [[%s][%s]]" num url title) t t))))
    (message "Markdown reference footnotes → Org footnotes complete.")))
(provide 'footnotes--convert-markdown-footnotes-to-org)
;;; footnotes--convert-markdown-footnotes-to-org.el ends here
#+end_src

* line breaks
#+begin_src emacs-lisp
(defun asterisk-to-dash ()
  "Replace every newline-star sequence with newline-dash in the
current buffer.  Safe (save-excursion) and repeatable."
  (interactive)
  (save-excursion
;; (goto-char (point-min))
    (while (search-forward "\n* " nil t)
      (replace-match "\n- "))))



(defun asterisk-to-dash-and-convert-code-blocks-to-org ()
  "From point to end of buffer:
   • Change '\\n* ' to '\\n- '.
   • Change a line starting with two spaces + '* ' to two spaces + '- '.
   Then run `convert-markdown-to-org-code-blocks-simple` if it exists."
  (interactive)
  ;; 1. newline *  → newline -
  (save-excursion
    (while (search-forward "\n* " nil t)
      (replace-match "\n- ")))
  ;; 2. line-start two-spaces *  → two-spaces -
  (save-excursion
    (while (re-search-forward "^  \\* " nil t)
      (replace-match "  - ")))
  ;; 3. optional post-processing
  (when (fboundp 'convert-markdown-to-org-code-blocks-simple)
    (convert-markdown-to-org-code-blocks-simple)))


(defun normalize-dashes ()
  "1) Turn “foo---bar” into “foo --- bar”.
2) Turn a single space-hyphen-space (“ - ”) into spaced em-dash style (“ --- ”)."
  (interactive)
  (save-excursion
    ;; Pass 1 – add spaces around existing triple hyphens
    (goto-char (point-min))
    (while (re-search-forward "\\([[:alnum:]]\\)---\\([[:alnum:]]\\)" nil t)
      (replace-match "\\1 --- \\2" nil nil))

    ;; Pass 2 – promote space-hyphen-space to spaced triple hyphen
    (goto-char (point-min))
    (while (re-search-forward " - " nil t)
(replace-match " --- " nil nil))))


(defun normalize-dashes ()
  "• Add spaces around a naked em-dash marker (---).
• Promote a space-hyphen-space ( - ) to a spaced em-dash ( --- )."
  (interactive)
  (save-excursion
    ;; Pass 1 – space out triple-hyphens between *any* non-whitespace chars
    (goto-char (point-min))
    (while (re-search-forward "\\(\\S-\\)---\\(\\S-\\)" nil t)
      (replace-match "\\1 --- \\2" nil nil))

    ;; Pass 2 – turn space-hyphen-space into spaced em-dash
    (goto-char (point-min))
    (while (re-search-forward " - " nil t)
      (replace-match " --- " nil nil))))
#+end_src

* ChatGPT export

** export bare link images
#+begin_src emacs-lisp
(defun my/org-wrap-bare-image-paths (_backend)
  "Turn any line that consists only of a pathname ending in
   .png/.jpg/.jpeg/.gif into  [[file:...]].
   Handles absolute paths (/...),  ./relative/...,  ../relative/...,  or
   plain relative like  mob-wife/foo.png."
  (save-excursion
    (goto-char (point-min))
    (while (re-search-forward
            ;; line with optional spaces, *any* path that contains a slash and ends
            ;; in the right extension, then only spaces + EOL
            "^\\s-*\\([^[:space:]]*/[^[:space:]]*\\.\\(?:png\\|jpe?g\\|gif\\)\\)\\s-*$"
            nil t)
      (let* ((raw (match-string 1))
             ;; encode spaces only
             (encoded (replace-regexp-in-string " " "%20" raw t t)))
        (replace-match (format "[[file:%s]]" encoded) t t))))
  (buffer-string))

(add-hook 'org-export-before-processing-hook #'my/org-wrap-bare-image-paths)

#+end_src

#+begin_src emacs-lisp
(defun my/org-insert-image-links-from-dir (dir &optional as-bare-paths)
  "Insert Org links for every image in DIR.
If AS-BARE-PATHS is non-nil (or called with a prefix key),
insert the *bare relative pathname* instead of [[file:...]].
Supported extensions: png, jpg, jpeg, gif, svg, webp."
  (interactive "DDirectory with images: \nP")
  (let* ((img-ext '("png" "jpg" "jpeg" "gif" "svg" "webp"))
         (here    (file-name-directory (or (buffer-file-name) default-directory)))
         (files   (seq-filter
                   (lambda (f)
                     (and (file-regular-p f)
                          (member (downcase (file-name-extension f)) img-ext)))
                   (directory-files dir t "^[^.].*"))))   ; skip . and ..
    (unless files
      (user-error "No image files found in %s" dir))
    (dolist (f (sort files #'string<))
      (let ((rel (file-relative-name f here)))
        (insert (if as-bare-paths
                    rel
                  (format "[[file:%s]]" rel)))
        (insert "\n")))))

#+end_src

** slugs
#+begin_src emacs-lisp
;;; --- batch exporter: one HTML file per heading -----------------------------

(defun my/slugify (s)
  "Turn a heading title S into a filesystem-safe slug."
  (let* ((down  (downcase
                 (replace-regexp-in-string "[^[:alnum:]]+" "-" s)))
         (clean (replace-regexp-in-string "^-\\|-\\'" "" down)))
    (replace-regexp-in-string "-+" "-" clean)))


(defun my/org-export-headings-to-html ()
  "Export each level-2 subtree to its own HTML file, plus index.html.
   Adds ../css/chatgpt-images.css to every page."
  (interactive)
  (unless (buffer-file-name)
    (user-error "Save this buffer first - exporter needs a filename"))
  (let* ((base-dir (file-name-directory (buffer-file-name)))
         ;; The CSS lives one directory above base-dir
         (css-path (file-relative-name
                    (expand-file-name "../css/chatgpt-images.css" base-dir)
                    base-dir))
         (css-tag  (format "<link rel=\"stylesheet\" href=\"%s\"/>" css-path))
         (index-links '()))
    ;; ---------- export each level-2 heading ----------
    (org-map-entries
     (lambda ()
       (when (= (org-outline-level) 2)
         (let* ((title (nth 4 (org-heading-components)))
                (slug  (concat (my/slugify title) ".html"))
                (outfile (expand-file-name slug base-dir)))
           (save-restriction
             (org-narrow-to-subtree)
             (let ((org-html-head-extra css-tag))
               (org-export-to-file 'html outfile nil nil nil nil)))
           (push (format "- [[file:%s][%s]]" slug title) index-links))))
     nil 'file)
    ;; ---------- build the index ----------
    (with-temp-buffer
      (insert "* ChatGPT Use Cases for Mamie - Index\n\n")
      (dolist (l (nreverse index-links)) (insert l "\n"))
      (write-file (expand-file-name "index.org" base-dir))
      (let ((org-html-head-extra css-tag))
        (org-export-to-file 'html (expand-file-name "index.html" base-dir))))
    (message "✅ Exported %d pages + index" (length index-links))))

#+end_src

* Emacs server

** fullscreen on each instance
#+BEGIN_EXAMPLE emacs-lisp
;; For full screen instead
(add-hook 'after-make-frame-functions
          (lambda (frame)
            (select-frame frame)
            (toggle-frame-fullscreen)
(org-roam-dailies-goto-today)
))


#+END_EXAMPLE

** silence warnings
#+begin_src emacs-lisp
(with-eval-after-load 'info
  (set-face-attribute 'info-index-match nil
                      :foreground 'unspecified
                      :background "#3a3a3a"))  ; or any color you prefer


;; Better winner-mode fix
(setq winner-dont-bind-my-keys t)  ; Optional: if you have key conflicts
(with-eval-after-load 'winner
  (setq winner-boring-buffers-regexp
        "\\*[hH]elm.*\\*\\|\\*Compile-Log\\*\\|\\*Messages\\*"))

;; 1. Silence winner-mode bug (put in user-config)
(with-eval-after-load 'winner
  (advice-add 'winner-save-old-configurations
              :around (lambda (orig &rest args)
                        (ignore-errors (apply orig args)))))

;; 2. Ensure the Info face is legal (one-time in *Customize* or edit custom-set-faces)
(with-eval-after-load 'info
  (set-face-attribute 'info-index-match nil :foreground 'unspecified))
#+end_src

* Astro

#+begin_src emacs-lisp
;;; --- Astro + Eglot -------------------------------------------------

;; Core major-mode foundation
(use-package web-mode
  :ensure t)

;; Minimal major mode for .astro files (inherits from web-mode)
(define-derived-mode astro-mode web-mode "Astro")
(add-to-list 'auto-mode-alist '("\\.astro\\'" . astro-mode))

;; LSP client
(use-package eglot
  :ensure t
  :config
  ;; Tell Eglot how to start Astro's language-server
  (add-to-list
   'eglot-server-programs
   ;; ------- choose ONE of the two recipes below --------------------
   ;; ① Global npm/yarn/pnpm install (easiest):
   '(astro-mode . ("astro-ls" "--stdio"
                   :initializationOptions
                   (:typescript (:tsdk "/Users/jay/Library/CloudStorage/Dropbox/github/square-satellite/node_modules/typescript/lib"))))



   ;; ② Project-local devDependency → uncomment next block *and* comment
   ;;    the global line above.  Uses npx to locate the binary.
   ;; '(astro-mode . ("npx" "--no" "@astrojs/language-server" "--stdio"
   ;;                 :initializationOptions
   ;;                 (:typescript (:tsdk "./node_modules/typescript/lib"))))
   )

  ;; Spin up Eglot automatically in .astro buffers
  (add-hook 'astro-mode-hook #'eglot-ensure))

;; Optional: run "format" (Prettier via Astro-LS) every time you save
(defun my/astro-format-before-save ()
  (when (derived-mode-p 'astro-mode)
    (eglot-format-buffer)))

(add-hook 'before-save-hook #'my/astro-format-before-save)

#+end_src
------------------------------------------------------------------
Prerequisites outside Emacs (run in your project or globally):
  npm install -g @astrojs/language-server      # or: npm i -D @astrojs/language-server
  npm install -D typescript                    # if you didn't enable TS at project creation
------------------------------------------------------------------

** ChatGPT conversion


#+begin_src emacs-lisp

(defun convert-markdown-to-org-code-blocks-simple ()
  "Simple version that replaces based on presence/absence of language specifier."
  (interactive)
  (let ((inhibit-read-only t))
    (save-excursion
      ;; First pass: Replace opening fences (those with language specifiers)
      (goto-char (point-min))
      (while (re-search-forward "^\\([[:space:]]*\\)\\(````?\\)\\([[:alnum:]]+\\)[[:space:]]*$" nil t)
        (replace-match "\\1#+begin_src \\3" t))

      ;; Second pass: Replace closing fences (those without language specifiers)
      (goto-char (point-min))
      (while (re-search-forward "^\\([[:space:]]*\\)\\(````?\\)[[:space:]]*$" nil t)
        (replace-match "\\1#+end_src \n" t))

      ;; Handle backticks in language specification
      (goto-char (point-min))
      (while (re-search-forward "^\\([[:space:]]*\\)#\\+begin_src[[:space:]]+`\\([[:alnum:]]+\\)" nil t)
        (replace-match "\\1#+begin_src \\2" t)))))


;; Optional: Create keybindings
;; (global-set-key (kbd "C-c m o") 'convert-markdown-to-org-code-blocks)
;; (global-set-key (kbd "C-c m s") 'convert-markdown-to-org-code-blocks-simple)
;; (global-set-key (kbd "C-c m S") 'convert-markdown-to-org-code-blocks-stateful)
#+end_src

* Notch Management
#+begin_src emacs-lisp
;; MacBook Pro Notch Tab Bar Auto-Management
(defvar jay/--last-notch-state nil
  "Remember whether the tab bar is currently shown to hide the notch.")

(use-package tab-bar
  :defer t
  :config
  (tab-bar-mode -1))

(defun jay/get-frame-position ()
  "Get the actual numeric position of the frame, evaluating any symbolic expressions."
  (let ((left (frame-parameter nil 'left))
        (top (frame-parameter nil 'top)))
    (cons (if (numberp left) left (eval left))
          (if (numberp top) top (eval top)))))

(defun jay/on-macbook-display-p ()
  "Check if current frame is on MacBook Pro built-in display.
Returns t if on built-in Retina display, nil if on external monitor."
  (when (eq system-type 'darwin)
    (let* ((pos (jay/get-frame-position))
           (frame-x (car pos))
           (frame-y (cdr pos))
           (displays (display-monitor-attributes-list))
           (current-display nil))

      ;; Find which display the frame is on
      (dolist (display displays)
        (let* ((geometry (cdr (assoc 'geometry display)))
               (x (nth 0 geometry))
               (y (nth 1 geometry))
               (width (nth 2 geometry))
               (height (nth 3 geometry)))
          (when (and geometry
                     (>= frame-x x)
                     (<= frame-x (+ x width))
                     (>= frame-y y)
                     (<= frame-y (+ y height)))
            (setq current-display display))))

      ;; Check if current display is the built-in display
      (when current-display
        (let ((display-name (cdr (assoc 'name current-display))))
          (and display-name
               (string-match-p "Built-in\\|Retina Display" display-name)))))))

(defun jay/update-tab-bar-for-display ()
  "Enable the tab bar *only* when the frame is both on the MacBook display
and in fullscreen (or maximized) mode.  Otherwise, keep it politely out of sight."
  (interactive)
  (let* ((fullscreen-state (frame-parameter nil 'fullscreen))
         (on-macbook      (jay/on-macbook-display-p))
         ;; We regard either 'fullboth (native fullscreen) or 'maximized
         ;; as warranting notch-defence duty.
         (should-show     (and on-macbook
                               (memq fullscreen-state '(fullboth maximized)))))
    (if should-show
        (progn
          (tab-bar-mode 1)
          (message "🍙🚫 Notch hidden 🎩✨"))
      (progn
        (tab-bar-mode -1)
;; (message "🎩 Notch hiding disabled.")
))))

;; Auto-update functions
(defun jay/frame-move-hook (frame)
  "Hook to run when frame might have moved."
  (when (eq frame (selected-frame))
    (jay/update-tab-bar-for-display)))

(defun jay/setup-display-aware-tab-bar ()
  "Activate minimal hooks for notch-hiding logic."
  (when (eq system-type 'darwin)
    ;; Clear any old hooks
    (remove-hook 'focus-in-hook            #'jay/update-tab-bar-for-display)
    (remove-hook 'after-make-frame-functions
                 (lambda (f) (with-selected-frame f
                               (jay/update-tab-bar-for-display))))
    ;; Re-add just one lightweight hook
    (add-hook 'focus-in-hook #'jay/update-tab-bar-for-display)
    ;; Initial check at startup
    (jay/update-tab-bar-for-display)))

;; Modified fullscreen toggle that updates tab bar
(defun jay/toggle-fullscreen ()
  "Toggle fullscreen mode with automatic tab bar management."
  (interactive)
  (let ((fullscreen-p (frame-parameter nil 'fullscreen)))
    (set-frame-parameter
     nil 'fullscreen
     (if fullscreen-p nil 'fullboth))
    ;; Update tab bar after changing fullscreen state
    (run-with-timer 0.1 nil 'jay/update-tab-bar-for-display)
    ;; Adjust font size if available
    (when (fboundp 'jay/adjust-font-size)
      (jay/adjust-font-size))))

;; Debug function to check current status
(defun jay/debug-display-detection ()
  "Show current display detection status."
  (interactive)
  (let* ((on-macbook (jay/on-macbook-display-p))
         (pos (jay/get-frame-position))
         (displays (display-monitor-attributes-list))
         (display-info (mapconcat
                       (lambda (d)
                         (format "%s: %s"
                                 (or (cdr (assoc 'name d)) "Unknown")
                                 (cdr (assoc 'geometry d))))
                       displays ", ")))
    (message "🔍 Position: %s | MacBook display: %s, sir | Monitors in residence: %s"
             pos (if on-macbook "Indeed" "I'm afraid not") display-info)))

;; Initialize on load
(when (eq system-type 'darwin)
  (run-with-timer 1 nil 'jay/setup-display-aware-tab-bar))

#+end_src


* Local Variables & The End
These have to be at the end.

# Local Variables:
# org-config-files-local-mode: t
# enable-local-eval: t
# eval: (org-config-files-local-mode 1)
# End:

