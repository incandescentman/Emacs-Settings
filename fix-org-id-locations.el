;;; fix-org-id-locations.el --- Fix corrupted org-id-locations file -*- lexical-binding: t; -*-

;; This function fixes the org-id-locations file when it contains a list
;; instead of the expected hash table format

(defun fix-org-id-locations ()
  "Fix corrupted org-id-locations file by converting list to hash table."
  (interactive)
  (let* ((locations-file (expand-file-name ".org-id-locations"
                                           (or (bound-and-true-p org-id-locations-file-relative)
                                               user-emacs-directory
                                               "~/.emacs.d/.cache")))
         (cache-locations-file (expand-file-name ".cache/.org-id-locations"
                                                 user-emacs-directory)))

    ;; Try the cache location first if main doesn't exist
    (when (and (not (file-exists-p locations-file))
               (file-exists-p cache-locations-file))
      (setq locations-file cache-locations-file))

    (if (not (file-exists-p locations-file))
        (message "org-id-locations file not found at %s" locations-file)

      ;; Read the current contents
      (let ((contents (with-temp-buffer
                       (insert-file-contents locations-file)
                       (goto-char (point-min))
                       (condition-case nil
                           (read (current-buffer))
                         (error nil)))))

        (cond
         ;; If it's already a hash table, nothing to do
         ((hash-table-p contents)
          (message "org-id-locations is already a hash table. No fix needed."))

         ;; If it's a list, convert to hash table
         ((listp contents)
          (message "Converting org-id-locations from list to hash table...")
          (let ((new-table (make-hash-table :test 'equal)))

            ;; Convert list entries to hash table
            (dolist (entry contents)
              (when (and (listp entry) (>= (length entry) 2))
                (let ((file (car entry))
                      (ids (cdr entry)))
                  ;; Expand file path to absolute
                  (setq file (expand-file-name file))
                  ;; Store IDs for this file
                  (puthash file ids new-table))))

            ;; Set the global variable
            (setq org-id-locations new-table)

            ;; Save the corrected format
            (with-temp-file locations-file
              (let ((print-length nil)
                    (print-level nil))
                (insert ";; org-id-locations-file -- autogenerated, do not edit\n")
                (insert "(setq org-id-locations ")
                (prin1 new-table (current-buffer))
                (insert ")\n")))

            (message "Fixed org-id-locations: converted %d entries to hash table"
                     (hash-table-count new-table))))

         (t
          (message "Unknown format in org-id-locations file")))))))

;; Alternative approach: just reset org-id-locations and let org-roam rebuild it
(defun reset-org-id-locations ()
  "Reset org-id-locations to an empty hash table and let org-roam rebuild it."
  (interactive)
  (setq org-id-locations (make-hash-table :test 'equal))
  (when (fboundp 'org-id-locations-save)
    (org-id-locations-save))
  (when (and (fboundp 'org-roam-db-sync)
             (boundp 'org-roam-directory)
             (file-exists-p org-roam-directory))
    (org-roam-db-sync))
  (message "Reset org-id-locations. Run org-roam-db-sync to rebuild."))

(provide 'fix-org-id-locations)
;;; fix-org-id-locations.el ends here