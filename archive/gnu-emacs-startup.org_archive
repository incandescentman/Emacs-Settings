
Archived entries from file /Users/jay/Dropbox/emacs/prelude/personal/gnu-emacs-startup.org


* DONE in pasteboard-paste above, modify so that it will remove extra whitespace BEFORE pasted word :rudi:
  :PROPERTIES:
  :ARCHIVE_TIME: 2015-05-29 Fri 23:23
  :ARCHIVE_FILE: ~/Dropbox/emacs/prelude/personal/gnu-emacs-startup.org
  :ARCHIVE_OLPATH: Isolate Emacs kill ring from the OSX system pasteboard (clipboard).
  :ARCHIVE_CATEGORY: gnu-emacs-startup
  :END:



: Lorem ipsum.

e.g. in the example above, if I place the point on the "i" in "ipsum" and then paste the string " dolor sit amet" including the initial space in the string, I should get...

...this:
: Lorem dolor sit amet ipsum.

...NOT this:

: Lorem  dolor sit amet ipsum.

;;; old version; remove after testing new one (see below)
;; (defun pasteboard-paste()
;;   "Paste from OS X system pasteboard via `pbpaste' to point."
;;   (interactive)
;; (my/fix-space)
;;   (shell-command-on-region
;;    (point) (if mark-active (mark) (point)) "pbpaste | perl -p -e 's/\r$//' | tr '\r' '\n'" nil t)
;; (my/fix-space)
;; ;; (when (looking-back "^[[:space:]]+") (just-one-space)) ; this didn't work
;; )

;;; new version; not thoroughly tested
(defun pasteboard-paste ()
  "Paste from OS X system pasteboard via `pbpaste' to point."
  (interactive)
  (let ((start (point))
        (end (if mark-active
                 (mark)
               (point))))
    (shell-command-on-region start end
                             "pbpaste | perl -p -e 's/\r$//' | tr '\r' '\n'"
                             nil t)
    (my/fix-space)
    (save-excursion
      (goto-char start)
      (my/fix-space))))




* DONE in pasteboard-paste above, modify so that it will remove extra whitespace BEFORE pasted word :rudi:
  :PROPERTIES:
  :ARCHIVE_TIME: 2015-05-29 Fri 23:23
  :ARCHIVE_FILE: ~/Dropbox/emacs/prelude/personal/gnu-emacs-startup.org
  :ARCHIVE_OLPATH: Isolate Emacs kill ring from the OSX system pasteboard (clipboard).
  :ARCHIVE_CATEGORY: gnu-emacs-startup
  :END:



: Lorem ipsum.

e.g. in the example above, if I place the point on the "i" in "ipsum" and then paste the string " dolor sit amet" including the initial space in the string, I should get...

...this:
: Lorem dolor sit amet ipsum.

...NOT this:

: Lorem  dolor sit amet ipsum.

;;; old version; remove after testing new one (see below)
;; (defun pasteboard-paste()
;;   "Paste from OS X system pasteboard via `pbpaste' to point."
;;   (interactive)
;; (my/fix-space)
;;   (shell-command-on-region
;;    (point) (if mark-active (mark) (point)) "pbpaste | perl -p -e 's/\r$//' | tr '\r' '\n'" nil t)
;; (my/fix-space)
;; ;; (when (looking-back "^[[:space:]]+") (just-one-space)) ; this didn't work
;; )

;;; new version; not thoroughly tested
(defun pasteboard-paste ()
  "Paste from OS X system pasteboard via `pbpaste' to point."
  (interactive)
  (let ((start (point))
        (end (if mark-active
                 (mark)
               (point))))
    (shell-command-on-region start end
                             "pbpaste | perl -p -e 's/\r$//' | tr '\r' '\n'"
                             nil t)
    (my/fix-space)
    (save-excursion
      (goto-char start)
      (my/fix-space))))




* TODO can you help me fix this function?                              :rudi:
  :PROPERTIES:
  :ARCHIVE_TIME: 2015-06-07 Sun 22:17
  :ARCHIVE_FILE: ~/Dropbox/emacs/prelude/personal/gnu-emacs-startup.org
  :ARCHIVE_OLPATH: Custom functions/BACKWARD kill word correctly
  :ARCHIVE_CATEGORY: gnu-emacs-startup
  :ARCHIVE_TODO: TODO
  :END:

Take a look at the function kill-word-correctly above. I made it so that kill-word-correctly counts punctuation such as , . ; ? ! as a word.

: The quick brown brown, fox jumped.

In the example above, f I place the point on the "b" in the second instance of "brown", and then do kill-word-correctly TWICE, it first deletes the word brown, and THEN deletes the unwanted comma.

I want to do the same for backward-kill-word-correctly.

Now take this example:
: The quick brown, fox ^ fox jumped.

Goal:
Suppose the point is at the ^ caret above. I want to be able to invoke backward-kill-word-correctly, TWICE, such that...

...the first invocation should result in this:
: The quick brown, fox jumped.

...and second invocation should then delete the comma and fix the space so the result is this:
: The quick brown fox jumped.

*** DONE In the example above, is the caret part of the string, or just there to mark point? :followup:

    The point of this question is that, in case it is part of the string, the
    first invocation deletes it, so it is not entirely a "backward" kill.  I
    think the semantics can get a bit convoluted here.
*** DONE Clarification: The caret is NOT part of the string.

Sorry, maybe a better way to phrase it would be as follows:

Take the example below...

: The quick brown, fox fox jumped.

...and suppose the point is on the space between the first "fox" and the second one, or on the "f" in the second "fox".

I want to be able to invoke backward-kill-word-correctly, TWICE, such that it first deletes the word, then deletes the comma (but leaves one space) such that the result is this:

: The quick brown fox jumped.

Thanks!!

*** DONE More follow-up questions                             :answer:rudi:

     - When you say that you want to invoke the command twice and have that
       behaviour, are you expecting it to keep some sort of memory?

: No. No memory.

 Or, on the contrary, should the second invocation in your example kill *just* the comma regardless of the first invocation?

: Yes. Basically I just want punctuation (,.:;!?) to be considered a word when I do backward-kill-word-correctly.

I will implement it like that (no memory) since not only it is the more logical to me, but also it should be easily adaptable if you originally intended a different semantics.

: Great! It appears to be working as I intended.


        - ~backward-kill-word~ affects the kill-ring, adding or appending the
          killed text to it.  Do you want to keep the same semantics?  In your
          example above, after invoking ~backward-kill-word-correctly~ twice, the
          kill-ring's last entry would have the string ", fox ".  I'm asking since
          your implementation of ~kill-word-correctly~ does indeed lose this
          semantics, since ~delete-forward-char~ does not affect the kill-ring
          (neither does ~my/fix-space~, by the way).

: No need to keep the comma once it is out of its context. The kill ring could have just "fox" if this is easy to implement. If it's time consuming then don't worry about it.

**** TODO Reply

      Well, it does complicate things a bit, and the semantics anyway seem clearer to me if the kill-ring contains all the killed text, including punctuation. Take your example:

: The quick brown, fox fox^ jumped.

      If I kill everything consecutively down to the comma, the kill-ring would keep "fox fox". However, if I would kill everything down to "brown", we'd probably want "brown, fox fox" to end up in the kill-ring - and that includes the comma. This behaviour is non-trivial.

      I will thus leave it as it is (include the killed punctuation in the kill-ring).

:


* DONE New note about the abbrevs file                                 :rudi:
  :PROPERTIES:
  :ARCHIVE_TIME: 2015-06-16 Tue 14:06
  :ARCHIVE_FILE: ~/Dropbox/emacs/prelude/personal/gnu-emacs-startup.org
  :ARCHIVE_CATEGORY: gnu-emacs-startup
  :END:
Rúdi: As you can see from my abbrevs file, it contains two main kinds of abbrevs:

1. Typographical error corrections

Ghandi → Gandhi

#+BEGIN_EXAMPLE
("Ghandi" "Gandhi" nil 0)
#+END_EXAMPLE

These get created automatically through some code I found here:
[[http://endlessparentheses.com/ispell-and-abbrev-the-perfect-auto-correct.html][Emacs, Ispell and Abbrev, the Perfect Auto-Correct]]

2. Expansion of text shortcuts

bc → because

#+BEGIN_EXAMPLE
("bc" "because" nil 455)
#+END_EXAMPLE

These are my way of making typing faster, by creating text shortcuts that automatically expand into the full form of the word. These are all between 1 and 4 characters long, and expand to form longer words.

For ONLY the #2 "expansion of text shortcuts", I would like to:
- [X] separate these out into their own separate abbrevs file, which I can then open-source on Github and share with other Emacs users, and
- [X] also convert them to TextExpander format, which I can also open-source share with other people.

Basically I want to offer these expansions in two formats.

That's my goal for this latest task. Does that make sense?

Thanks,
Jay


* DONE [#A] a different kind of request
  :PROPERTIES:
  :ARCHIVE_TIME: 2015-06-16 Tue 14:06
  :ARCHIVE_FILE: ~/Dropbox/emacs/prelude/personal/gnu-emacs-startup.org
  :ARCHIVE_CATEGORY: gnu-emacs-startup
  :END:
Hi Rúdi,

Here's a different kind of request. If you're interested, maybe we could make it the top priority. However, it's not strictly speaking hacking in elisp, so feel free to turn it down if it doesn't interest you and we can just proceed with the Emacs functions.

I'd like to make some of my many Emacs abbrevs shortcuts available in other applications. On my Mac OSX, I use an app called TextExpander to expand text. So I'd like to convert my abbrevs file to TextExpander format.

This task involves programmatically converting an abbrevs file, which looks something like this:

#+BEGIN_QUOTE
(define-abbrev-table 'global-abbrev-table '(
 ("qo" "without" nil 1)
 ("ty" "they" nil 3)
 ("tyr" "they're" nil 5)
))
#+END_QUOTE

...into a TextExpander file, which looks something like this:

#+BEGIN_QUOTE
<dict>
			<key>abbreviation</key>
			<string>qo</string>
			<key>abbreviationMode</key>
			<integer>2</integer>
			<key>creationDate</key>
			<date>2015-06-11T01:04:09Z</date>
			<key>flags</key>
			<integer>0</integer>
			<key>label</key>
			<string></string>
			<key>lastUsed</key>
			<date>2015-06-11T01:05:05Z</date>
			<key>modificationDate</key>
			<date>2015-06-11T01:04:14Z</date>
			<key>plainText</key>
			<string>without</string>
			<key>snippetType</key>
			<integer>0</integer>
			<key>useCount</key>
			<integer>0</integer>
			<key>uuidString</key>
			<string>12D393EE-F929-4F9B-AFF6-F43D718E8048</string>
		</dict>
		<dict>
			<key>abbreviation</key>
			<string>ty</string>
			<key>abbreviationMode</key>
			<integer>2</integer>
			<key>creationDate</key>
			<date>2015-06-11T01:03:06Z</date>
			<key>flags</key>
			<integer>0</integer>
			<key>label</key>
			<string></string>
			<key>modificationDate</key>
			<date>2015-06-11T01:03:06Z</date>
			<key>plainText</key>
			<string>they</string>
			<key>snippetType</key>
			<integer>0</integer>
			<key>useCount</key>
			<integer>0</integer>
			<key>uuidString</key>
			<string>6341B244-BC48-48B9-8E1E-ABAF34C44BC3</string>
		</dict>
		<dict>
			<key>abbreviation</key>
			<string>tyr</string>
			<key>abbreviationMode</key>
			<integer>2</integer>
			<key>creationDate</key>
			<date>2015-06-11T01:03:02Z</date>
			<key>flags</key>
			<integer>0</integer>
			<key>label</key>
			<string></string>
			<key>lastUsed</key>
			<date>2015-06-11T01:03:31Z</date>
			<key>modificationDate</key>
			<date>2015-06-11T01:03:02Z</date>
			<key>plainText</key>
			<string>they're</string>
			<key>snippetType</key>
			<integer>0</integer>
			<key>useCount</key>
			<integer>0</integer>
			<key>uuidString</key>
			<string>A1A1B41E-B8BF-4562-B977-143419E30695</string>
		</dict>
#+END_QUOTE

Let me know if this interests you, and if so, I'll send you my abbrev file. Again, if not, no worries. Thanks!
** DONE Request for clarification                            :followup:

   Sure, I'll handle it. It sure is just hacking elisp...

: Excellent. :-)

   Here's my proposal: a new function, say ~abbrev-table-export-to-text-expander~, which prompts you for the abbrev table name, and creates a new buffer with the result of converting to TextExpander, which you then can save in the location you desire. Does that look good?

: It would be cool if I could just export all my existing abbrevs. Here's what I would like to do: export all my abbrevs where the abbrev is 4 characters or less. No confirmation, no prompt.
: e.g. ehrs → behaviors
: anything longer than that, I don't need to export to TextExpander.
: Is this feasible?

   Now, before I start, a question: is there information about the file format? I cannot deduce the meaning of all XML tags in your example. I have searched the web for the format, to no available.

: Good question. The format is called TextExpander for OSX.

http://smilesoftware.com/help/TextExpander/creating.html

http://brettterpstra.com/2013/01/04/mass-creating-textexpander-snippets/

http://smilesoftware.com/help/TextExpander%204%20Help.pdf

http://smilesoftware.com/help/TextExpander/groups.html

Take a look and let me know whether that's helpful. If not you may ask a question on StackExchange? Or if not I can contact Smile support.

Thank you! Let me know.

Thanks,
Jay

* DONE Request
  :PROPERTIES:
  :ARCHIVE_TIME: 2015-06-16 Tue 16:48
  :ARCHIVE_FILE: ~/Dropbox/emacs/prelude/personal/gnu-emacs-startup.org
  :ARCHIVE_CATEGORY: gnu-emacs-startup
  :END:
For the above whitespace and sentence functions, can we make it so that Emacs will recognize three hyphens in a row---as punctuation same as a comma?

** DONE Request for clarification

   Not sure which functions you mean. The ones in the "Sentences" Heading?
** DONE Answer
- my/fix-space
- kill-clause
- my-delete-backward
- kill-word-correctly
- backward-kill-word-correctly

Basically I'd like to make it so that org-mode treats --- as a singles punctuation mark in any function that looks for :punct:

*** Example
Take a look at the function kill-word-correctly. I want it so that kill-word-correctly counts --- as a word.

Take this sentence below:

: The quick brown fox jumped---jumped high.

In the sentence above, if I place the point on the "h" in "high" and then do kill-word-correctly TWICE, it should first delete the word jumped and fix the space, and THEN on the second invocation, it should deletes the unwanted --- and fix the space.

So the first invocation should result in this:

: The quick brown fox jumped---high.

...and second invocation should then delete the --- and fix the space so the result is this:

: The quick brown fox jumped high.

Thanks!

*** DONE Note & question

    OK. But it is not straightforward. You see, [:punct:] denotes a set of characters; --- a *sequence* of characters. It is not simply a case of changing the meaning of [:punct:]. I don't see a way to do it other than changing each function individually.

    However, according to the syntax table of my org-mode, - is considered a punctuation. So if I ~kill-word-correctly~ over "open-source" (point on 'o'), I then get "-source", and if I do it again, I get "source". Is that the same for you?

: Yes it is.

    If that is the case, then would killing all *consecutive* punctuation marks cover this case? What about "--", "?!", "...?" (and possibly other consecutive punctuation marks, like "--," - some authors like that style)? They would also be killed completely. Is that according to your requirements?

: Yes, automatically killing all consecutive punctuation in cases like "---" "--", "?!", and "...?" would certainly be according to my requirements. So yes, I think that solves the problem! Thank you!

** DONE More questions

   - ~my/fix-space~
     - What should be the difference here?

: The difference is that there should be a space after ; : , ? ! or . but no space after ---
*or after -*

   - ~kill-clause~
     - Since this is already sensitive to --, it should also be sensitive to ---. It should also be sensitive to other sequences of punctuation marks. Let me know otherwise.

: Excellent.

   - ~my/delete-backward~
     - Again, I don't think this requires any change. It deletes all spaces when it is looking at a punctuation mark. Since - is a punctuation mark, any space before --- will also be deleted.

: Correct. I think the difference is the space following ---

     - Note: there were two versions of ~my/delete-backward~; I assumed the first one was a failed attempt to give it some ability to get rid of extra whitespaces, so I took the liberty of adding that functionality. So, what it does is the following: after deleting the region or character, checks if immediately before or after the point there is a space, and if that is the case, uses ~my/fix-space~. Does this behaviour make sense to you?

   - ~kill-word-correctly~ & ~backward-kill-word-correctly~
     - Regarding these two functions, I have added new versions of them. Note however that they tend to fsck up the kill-ring, because of their calls to ~my/fix-space~. This already occurred in the old versions. Consider the following example:

: Kill them all!

   If you place the point at 'K', and call ~kill-word-correctly~ four times, all of the text will be killed. After killing each word, two consecutive spaces are left, and ~my/fix-space~ will get rid of one. However, ~my/fix-space~ is not a kill command, so it does not affect the kill-ring. Consequently, if you yank after killing all the words, you'll get:

: Killthemall!

   Would you like me to try to fix this or is the kill ring really not your concern?

: Haha, no, this is not a problem! Thank you!


* TODO [#B] smart-colon exception for smiley emoticon
  :PROPERTIES:
  :ARCHIVE_TIME: 2015-06-18 Thu 15:56
  :ARCHIVE_FILE: ~/Dropbox/emacs/prelude/personal/gnu-emacs-startup.org
  :ARCHIVE_CATEGORY: gnu-emacs-startup
  :ARCHIVE_TODO: TODO
  :END:
I'd like to make it easy for me to type something like the above:
: Thanks! :-)

Currently if I type it the way it looks, I wind up with this:
: Thanks!: -)

Should we somehow make an exception for the above, or should I just disable smart-punctuation for colon?


* DONE [#C] yet another edge case for kill-word-correctly-and-capitalize
  :PROPERTIES:
  :ARCHIVE_TIME: 2015-06-26 Fri 13:15
  :ARCHIVE_FILE: ~/Dropbox/emacs/prelude/personal/gnu-emacs-startup.org
  :ARCHIVE_CATEGORY: gnu-emacs-startup
  :ARCHIVE_TODO: DONE
  :END:
Here's another edge case.

: Into the book her sister was reading, but it had no pictures or conversations in it. "And what is the use of a book," thought thought Alice, "without pictures or conversations?"

Suppose the point is on the "t" in the first "thought" and I invoke kill-word-correctly-and-capitalize.

Current output:
: Into the book her sister was reading, but it had no pictures or conversations in it. "And what is the use of a book,"thought Alice, "without pictures or conversations?"

Desired output:
: Into the book her sister was reading, but it had no pictures or conversations in it. "And what is the use of a book," thought Alice, "without pictures or conversations?"

This function is becoming more and more useful!

** NOTE-TO-JAY Question

   The culprit here seems to be again ~my/fix-space~. I see you added the following clause:

: (looking-back "\" ")

   This means that after fixing the spaces, if you look back from point to '" ', you should delete the space. I suppose that's only true if: (1) the quotation marks are starting a quote, or (2) there is a punctuation mark ahead (which is handled by another clause).

   So, what was the intention here?
** NOTE-TO-RÚDI Answer
Hmm, I'm not sure I remember what I intended there. I must have been trying to address an edge case I found myself. If it makes sense to remove that clause again, let's do so, and if I find another edge case, we can address it at that point.

In general, I will use quotation marks and punctuation in the style/sequence reflected below:

#+BEGIN_QUOTE
Alice was beginning to get very tired of sitting by her sister on the bank (and of having nothing to do). Once or twice she had peeped into the book her sister was reading, but it had no pictures or conversations in it. "And what is the use of a book," thought Alice, "without pictures or conversations."
#+END_QUOTE

Thanks!

** NOTE-TO-JAY About the quotation marks

OK, I removed the clauses pertaining to the quotation marks. Indeed, it is hard to determine, when you are looking at a single quotation mark, if it is starting or ending the quote. You must pair it with the previous or next; in the limit you have to take into account the whole buffer. There is probably code out there that does it (note that ~emacs-lisp-mode~, for example, colourises strings -- therefore, it must know when a string starts or ends). I can search for it if you want.
** NOTE-TO-RÚDI yes, later
Yes, that would be great, but let's deprioritize it. Thanks!


#+BEGIN_SRC emacs-lisp
(defvar *punctuation-markers-to-cycle-between*  ".?!")

(defun cycle-punctuation ()
  (interactive)
  (save-excursion
    (forward-sentence)
    (when (re-search-backward (format "\\>\\([%s]\\)[[:space:]]*\\="
                                      *punctuation-markers-to-cycle-between*)
                              nil t)
      (let ((next (elt *punctuation-markers-to-cycle-between*
                       ;; circular string; should be abstracted
                       (mod (1+ (position (elt (match-string 1) 0)
                                          *punctuation-markers-to-cycle-between*))
                            (length *punctuation-markers-to-cycle-between*)))))
        (replace-match (format "%c" next) t t nil 1)))))

(define-key key-minor-mode-map (kbd "M-.") 'cycle-punctuation)
#+END_SRC


* italicize next word
:PROPERTIES:
:ARCHIVE_TIME: 2015-11-21 Sat 19:59
:ARCHIVE_FILE: ~/Dropbox/emacs/prelude/personal/gnu-emacs-startup.org
:ARCHIVE_OLPATH: experiments - tested/words - some interesting utilities for text in Emacs/Send email to a list of users
:ARCHIVE_CATEGORY: gnu-emacs-startup
:END:

deprecated. use embolden next word, and bold words will be changed into italics during export. for purposes of visual display within Emacs, we'll display as bold. but semantically we'll treat these as italics, since there is no bold in books.

   #+BEGIN_EXAMPLE emacs-lisp
(define-minor-mode italicize-next-word
    "Make the next word you type bold."
  nil
  :lighter " ITALICIZE"
  :keymap (let ((map (make-sparse-keymap)))
            (define-key map (kbd "SPC") (lambda ()
                      (interactive)
                      (save-excursion
                        (goto-char (get-register 'p))
                        (insert "/"))
                      (insert "/ ")
                      (italicize-next-word -1)))
        (define-key map (kbd ".") (lambda ()
                    (interactive)
                    (save-excursion
                      (goto-char (get-register 'p))
                      (insert "/"))
                    (insert "/. ")
                    (italicize-next-word -1)))
            map)
  (if italicize-next-word
      (set-register 'p (point))
    (set-register 'p nil)))

(global-set-key "\C-i" 'italicize-next-word)
(define-key key-minor-mode-map (kbd "C-i") 'italicize-next-word)
   #+END_EXAMPLE

* old version, works
:PROPERTIES:
:ARCHIVE_TIME: 2015-11-21 Sat 20:21
:ARCHIVE_FILE: ~/Dropbox/emacs/prelude/personal/gnu-emacs-startup.org
:ARCHIVE_OLPATH: spacecraft-mode - superior handling of whitespace for writing and editing prose/self insert space/smart-org-meta-return-dwim
:ARCHIVE_CATEGORY: gnu-emacs-startup
:END:
 #+BEGIN_EXAMPLE emacs-lisp
(setq org-blank-before-new-entry
      '((heading . always)
       (plain-list-item . nil)))
(setq org-return-follows-link t)

(defun call-rebinding-org-blank-behaviour (fn)
  (let ((org-blank-before-new-entry
         (copy-tree org-blank-before-new-entry)))
    (when (org-at-heading-p)
      (rplacd (assoc 'heading org-blank-before-new-entry) nil))
    (call-interactively fn)))

(defun smart-org-meta-return-dwim ()
  (interactive)
  (call-rebinding-org-blank-behaviour 'org-meta-return))

(defun smart-org-insert-todo-heading-dwim ()
  (interactive)
  (call-rebinding-org-blank-behaviour 'org-insert-todo-heading))

(define-key org-mode-map (kbd "M-<return>") 'smart-org-meta-return-dwim)
(define-key org-mode-map (kbd "M-S-<return>") 'smart-org-insert-todo-heading-dwim)
 #+END_EXAMPLE

* code not currently in use
:PROPERTIES:
:ARCHIVE_TIME: 2023-02-14 Tue 12:47
:ARCHIVE_FILE: ~/emacs/emacs-settings/gnu-emacs-startup.org
:ARCHIVE_CATEGORY: gnu-emacs-startup
:END:
*** keybindings not currently in use
 (define-key key-minor-mode-map (kbd "DEL")  'new-org-delete-backward-char)
 (global-set-key (kbd "C-c s") 'org-copy-subtree)
 (define-key key-minor-mode-map (kbd "C-v s") 'org-paste-subtree)
;; (define-key key-minor-mode-map (kbd "s-l") 'org-insert-link)
(define-key key-minor-mode-map (kbd "C-c C-l") 'org-insert-link)
 (define-key key-minor-mode-map (kbd "s-i") 'markdown-insert-image)
 (define-key key-minor-mode-map (kbd "s-\\") 'org-ctrl-c-ctrl-c)
 (define-key key-minor-mode-map (kbd "s-u") 'ido-dired)
 (define-key key-minor-mode-map (kbd "H-n") 'org-narrow-to-subtree)
 (define-key key-minor-mode-map (kbd "H-G") 'prelude-google)
 (define-key key-minor-mode-map (kbd "s-G") 'osx-browse-guess)
 (define-key key-minor-mode-map (kbd "s-") 'google-define-word-or-phrase)
 (define-key key-minor-mode-map (kbd "C-c C-x C-o") 'org-pomodoro)
 (define-key key-minor-mode-map (kbd "s-R") 'web-research)


;; (define-key key-minor-mode-map (kbd "<right>") 'aquamacs-right-char)
;; (define-key key-minor-mode-map (kbd "<right>") 'switch-to-next-buffer)
;; (define-key key-minor-mode-map (kbd "<right>") 'switch-to-next-buffer)
;; (define-key key-minor-mode-map (kbd "<down>") 'aquamacs-next-line)


* experiments - tested
:PROPERTIES:
:ARCHIVE_TIME: 2023-02-27 Mon 00:39
:ARCHIVE_FILE: ~/emacs/emacs-settings/gnu-emacs-startup.org
:ARCHIVE_CATEGORY: gnu-emacs-startup
:END:
** words - some interesting utilities for text in Emacs
The idea is a command called words that will be run interactively. It will grab the word at point, or operate on a selected region, and then offer a menu to lookup the definition, find it in a thesaurus, google it, etc.

We structure the code so you can add functions to it later, without directly modifying this code. The only limitation of this code is that the functions must have a signature with no arguments. That does not seem terribly limiting, as we can check for a region, and use it if we want (see the words-google function).

#+BEGIN_SRC emacs-lisp
(defun words-dictionary ()
  (interactive)
  (browse-url
   (format
    "http://dictionary.reference.com/browse/%s?s=t"
    (thing-at-point 'word))))

(defun words-thesaurus ()
  (interactive)
  (browse-url
   (format
    "http://www.thesaurus.com/browse/%s"
    (thing-at-point 'word))))

(defun words-google ()
  (interactive)
  (browse-url
   (format
    "http://www.google.com/search?q=%s"
    (if (region-active-p)
	(url-hexify-string (buffer-substring (region-beginning)
					     (region-end)))
      (thing-at-point 'word)))))


(defvar words-funcs '()
 "functions to run in `words'. Each entry is a list of (key menu-name function).")

(setq words-funcs
  '(("d" "ictionary" words-dictionary)
    ("t" "hesaurus" words-thesaurus)
    ("g" "oogle" words-google)))


(defun words ()
  (interactive)
   (message
   (concat
    (mapconcat
     (lambda (tup)
       (concat "[" (elt tup 0) "]"
	       (elt tup 1) " "))
     words-funcs "") ": "))
   (let ((input (read-char-exclusive)))
     (funcall
      (elt
       (assoc
	(char-to-string input) words-funcs)
       2))))
#+END_SRC

#+RESULTS:
: words

This works nicely. Now, let us add a new function that looks up the word or selection on twitter. We just define a new function, and add the menu selection to the words-func variable.

#+BEGIN_SRC emacs-lisp
(defun words-twitter ()
  (interactive)
  (browse-url
   (format
    "https://twitter.com/search?q=%s"
    (if (region-active-p)
	(url-hexify-string (buffer-substring (region-beginning)
					     (region-end)))
      (thing-at-point 'word)))))

(add-to-list 'words-funcs
  '("w" "twitter" words-twitter)
  t) ; append

#+END_SRC

#+RESULTS:
| d | ictionary | words-dictionary |
| t  | hesaurus  | words-thesaurus  |
| g | oogle     | words-google     |
| w | twitter   | words-twitter    |

Finally, the most complicated idea: spelling and grammar. I know there is flyspell, and such, but they are build on an ancient dictionary. Here, for fun, we explore a web api. This next function is not a trivial one, and I will not explain it here beyond saying it sends a selection of text to a url, gets an xml response back, and that response is parsed and printed to a buffer by this function. The main point is to illustrate we can do interesting things with a selection of text!

#+BEGIN_SRC emacs-lisp
(defun words-atd ()
  "Send paragraph at point to After the deadline for spell and grammar checking."
  (interactive)

  (let* ((url-request-method "POST")
	 (url-request-data (format
			    "key=some-random-text-&data=%s"
			    (url-hexify-string
			     (thing-at-point 'paragraph))))
	 (xml  (with-current-buffer
		   (url-retrieve-synchronously
		    "http://service.afterthedeadline.com/checkDocument")
		 (xml-parse-region url-http-end-of-headers (point-max))))
	 (results (car xml))
	 (errors (xml-get-children results 'error)))

    (switch-to-buffer-other-frame "*ATD*")
    (erase-buffer)
    (dolist (err errors)
      (let* ((children (xml-node-children err))
	     ;; for some reason I could not get the string out, and had to do this.
	     (s (car (last (nth 1 children))))
	     ;; the last/car stuff doesn't seem right. there is probably
	     ;; a more idiomatic way to get this
	     (desc (last (car (xml-get-children children 'description))))
	     (type (last (car (xml-get-children children 'type))))
	     (suggestions (xml-get-children children 'suggestions))
	     (options (xml-get-children (xml-node-name suggestions) 'option))
	     (opt-string  (mapconcat
			   (lambda (el)
			     (when (listp el)
			       (car (last el))))
			   options
			   " ")))

	(insert (format "** %s ** %s
Description: %s
Suggestions: %s

" s type desc opt-string))))))

(add-to-list 'words-funcs
  '("s" "spell/grammar" words-atd)
  t) ; append
#+END_SRC

#+RESULTS:
: words-atd

My final words menu looks like:
#+attr_html: :width 400
[[./images/final-menu.png]]

If I have the cursor in the previous paragraph, run the words command and select "s" I get a buffer with these contents:

#+BEGIN_EXAMPLE
*** flyspell ** (spelling)
Description: (Spelling)
Suggestions: flywheel flyball

*** are build on ** (grammar)
Description: (Auxiliary Verb Agreement)
Suggestions: are built on

*** api ** (spelling)
Description: (Spelling)
Suggestions: app ape apt ai ami

*** url ** (spelling)
Description: (Spelling)
Suggestions: urn ure curl hurl burl

*** xml ** (spelling)
Description: (Spelling)
Suggestions: xl ml

*** selection ** (suggestion)
Description: (Complex Expression)
Suggestions: choice

*** an xml ** (grammar)
Description: (Wrong article)
Suggestions: a xml

*** a selection of ** (grammar)
Description: (Hidden Verbs)
Suggestions:

*** is parsed ** (grammar)
Description: (Passive voice)
Suggestions:

*** selection ** (suggestion)
Description: (Complex Expression)
Suggestions: choice

*** a selection of ** (grammar)
Description: (Hidden Verbs)
Suggestions:
#+END_EXAMPLE

It might be nice to link back to those words, so you could click on them and fix them, but that is a beyond today's goal. In summary, today we looked at a framework to create a user-modifiable menu of commands that are launched from a single command. Here we called the command words, and then built up some different things we might want to do with the word or selection at point. While you can of course just remember the individual commands, remembering one command and then being prompted might have some advantages.

Source: tk

** invisible text in Emacs
Source:    [[http://kitchingroup.cheme.cmu.edu/blog/2014/02/06/Invisible-text-in-Emacs/][invisible text in Emacs]]

** Making org-mode links to files in Emacs packages
#+BEGIN_EXAMPLE
Today I will make a new org-mode link that lets me make links to files inside of Emacs packages. These files may be installed in different places on different systems (e.g. in the system directory, in ELPA directories, or in custom directories), so we need a way to construct paths to them. The application of this is eventually I hope to have some emacs packages of documentation, and I would like to have links between the packages that work no matter how they are installed.

I want a syntax that looks like pkg:rainbow-mode==rainbow-mode-pkg.el. We will have a function that parses that to get the package, and the path to the file in the package. Emacs has a function to find the path to the file that defines a library. I chose == because it seems unlikely that would be a string in a package or path.

#+BEGIN_SRC emacs-lisp :results value
(locate-library "rainbow-mode")
#+END_SRC

#+RESULTS:
: c:/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa/rainbow-mode-0.9/rainbow-mode.elc

We can use that to construct the path to where we want. Say we want the file named "rainbow-mode-pkg.el"

#+BEGIN_SRC emacs-lisp :results value
(expand-file-name
 "rainbow-mode-pkg.el"
 (file-name-directory (locate-library "rainbow-mode")))
#+END_SRC

#+RESULTS:
: c:/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa/rainbow-mode-0.9/rainbow-mode-pkg.el

In org-mode links, the link path gets passed to a function. We can split the string like this to get the package and relative path we are referring to.

#+BEGIN_SRC emacs-lisp :results value
(split-string "rainbow-mode==rainbow-mode-pkg.el" "==")
#+END_SRC

#+RESULTS:
| rainbow-mode | rainbow-mode-pkg.el |

That is all of the pieces we need to construct the link function. Here it is.

#+BEGIN_SRC emacs-lisp
(org-add-link-type
 "pkg"
 (lambda (path)
   (let ((pkg) (relpath)
	 (splitpath (split-string path "==")))
     (setq pkg (car splitpath))
     (setq relpath (nth 1 splitpath))
     (find-file (expand-file-name
		 relpath
		 (file-name-directory (locate-library pkg)))))))
#+END_SRC

#+RESULTS:

pkg:rainbow-mode==rainbow-mode-pkg.el

This works too, but you have to use auctex-pkg as the package name.

pkg:auctex-pkg==doc/intro.texi

I think that is because locate-library looks for the /file/ a library is defined in. That is not quite the same as the root directory of a package. It turns out to be a little more complicated to find that. Below is some code I hacked up looking at the package.el code. First let us examine some pieces.

This gives us information about an installed package.

#+BEGIN_SRC emacs-lisp :results value
(assq 'auctex package-alist)
#+END_SRC

#+RESULTS:
: (auctex . [(11 87 2) nil Integrated environment for *TeX*])

We can get the version of the package like this

#+BEGIN_SRC emacs-lisp :results value
(package-version-join (package-desc-vers (cdr (assq 'auctex package-alist))))
#+END_SRC

#+RESULTS:
: 11.87.2

Ok, finally, we get the directory where it is installed like this:

#+BEGIN_SRC emacs-lisp :results value
(package--dir "auctex" "11.87.2")
#+END_SRC

#+RESULTS:
: c:/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa/auctex-11.87.2

Note that in some places we use a package symbol, and in other places a string name.Putting that together, we have this block to get the install-dir of a package. If we have a package symbol we can get the path like this.

#+BEGIN_SRC emacs-lisp :results value
(let* ((pkg 'auctex)
       (pkg-name (symbol-name pkg)) ; convert symbol to string
       (desc (cdr (assq pkg package-alist)))
       (version (package-version-join (package-desc-vers desc)))
       (pkg-dir (package--dir pkg-name version)))
  pkg-dir)
#+END_SRC

#+RESULTS:
: c:/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa/auctex-11.87.2

Usually, we will have a string though. We just have to make it a symbol with the =intern= function.

#+BEGIN_SRC emacs-lisp :results value
(setq pkg-name "auctex")
(setq pkg (intern pkg-name))
(setq desc (cdr (assq pkg package-alist)))
#+END_SRC

#+RESULTS:
: [(11 87 2) nil "Integrated environment for *TeX*"]

Now, we have all the pieces to get the path from a package name in a string:

#+BEGIN_SRC emacs-lisp :results value
(let* ((pkg-name "auctex")
       (pkg (intern pkg-name))
       (desc (cdr (assq pkg package-alist)))
       (version (package-version-join (package-desc-vers desc)))
       (pkg-dir (package--dir pkg-name version)))
  pkg-dir)
#+END_SRC

#+RESULTS:
: c:/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa/auctex-11.87.2

Let us use that to rewrite the link, and address a few other limitations. We will  use =org-open-link-from-string= so we can use org-link syntax in the path part of the link, e.g. to open a file at a line, or headline. Here is our new link.

#+BEGIN_SRC emacs-lisp
(org-add-link-type
 "pkg2"
 (lambda (path)
   (let ((pkg) (relpath) (pkg-dir) (link-string)
	 (splitpath (split-string path "==")))
     (setq pkg-name (car splitpath))
     (setq relpath (nth 1 splitpath))
     (setq pkg-dir (let* ((pkg-symbol (intern pkg-name)) ;convert string to pkg
			  (desc (cdr (assq pkg-symbol package-alist)))
			  (version (package-version-join (package-desc-vers desc)))
			  (pkg-dir (package--dir pkg-name version)))
		     pkg-dir))
     (setq link-string (format "[[file:%s/%s]]" pkg-dir relpath))
     (message "link: %s" link-string)
     (org-open-link-from-string link-string))))
#+END_SRC

Now, we can do all of these:
pkg2:auctex==doc/faq.texi
pkg2:auctex==doc/faq.texi::should
pkg2:auctex==doc/faq.texi::10
[[pkg2:auctex==doc/faq.texi::first place]]

Awesome!

Just for fun, I made a toy package called =package1= in my elpa directory. That package has an org file in it. Now, I can test out the following links:

pkg2:package1==intro.org

pkg2:package1==intro.org::*Miscellaneous

[[pkg2:package1==intro.org::*subheading with words]]

pkg2:package1==intro.org::#install-section

pkg2:package1==intro.org::intro-target

They all work! That works for packages installed via the package manager. However, when I try this with my custom installed org-mode, it does not work. If I run (describe-package 'org) I see that org is a build in package, and that there is an alternate version avalable. It does not point to my org-installation.

pkg2:org==doc/library-of-babel.org

#+BEGIN_SRC emacs-lisp
(princ (locate-library "org"))
#+END_SRC

#+RESULTS:
: c:/Users/jkitchin/Dropbox/kitchingroup/jmax/org-mode/lisp/org.elc

#+BEGIN_SRC emacs-lisp
(princ (package-installed-p "org"))
#+END_SRC

#+RESULTS:
: nil

Obviously, we need to check if the package is installed via package.el, or if we should look somewhere else. Let us take a final stab at this. Let us review the challenge.

#+BEGIN_SRC emacs-lisp
(print (locate-library "auctex"))
(print (locate-library "auctex-autoloads"))
#+END_SRC

#+RESULTS:
:
: nil
:
: "c:/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa/auctex-11.87.2/auctex-autoloads.el"

We may have to check for a package-autoloads. Ww can wrap that in an =or= macro, which will return the first non-nil result.

#+BEGIN_SRC emacs-lisp :results value
(let ((pkg-name "auctex"))
   (file-name-directory
    (or (locate-library pkg-name)
	(locate-library (format "%s-autoloads" pkg-name)))))
#+END_SRC

#+RESULTS:
: c:/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa/auctex-11.87.2/

Doing this on the org package shows that this points to a lisp directory.
#+BEGIN_SRC emacs-lisp :results value
(let ((pkg-name "org"))
   (file-name-directory
    (or (locate-library pkg-name)
	(locate-library (format "%s-autoloads" pkg-name)))))
#+END_SRC

#+RESULTS:
: c:/Users/jkitchin/Dropbox/kitchingroup/jmax/org-mode/lisp/

So, let's try a final link function.

#+BEGIN_SRC emacs-lisp
(org-add-link-type
 "pkg3"
 (lambda (path)
   (let ((pkg-name) (relpath)(pkg-dir) (link-string)
	 (splitpath (split-string path "==")))
     (setq pkg-name (car splitpath))
     (setq relpath (nth 1 splitpath))
     (setq pkg-dir (file-name-directory
		    (or (locate-library pkg-name)
			(locate-library (format "%s-autoloads" pkg-name)))))
(setq link-string (format "[[file:%s/%s]]" pkg-dir relpath))
     (message "link: %s" link-string)
     (org-open-link-from-string link-string))))
#+END_SRC

#+RESULTS:

Now, we just have to make sure to use the right relative path. This link opens up an org-file in my installed version of org-mode: pkg3:org==../doc/library-of-babel.org

I don't know if there is a more clever way to create these links. There are two parts to them: 1) the package, and 2) the relative path. The link syntax isn't that rich to do it without parsing the linkpath.

#+END_EXAMPLE

** Send email to a list of users
I have a need to send a lot of emails to users in my class. I have to send each student an email containing there userid and a password assigned to them. I have a list of these, so the strategy is to create a function that will email that information to one user, and then use mapc to apply the function to each pair in a list.  First, we work out a function that will send one email to one user.

#+BEGIN_SRC emacs-lisp
(defun send-mail (userid password)
  "send email to sunjaydixit@gmail.com containing their password"
  (interactive)
  (mail)
  (mail-to)
  (insert (format "%s@jaydixit.com" userid))
  (mail-subject)
  (insert "[06-640] account information")
  (mail-text)
  (insert (format "
An account has been created on jaydixit.com
userid: %s
password: %s" userid password))
  (mail-send-and-exit))

;; (send-mail "jkitchin" "trustme99")
#+END_SRC

#+RESULTS:

That worked well. I ran the block and got the email.

Now, suppose I have this data:
#+tblname: users
| userid | password  |
|-------+-----------|
| user1  | trustme99 |
| user2  | foolme99  |
| user3  | blameme99 |

We can pass that to a source block as a list of lists that will look like this:
#+BEGIN_EXAMPLE
 ((user1 trustme99) (user2 foolme99) (user3 blameme99))
#+END_EXAMPLE

Then, we can use a mapc to process each element. Here I use a dummy function with two arguments. If I substitute the function above, each of these users would get an email.

#+BEGIN_SRC emacs-lisp :var data=users
;; (defun fun (a b) (princ (format "user: %s\npassword: %s\n" a but)))

;; (mapc (lambda (x) (fun (car x) (cadr x))) data)
#+END_SRC

#+RESULTS:
: user: user1
: password: trustme99
: user: user2
: password: foolme99
: user: user3
: password: blameme99

I am not sure that is the best way to get the first and second elements in the list element. It looks funny to me, but it works fine. the alternative is not much prettier:

#+BEGIN_SRC emacs-lisp :var data=users
;; (defun fun (a b) (princ (format "user: %s\npassword: %s\n" a but)))

;; (mapc (lambda (x) (fun (nth 0 x) (nth 1 x))) data)
#+END_SRC

#+RESULTS:
: user: user1
: password: trustme99
: user: user2
: password: foolme99
: user: user3
: password: blameme99

Source: [[http://kitchingroup.cheme.cmu.edu/blog/2014/01/13/Send-email-to-a-list-of-users/][The Kitchin Research Group]]


** videos
- [[https://www.youtube.com/watch?v%3D6W82EdwQhxU][Hack Emacs - An Overview of Org Mode - YouTube]]
- [[https://www.youtube.com/watch?v%3DoJTwQvgfgMM][Emacs Org-mode - a system for note-taking and project planning - YouTube]]
- [[https://www.youtube.com/watch?v%3DnsGYet02bEk][Hack Emacs - Org Mode In Depth: Managing Structure - YouTube]]
- [[https://www.youtube.com/watch?v%3DfgizHHd7nOo][Kitchin - org mode is awesome - YouTube]]

** macro to create defuns?

(defmacro make-my-function (name)
  (list 'defun (intern (format "my-%s-function" name)) ()
        (list 'interactive)
        (list (intern (format "mark-%s" name)))
        (list 'do-more-stuff)
        (list (intern (format "modify-%s" name)))))


* source code blocks: org-insert-src-block
:PROPERTIES:
:ARCHIVE_TIME: 2023-02-27 Mon 00:40
:ARCHIVE_FILE: ~/emacs/emacs-settings/gnu-emacs-startup.org
:ARCHIVE_CATEGORY: gnu-emacs-startup
:END:
[[http://wenshanren.org/?p%3D334][Emacs：insert source code block in org-mode | 肉山博客 (Wenshan's Blog)]]


#+BEGIN_SRC emacs-lisp
(defun org-insert-src-block (src-code-type)
  "Insert a `SRC-CODE-TYPE' type source code block in org-mode."
  (interactive
   (let ((src-code-types
          '("emacs-lisp" "sh" "css" "dot" "latex" "fountain")))
     (list (ido-completing-read "Source code type: " src-code-types))))
  (progn
    (newline-and-indent)
    (insert (format "#+BEGIN_SRC %s\n" src-code-type))
    (newline-and-indent)
    (insert "#+END_SRC\n")
    (previous-line 2)
    (org-edit-src-code)))

(local-set-key (kbd "C-c v e")
               'org-edit-src-code)
;; keybinding for inserting code blocks
#+END_SRC


* no-abbrev-slash
:PROPERTIES:
:ARCHIVE_TIME: 2023-02-27 Mon 00:41
:ARCHIVE_FILE: ~/emacs/emacs-settings/gnu-emacs-startup.org
:ARCHIVE_OLPATH: embolden next word
:ARCHIVE_CATEGORY: gnu-emacs-startup
:END:
Doesn't work.

      #+BEGIN_SRC emacs-lisp
(define-minor-mode insert-slash-no-abbrev
    "Make the next word you type bold."
  nil
  :lighter " don't abbreviate"
  :keymap (let ((map (make-sparse-keymap)))
            (define-key map (kbd "SPC") (lambda ()
                      (interactive)
(insert "/ ")
))
            map)
  (if insert-slash-no-abbrev
      (set-register 'p (point))
    (set-register 'p nil)))
;; (global-set-key "/" 'insert-slash-no-abbrev)

      #+END_SRC


* ideas
:PROPERTIES:
:ARCHIVE_TIME: 2023-02-27 Mon 00:41
:ARCHIVE_FILE: ~/emacs/emacs-settings/gnu-emacs-startup.org
:ARCHIVE_OLPATH: embolden next word
:ARCHIVE_CATEGORY: gnu-emacs-startup
:END:
C-d on an empty line in the shell terminates the process.

(defun comint-delchar-or-eof-or-kill-buffer (arg)
  (interactive "p")
  (if (null (get-buffer-process (current-buffer)))
      (kill-buffer)
    (comint-delchar-or-maybe-eof arg)))

(add-hook 'shell-mode-hook
          (lambda ()
            (define-key shell-mode-map
              (kbd "C-d") 'comint-delchar-or-eof-or-kill-buffer)))
With this snippet, another press of C-d will kill the buffer.

It's pretty nice, since you then just tap C-d twice to get rid of the shell and go on about your merry way.



Do you program any elisp, at all, ever?

;; Elisp go-to-definition with M-. and back again with M-,
(autoload 'elisp-slime-nav-mode "elisp-slime-nav")
(add-hook 'emacs-lisp-mode-hook (lambda () (elisp-slime-nav-mode t)))
(eval-after-load 'elisp-slime-nav '(diminish 'elisp-slime-nav-mode))
Then you need to M-x package-install elisp-slime-nav-mode.

It lets you jump to the definition of a function with M-., and back again afterwards with M-,.

That last line says that we want elisp-slime-nav-mode to continue doing its work for us, but we no longer want to be reminded of it.



* experiments - new/untested
:PROPERTIES:
:ARCHIVE_TIME: 2023-02-27 Mon 00:41
:ARCHIVE_FILE: ~/emacs/emacs-settings/gnu-emacs-startup.org
:ARCHIVE_CATEGORY: gnu-emacs-startup
:END:

** include the output of a shell command in org-mode source code block?
[[http://emacs.stackexchange.com/questions/3219/how-to-include-the-output-of-a-shell-command-in-org-mode-source-code-block?rq%3D1][org export - How to include the output of a shell command in org-mode source code block? - Emacs Stack Exchange]]


** play mp3

   #+BEGIN_SRC emacs-lisp
(defun play-mp3 ()
  (interactive)
  (let ((file (buffer-file-name)))
    (kill-buffer (current-buffer))
    (ora-dired-start-process (format "rhythmbox \"%s\"" file))))
(add-to-list 'auto-mode-alist '("\\.mp3\\'" . ora-mp3))
   #+END_SRC

Source: [[http://emacs.stackexchange.com/questions/13561/whats-a-good-way-to-run-a-command-instead-of-opening-a-file][elisp - What's a good way to run a command instead of opening a file? - Emacs Stack Exchange]]


shareeditflag
answered 6 hours ago

sds
6258


Thanks, I already bound "r" in dired to do that years ago. My interest is in making it work everywhere, for example from a locate or a find-file completion session, or from a bookmark etc. –  abo-abo 5 hours ago
add a comment


I stopped using openwith when I started using Helm, as I find typing C-c C-x from helm-find-files convenient enough. (Also nowadays, I only unconditionally open audio and video files outside of Emacs, so most of the time I like being able to either open a file in Emacs or in an external program.)

** openwith

#+BEGIN_QUOTE
;; (use-package openwith)
(openwith-mode t)
(setq openwith-associations '(("\\.pdf\\'" "Skim.app" (file))))
#+END_QUOTE
Source: [[http://emacs.stackexchange.com/questions/3105/how-to-use-an-external-program-as-the-default-way-to-open-pdfs-from-emacs][find file - How to use an external program as the default way to open PDFs from Emacs? - Emacs Stack Exchange]]

** PDF-tools

[[http://emacs.stackexchange.com/questions/3105/how-to-use-an-external-program-as-the-default-way-to-open-pdfs-from-emacs][find file - How to use an external program as the default way to open PDFs from Emacs? - Emacs Stack Exchange]]

http://tuhdo.github.io/static/emacs-read-pdf.gif

** defun syntax
A Lisp function becomes a [[command]] when its body contains, at top level, a form that calls the special form `<code>(interactive...)</code>'. This special form does nothing when executed, but its presence in the function definition indicates that interactive calling is permitted. Its argument controls the reading of the function arguments in an interactive call.

*** Here is a simple example defining a command that displays a message:

#+BEGIN_SRC emacs-lisp
(defun hello ()
      "Hello World and you can call it via M-x hello."
      (interactive)
      (message "Hello World!"))
#+END_SRC

*** Example of a command that reads a string argument:

#+BEGIN_SRC emacs-lisp
(defun hello (someone)
      "Say hello to SOMEONE via M-x hello."
      (interactive "sWho do you want to say hello to? ")
      (message "Hello %s!" someone))
#+END_SRC

*** To use multiple arguments, separate their `interactive' entries with a newline:

#+BEGIN_SRC emacs-lisp
(defun multiple-hello (someone num)
      "Say hello to SOMEONE via M-x hello, for NUM times."
      (interactive "sWho do you want to say hello to? \nnHow many times? ")
      (dotimes (i num)
        (insert (format "Hello %s!\n" someone))))
#+END_SRC

Instead of passing a literal string argument to `interactive', you can pass it an EmacsLisp [[sexp]] that is evaluated when the [[command]] is called, to produce a list of the actual arguments.

This is useful when you need to do more than is offered by the predefined `interactive' string constructs.

To get the effect of the string constructs `P' and `p', respectively, use [[variable]] `current-prefix-arg' and function `prefix-numeric-value' applied to that variable.

To get the effect of `interactive' string codes that read user input, use Lisp functions that read input, such as `read-buffer', `read-string', and `completing-read'.

The following pairs of `interactive' specs are equivalent:

  (defun bar (arg)
    (interactive "p")
    ...)

  (defun bar (arg)
    (interactive
      (list (prefix-numeric-value current-prefix-arg))
    ...)

  (defun foo (arg buf)
    (interactive "P\nbBuffer: ")
    ...)

  (defun foo (arg buf)
    (interactive
      (list current-prefix-arg
            (read-buffer "Buffer: " (current-buffer) t)))
    ...)





* lisp functions from John Kitchin
:PROPERTIES:
:ARCHIVE_TIME: 2023-02-27 Mon 00:42
:ARCHIVE_FILE: ~/emacs/emacs-settings/gnu-emacs-startup.org
:ARCHIVE_CATEGORY: gnu-emacs-startup
:END:
** helm actions when there is no match

Sometimes you run out of matches in a helm selection buffer, and all that is left is the pattern you have typed in. It turns out you can perform some action on that pattern! Why would you do that? Suppose you are searching your bibliography, and you do not find what you are looking for. Then, you may want to send the pattern to Google, or some other search engine to see what comes up.

The key to handling this situation is to use /two/ sources in your helm session. One that works on the candidates and deals with actions on them, and one that has no candidates, and works on the pattern. The variable helm-pattern contains what you typed in. We call the second source the Fallback option. The second source has no candidates, and we use (dummy) in place of the candidates.

It easy to add two sources. Here we define the sources as variables, and use the variables in the :sources list to the helm command.

# #+BEGIN_EXAMPLE emacs-lisp
(defun some-action (arg)
  (message-box "%s\n%s"
    (helm-get-selection)
    (helm-marked-candidates)))

(defun default-action (candidate)
  (browse-url
   (format
    "http://www.google.com/search?q=%s" (url-hexify-string helm-pattern))))

(defvar source1 '((name . "HELM")
		  (candidates . (1 2 3 4))
		  (action . (("open" . some-action)))))

(defvar fallback-source '((name . "fallback")
			  (dummy)
			  (action . (("Google" . default-action)))))

(helm :sources '(source1 fallback-source))
# #+END_EXAMPLE

#+RESULTS:
: #<process open http://www.google.com/search?q=addtion%20pul>

When you run this, if you run out of search candidates, all that will be left is the fallback option, and when you press enter, it will launch a browser pointing to the google search for your pattern.

Source: [[http://kitchingroup.cheme.cmu.edu/blog/2015/02/02/helm-actions-when-there-is-no-match/][ helm actions when there is no match]]

** how to write helm functions
   [[http://wikemacs.org/wiki/How_to_write_helm_extensions][How to write helm extensions - WikEmacs]]
   [[http://kitchingroup.cheme.cmu.edu/blog/2015/01/24/Anatomy-of-a-helm-source/][Anatomy of a helm source]]


** dwiw-auto-capitalize
I have been using auto-capitalize.el for a short time to automatically capitalize the beginning of sentences. I mostly like what it does, but in org-mode I tend to write short code blocks while still in org-mode, and it is pretty irritating for auto-capitalize to "fix" the capitalization of your code. Of course, I can type C-c ' to edit the block in its native mode, but I do not always want to do that.

Below, I illustrate an approach to turn off auto-capitalize-mode when the cursor is inside a code-block. Basically, we write a function that checks if you are in a src-block, and if auto-capitalize is on, turn it off. If you are not in the code-block, we turn auto-capitalize on if it is not on. Then we hook the function into post-command-hook, which will run it after every emacs command, including cursor movements.

Here is that code:
#+BEGIN_EXAMPLE emacs-lisp
(defun dwiw-auto-capitalize ()
  (if (org-in-block-p '("src"))
      (when auto-capitalize
	(auto-capitalize-mode -1))
    (unless auto-capitalize
      (auto-capitalize-mode 1))))

;; (add-hook 'post-command-hook dwiw-auto-capitalize)
#+END_EXAMPLE

#+RESULTS:
| dwiw-auto-capitalize |

It works! Now the minor mode turns on and off depending on where the cursor is in my org document.

Source: [[http://kitchingroup.cheme.cmu.edu/blog/2014/12/03/Selective-auto-capitalization-in-org-buffers/][auto capitalization in org buffers]]

** Better integration of org-mode and email
I like to email org-mode headings and content to people. It would be nice to have some records of when a heading was sent, and to whom. We store this information in a heading. It is pretty easy to write a simple function that emails a selected region.

#+BEGIN_EXAMPLE emacs-lisp
(defun email-region (start end)
  "Send region as the body of an email."
  (interactive "r")
  (let ((content (buffer-substring start end)))
    (compose-mail)
    (message-goto-body)
    (insert content)
    (message-goto-to)))
#+END_EXAMPLE

that function is not glamorous, and you still have to fill in the email fields, and unless you use gnus and org-contacts, the only record keeping is through the email provider.

What I would like is to send a whole heading in an email. The headline should be the subject, and if there are TO, CC or BCC properties, those should be used. If there is /no TO/, then I want to grab the TO from the email after you enter it and store it as a property. You should be able to set OTHER-HEADERS as a property (this is just for fun. There is no practical reason for this yet). After you send the email, it should record in the heading when it was sent.

It turned out that is a relatively tall order. While it is easy to setup the email if you have everything in place, it is tricky to get the information on TO and the time sent /after/ the email is sent. Past lispers had a lot of ideas to make this possible, and a day of digging got me to the answer. You can specify some "action" functions that get called at various times, e.g. after sending, and a return action when the compose window is done. Unfortunately, I could not figure out any way to do things except to communicate through some global variables.

So here is the code that lets me send org-headings, with the TO, CC, BCC properties, and that records when I sent the email after it is sent.

#+BEGIN_EXAMPLE emacs-lisp
(defvar *email-heading-point* nil
  "global variable to store point in for returning")

(defvar *email-to-addresses* nil
  "global variable to store to address in email")

(defun email-heading-return ()
  "after returning from compose do this"
  (switch-to-buffer (marker-buffer  *email-heading-point*))
  (goto-char (marker-position  *email-heading-point*))
  (setq *email-heading-point* nil)
  (org-set-property "SENT-ON" (current-time-string))
  ;; reset this incase you added new ones
  (org-set-property "TO" *email-to-addresses*)
  )

(defun email-send-action ()
  "send action for compose-mail"
  (setq *email-to-addresses* (mail-fetch-field "To")))

(defun email-heading ()
  "Send the current org-mode heading as the body of an email, with headline as the subject.

use these properties
TO
OTHER-HEADERS is an alist specifying additional
header fields.  Elements look like (HEADER . VALUE) where both
HEADER and VALUE are strings.

save when it was sent as s SENT property. this is overwritten on
subsequent sends. could save them all in a logbook?
"
  (interactive)
  ; store location.
  (setq *email-heading-point* (set-marker (make-marker) (point)))
  (org-mark-subtree)
  (let ((content (buffer-substring (point) (mark)))
	(TO (org-entry-get (point) "TO" t))
	(CC (org-entry-get (point) "CC" t))
	(BCC (org-entry-get (point) "BCC" t))
	(SUBJECT (nth 4 (org-heading-components)))
	(OTHER-HEADERS (eval (org-entry-get (point) "OTHER-HEADERS")))
	(continue nil)
	(switch-function nil)
	(yank-action nil)
	(send-actions '((email-send-action . nil)))
	(return-action '(email-heading-return)))

    (compose-mail TO SUBJECT OTHER-HEADERS continue switch-function yank-action send-actions return-action)
    (message-goto-body)
    (insert content)
    (when CC
      (message-goto-cc)
      (insert CC))
    (when BCC
      (message-goto-bcc)
      (insert BCC))
    (if TO
	(message-goto-body)
      (message-goto-to))
    ))
#+END_EXAMPLE

This works pretty well for me. Since I normally use this to send tasks to people, it keeps the task organized where I want it, and I can embed an org-id in the email so if the person replies to it telling me the task is done, I can easily navigate to the task to mark it off. Pretty handy.

Source: [[http://kitchingroup.cheme.cmu.edu/blog/2014/06/08/Better-integration-of-org-mode-and-email/][better integration of org-mode and email]]



* Helm Org Wiki
:PROPERTIES:
:ARCHIVE_TIME: 2023-02-27 Mon 00:43
:ARCHIVE_FILE: ~/emacs/emacs-settings/gnu-emacs-startup.org
:ARCHIVE_CATEGORY: gnu-emacs-startup
:END:

I'm using an extremely simplistic approach: just dump all the org
files into one directory.  The name of each org file should be concise
but descriptive, e.g. Makefile.org describes Makefiles, and git.org
describes git.

This simplicity completely alleviates organization effort: there's
nothing to organize, since there's only one directory to put the files in.
At the same time, it's very accessible by means of two `helm` wrappers:

- globally, "C-0" runs the command helm-org-wiki (the code is below)
- in org-mode, "g" runs the command wspecial-worf-goto (the code is at
https://github.com/abo-abo/worf)

It's like a two-stage personal Google: the first stage is to find an org-file,
the second stage is to search within an org-file.

For example, here's the sequence of key bindings when I want to look
up how git bisect works, assuming that I'm in some random buffer, like
`ansi-term`:

        C-0 gi RET g bis RET

Done. Note that "gi" was enough to match "git.org", since all my other
pages don't contain "gi".  Same thing for "bis" being able to match
uniquely the heading "git bisect".  I think that it's quite optimal
that I'm able to find the topic "git bisect" by using only 10 key
presses, which is the same as the amount of characters in "git
bisect".  Compare this to `helm-google-suggest` (bound to "C-p g"):

        C-p g git bi RET TAB RET

That's 12 key presses (10 in Emacs, 2 in Firefox).

New wiki pages can be created with "C-0" as well, just type in the
name of the new file and hit RET.

That's it, the code is below. It's very similar to `org-switchb`,
except that the files need not be opened to appear in the completion
list, and new files are created if there's no match.

regards,
Oleh
(Source: http://lists.gnu.org/archive/html/emacs-orgmode/2014-04/msg01134.html)

#+BEGIN_EXAMPLE emacs-lisp
    (defgroup helm-org-wiki nil
      "Simple jump-to-org-file package."
      :group 'org
      :prefix "helm-org-wiki-")
    (defcustom helm-org-wiki-directory "~/nd/"
      "Directory where files for `helm-org-wiki' are stored."
      :group 'helm-org-wiki
      :type 'directory)
    (defun helm-org-wiki-files ()
      "Return .org files in `helm-org-wiki-directory'."
      (let ((default-directory helm-org-wiki-directory))
        (mapc #'file-name-sans-extension
                (file-expand-wildcards "*.txt"))))
    (defvar helm-source-org-wiki
      `((name . "Projects")
        (candidates . helm-org-wiki-files)
        (action . ,(lambda (x)
                      (find-file (expand-file-name
                                  (format "%s.txt" x)
                                  helm-org-wiki-directory))))))
    (defvar helm-source-org-wiki-not-found
      `((name . "Create org-wiki")
        (dummy)
        (action . (lambda (x)
                    (helm-switch-to-buffer
                     (find-file
                      (format "%s/%s.org"
                              helm-org-wiki-directory x)))))))
    ;;;###autoload
    (defun helm-org-wiki ()
      "Select an org-file to jump to."
      (interactive)
      (helm :sources
            '(helm-source-org-wiki
              helm-source-org-wiki-not-found)))
    (provide 'helm-org-wiki)

#+END_EXAMPLE



* Emacs Lisp Mode
:PROPERTIES:
:ARCHIVE_TIME: 2023-02-27 Mon 00:43
:ARCHIVE_FILE: ~/emacs/emacs-settings/gnu-emacs-startup.org
:ARCHIVE_CATEGORY: gnu-emacs-startup
:END:
#+BEGIN_EXAMPLE emacs-lisp
(defun turn-on-autocomplete-mode ()
   (auto-complete-mode 1))
(add-hook 'emacs-lisp-mode-hook 'turn-on-autocomplete-mode )
#+END_EXAMPLE


* smex
:PROPERTIES:
:ARCHIVE_TIME: 2023-02-27 Mon 00:45
:ARCHIVE_FILE: ~/emacs/emacs-settings/gnu-emacs-startup.org
:ARCHIVE_CATEGORY: gnu-emacs-startup
:END:
#+BEGIN_SRC emacs-lisp
;; (use-package smex)
;; (setq smex-completion-method 'ivy)
#+END_SRC



* keep cursor at same position when scrolling
:PROPERTIES:
:ARCHIVE_TIME: 2023-02-27 Mon 00:45
:ARCHIVE_FILE: ~/emacs/emacs-settings/gnu-emacs-startup.org
:ARCHIVE_CATEGORY: gnu-emacs-startup
:END:
#+BEGIN_EXAMPLE
(setq scroll-preserve-screen-position 1)
;;scroll window up/down by one line
(define-key key-minor-mode-map (kbd "M-n") (kbd "C-u 1 C-v"))
(define-key key-minor-mode-map (kbd "M-p") (kbd "C-u 1 M-v"))

#+END_EXAMPLE


* email stuff
:PROPERTIES:
:ARCHIVE_TIME: 2023-02-27 Mon 00:46
:ARCHIVE_FILE: ~/emacs/emacs-settings/gnu-emacs-startup.org
:ARCHIVE_CATEGORY: gnu-emacs-startup
:END:
** save buffer to sent-emails-org-file
#+BEGIN_SRC emacs-lisp
(defvar *sent-emails-org-file* "/Users/jay/Dropbox/writing/notationaldata/sent-emails.org")

(defun save-buffer-to-sent-emails-org-file ()
  ;; header

(write-region
   (concat "\n\n\n* "
(format-time-string "%F %l:%M%P\n\n")
           "\n\n")
   0 *sent-emails-org-file* t)
  ;; buffer
  (write-region nil 0 *sent-emails-org-file* t))
#+END_SRC

** send message without bullets
#+BEGIN_SRC emacs-lisp
(defun send-message-without-bullets ()
  (interactive)
  (remove-hook 'org-mode-hook 'org-bullets-mode)
;; (notmuch-mua-send-and-exit)
(message-send-and-exit)
  (add-hook 'org-mode-hook 'org-bullets-mode))

(add-hook 'message-mode-hook
          (lambda ()
            (local-set-key "\C-c\C-c" 'send-message-without-bullets)
            (local-set-key "\C-c\C-l" 'org-insert-link)
))

#+END_SRC

** sign current email
#+BEGIN_SRC emacs-lisp
(defvar *mail-signature* "\n---\nJay Dixit\n(646) 355-8001\njaydixit.com")

(defun sign-current-email ()
  (save-excursion
    (end-of-buffer)
    (insert *mail-signature*)))
#+END_SRC

** custom-send-message
#+BEGIN_SRC emacs-lisp
(defun custom-send-message (arg)
  (interactive "p")
  (when (and arg (= 0 (mod arg 4)))
    (sign-current-email))
  (save-buffer-to-sent-emails-org-file)
  (send-message-without-bullets))
#+END_SRC


* orgalist-mode-map
:PROPERTIES:
:ARCHIVE_TIME: 2023-02-27 Mon 00:46
:ARCHIVE_FILE: ~/emacs/emacs-settings/gnu-emacs-startup.org
:ARCHIVE_CATEGORY: gnu-emacs-startup
:END:

#+BEGIN_EXAMPLE emacs-lisp
(define-key orgalist-mode-map (kbd "<M-return>") 'smart-org-meta-return-dwim)
(define-key mu4e-compose-mode-map (kbd "<M-return>") 'smart-org-meta-return-dwim)
; (define-key orgalist-mode-map (kbd "<return>") 'message-mode-smart-return)
(define-key orgalist-mode-map (kbd "\C-c\C-c") 'custom-send-message)
(define-key mu4e-compose-mode-map (kbd "\C-c\C-c") 'custom-send-message)


(define-key orgalist-mode-map (kbd "C-c .") 'org-time-stamp)

#+END_EXAMPLE


* message-mode-map
:PROPERTIES:
:ARCHIVE_TIME: 2023-02-27 Mon 00:46
:ARCHIVE_FILE: ~/emacs/emacs-settings/gnu-emacs-startup.org
:ARCHIVE_CATEGORY: gnu-emacs-startup
:END:
#+BEGIN_EXAMPLE emacs-lisp
(add-hook 'message-mode-hook
          (lambda ()
            (local-set-key "\C-c\C-c" 'custom-send-message)
; (local-set-key (kbd "<return>") 'orgalist-mode-smart-return)
))
#+END_EXAMPLE



* fountain-mode-map
:PROPERTIES:
:ARCHIVE_TIME: 2023-02-27 Mon 00:46
:ARCHIVE_FILE: ~/emacs/emacs-settings/gnu-emacs-startup.org
:ARCHIVE_CATEGORY: gnu-emacs-startup
:END:
#+BEGIN_EXAMPLE emacs-lisp
(add-hook 'fountain-mode-hook
     (lambda ()
(local-set-key (kbd ".") 'smart-period)
(local-set-key (kbd ",") 'smart-comma)
(local-set-key (kbd "\`") 'flyspell-auto-correct-word)
(local-set-key (kbd "<SPC>") 'smart-space)


))
#+END_EXAMPLE



* reformat email
:PROPERTIES:
:ARCHIVE_TIME: 2023-02-27 Mon 00:46
:ARCHIVE_FILE: ~/emacs/emacs-settings/gnu-emacs-startup.org
:ARCHIVE_CATEGORY: gnu-emacs-startup
:END:
#+BEGIN_SRC emacs-lisp
(defun reformat-email (begin end)
  (interactive "r")
(xah-replace-pairs-region begin end
 '(
 ["> " ""]
))
  (unfill-region begin end)
  (fill-region begin end)
  (xah-replace-pairs-region begin end
 '(
 ["\n" "\n> "]
)))

#+END_SRC




* pandoc
:PROPERTIES:
:ARCHIVE_TIME: 2023-02-27 Mon 01:02
:ARCHIVE_FILE: ~/emacs/emacs-settings/gnu-emacs-startup.org
:ARCHIVE_CATEGORY: gnu-emacs-startup
:END:
   [[http://kitchingroup.cheme.cmu.edu/blog/2014/07/17/Pandoc-does-org-mode-now/][org-mode does pandocc and word now! ]]


* Reference for cleaning up whitespace around sentences:
:PROPERTIES:
:ARCHIVE_TIME: 2023-02-27 Mon 01:02
:ARCHIVE_FILE: ~/emacs/emacs-settings/gnu-emacs-startup.org
:ARCHIVE_CATEGORY: gnu-emacs-startup
:END:
[[http://stackoverflow.com/questions/4754547/redefining-sentence-in-emacs-single-space-between-sentences-but-ignoring-ab][regex - Redefining "sentence" in Emacs? (single space between sentences, but ignoring abbreviations) - Stack Overflow]]


* display file name
:PROPERTIES:
:ARCHIVE_TIME: 2023-02-27 Mon 01:02
:ARCHIVE_FILE: ~/emacs/emacs-settings/gnu-emacs-startup.org
:ARCHIVE_CATEGORY: gnu-emacs-startup
:END:
How can I modify the titlebar to contain the current file name?

The contents of an Emacs frame's titlebar is controlled by the variable frame-title-format, which has the same structure as the variable mode-line-format. (Use C-h v or M-x describe-variable to get information about one or both of these variables.)

By default, the titlebar for a frame does contain the name of the buffer currently being visited, except if there is a single frame. In such a case, the titlebar contains Emacs invocation name and the name of the machine at which Emacs was invoked. This is done by setting frame-title-format to the default value of

(multiple-frames "%b" ("" invocation-name "@" system-name))
To modify the behavior such that frame titlebars contain the buffer's name regardless of the number of existing frames, include the following in your .emacs:


#+BEGIN_SRC emacs-lisp
;; (setq frame-title-format (concat "Hey bro, just FYI, this file is called %b or something like that."))
;; Changing this for Hook app compatibility per https://discourse.hookproductivity.com/t/integrating-emacs-and-hook-with-org-mode/932/5
#+END_SRC


* new stuff / experimental
:PROPERTIES:
:ARCHIVE_TIME: 2023-02-27 Mon 01:03
:ARCHIVE_FILE: ~/emacs/emacs-settings/gnu-emacs-startup.org
:ARCHIVE_CATEGORY: gnu-emacs-startup
:END:
#+BEGIN_SRC emacs-lisp

;; Also auto refresh dired, but be quiet about it
;; (setq global-auto-revert-non-file-buffers t)
;; (setq auto-revert-verbose nil)


;; Move files to trash when deleting
(setq delete-by-moving-to-trash t)
#+END_SRC


