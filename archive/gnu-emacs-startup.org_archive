
Archived entries from file /Users/jay/Dropbox/emacs/prelude/personal/gnu-emacs-startup.org


* DONE in pasteboard-paste above, modify so that it will remove extra whitespace BEFORE pasted word :rudi:
  :PROPERTIES:
  :ARCHIVE_TIME: 2015-05-29 Fri 23:23
  :ARCHIVE_FILE: ~/Dropbox/emacs/prelude/personal/gnu-emacs-startup.org
  :ARCHIVE_OLPATH: Isolate Emacs kill ring from the OSX system pasteboard (clipboard).
  :ARCHIVE_CATEGORY: gnu-emacs-startup
  :END:



: Lorem ipsum.

e.g. in the example above, if I place the point on the "i" in "ipsum" and then paste the string " dolor sit amet" including the initial space in the string, I should get...

...this:
: Lorem dolor sit amet ipsum.

...NOT this:

: Lorem  dolor sit amet ipsum.

;;; old version; remove after testing new one (see below)
;; (defun pasteboard-paste()
;;   "Paste from OS X system pasteboard via `pbpaste' to point."
;;   (interactive)
;; (my/fix-space)
;;   (shell-command-on-region
;;    (point) (if mark-active (mark) (point)) "pbpaste | perl -p -e 's/\r$//' | tr '\r' '\n'" nil t)
;; (my/fix-space)
;; ;; (when (looking-back "^[[:space:]]+") (just-one-space)) ; this didn't work
;; )

;;; new version; not thoroughly tested
(defun pasteboard-paste ()
  "Paste from OS X system pasteboard via `pbpaste' to point."
  (interactive)
  (let ((start (point))
        (end (if mark-active
                 (mark)
               (point))))
    (shell-command-on-region start end
                             "pbpaste | perl -p -e 's/\r$//' | tr '\r' '\n'"
                             nil t)
    (my/fix-space)
    (save-excursion
      (goto-char start)
      (my/fix-space))))




* DONE in pasteboard-paste above, modify so that it will remove extra whitespace BEFORE pasted word :rudi:
  :PROPERTIES:
  :ARCHIVE_TIME: 2015-05-29 Fri 23:23
  :ARCHIVE_FILE: ~/Dropbox/emacs/prelude/personal/gnu-emacs-startup.org
  :ARCHIVE_OLPATH: Isolate Emacs kill ring from the OSX system pasteboard (clipboard).
  :ARCHIVE_CATEGORY: gnu-emacs-startup
  :END:



: Lorem ipsum.

e.g. in the example above, if I place the point on the "i" in "ipsum" and then paste the string " dolor sit amet" including the initial space in the string, I should get...

...this:
: Lorem dolor sit amet ipsum.

...NOT this:

: Lorem  dolor sit amet ipsum.

;;; old version; remove after testing new one (see below)
;; (defun pasteboard-paste()
;;   "Paste from OS X system pasteboard via `pbpaste' to point."
;;   (interactive)
;; (my/fix-space)
;;   (shell-command-on-region
;;    (point) (if mark-active (mark) (point)) "pbpaste | perl -p -e 's/\r$//' | tr '\r' '\n'" nil t)
;; (my/fix-space)
;; ;; (when (looking-back "^[[:space:]]+") (just-one-space)) ; this didn't work
;; )

;;; new version; not thoroughly tested
(defun pasteboard-paste ()
  "Paste from OS X system pasteboard via `pbpaste' to point."
  (interactive)
  (let ((start (point))
        (end (if mark-active
                 (mark)
               (point))))
    (shell-command-on-region start end
                             "pbpaste | perl -p -e 's/\r$//' | tr '\r' '\n'"
                             nil t)
    (my/fix-space)
    (save-excursion
      (goto-char start)
      (my/fix-space))))




* TODO can you help me fix this function?                              :rudi:
  :PROPERTIES:
  :ARCHIVE_TIME: 2015-06-07 Sun 22:17
  :ARCHIVE_FILE: ~/Dropbox/emacs/prelude/personal/gnu-emacs-startup.org
  :ARCHIVE_OLPATH: Custom functions/BACKWARD kill word correctly
  :ARCHIVE_CATEGORY: gnu-emacs-startup
  :ARCHIVE_TODO: TODO
  :END:

Take a look at the function kill-word-correctly above. I made it so that kill-word-correctly counts punctuation such as , . ; ? ! as a word.

: The quick brown brown, fox jumped.

In the example above, f I place the point on the "b" in the second instance of "brown", and then do kill-word-correctly TWICE, it first deletes the word brown, and THEN deletes the unwanted comma.

I want to do the same for backward-kill-word-correctly.

Now take this example:
: The quick brown, fox ^ fox jumped.

Goal:
Suppose the point is at the ^ caret above. I want to be able to invoke backward-kill-word-correctly, TWICE, such that...

...the first invocation should result in this:
: The quick brown, fox jumped.

...and second invocation should then delete the comma and fix the space so the result is this:
: The quick brown fox jumped.

*** DONE In the example above, is the caret part of the string, or just there to mark point? :followup:

    The point of this question is that, in case it is part of the string, the
    first invocation deletes it, so it is not entirely a "backward" kill.  I
    think the semantics can get a bit convoluted here.
*** DONE Clarification: The caret is NOT part of the string.

Sorry, maybe a better way to phrase it would be as follows:

Take the example below...

: The quick brown, fox fox jumped.

...and suppose the point is on the space between the first "fox" and the second one, or on the "f" in the second "fox".

I want to be able to invoke backward-kill-word-correctly, TWICE, such that it first deletes the word, then deletes the comma (but leaves one space) such that the result is this:

: The quick brown fox jumped.

Thanks!!

*** DONE More follow-up questions                             :answer:rudi:

     - When you say that you want to invoke the command twice and have that
       behaviour, are you expecting it to keep some sort of memory?

: No. No memory.

 Or, on the contrary, should the second invocation in your example kill *just* the comma regardless of the first invocation?

: Yes. Basically I just want punctuation (,.:;!?) to be considered a word when I do backward-kill-word-correctly.

I will implement it like that (no memory) since not only it is the more logical to me, but also it should be easily adaptable if you originally intended a different semantics.

: Great! It appears to be working as I intended.


        - ~backward-kill-word~ affects the kill-ring, adding or appending the
          killed text to it.  Do you want to keep the same semantics?  In your
          example above, after invoking ~backward-kill-word-correctly~ twice, the
          kill-ring's last entry would have the string ", fox ".  I'm asking since
          your implementation of ~kill-word-correctly~ does indeed lose this
          semantics, since ~delete-forward-char~ does not affect the kill-ring
          (neither does ~my/fix-space~, by the way).

: No need to keep the comma once it is out of its context. The kill ring could have just "fox" if this is easy to implement. If it's time consuming then don't worry about it.

**** TODO Reply

      Well, it does complicate things a bit, and the semantics anyway seem clearer to me if the kill-ring contains all the killed text, including punctuation. Take your example:

: The quick brown, fox fox^ jumped.

      If I kill everything consecutively down to the comma, the kill-ring would keep "fox fox". However, if I would kill everything down to "brown", we'd probably want "brown, fox fox" to end up in the kill-ring - and that includes the comma. This behaviour is non-trivial.

      I will thus leave it as it is (include the killed punctuation in the kill-ring).

:


* DONE New note about the abbrevs file                                 :rudi:
  :PROPERTIES:
  :ARCHIVE_TIME: 2015-06-16 Tue 14:06
  :ARCHIVE_FILE: ~/Dropbox/emacs/prelude/personal/gnu-emacs-startup.org
  :ARCHIVE_CATEGORY: gnu-emacs-startup
  :END:
Rúdi: As you can see from my abbrevs file, it contains two main kinds of abbrevs:

1. Typographical error corrections

Ghandi → Gandhi

#+BEGIN_EXAMPLE
("Ghandi" "Gandhi" nil 0)
#+END_EXAMPLE

These get created automatically through some code I found here:
[[http://endlessparentheses.com/ispell-and-abbrev-the-perfect-auto-correct.html][Emacs, Ispell and Abbrev, the Perfect Auto-Correct]]

2. Expansion of text shortcuts

bc → because

#+BEGIN_EXAMPLE
("bc" "because" nil 455)
#+END_EXAMPLE

These are my way of making typing faster, by creating text shortcuts that automatically expand into the full form of the word. These are all between 1 and 4 characters long, and expand to form longer words.

For ONLY the #2 "expansion of text shortcuts", I would like to:
- [X] separate these out into their own separate abbrevs file, which I can then open-source on Github and share with other Emacs users, and
- [X] also convert them to TextExpander format, which I can also open-source share with other people.

Basically I want to offer these expansions in two formats.

That's my goal for this latest task. Does that make sense?

Thanks,
Jay


* DONE [#A] a different kind of request
  :PROPERTIES:
  :ARCHIVE_TIME: 2015-06-16 Tue 14:06
  :ARCHIVE_FILE: ~/Dropbox/emacs/prelude/personal/gnu-emacs-startup.org
  :ARCHIVE_CATEGORY: gnu-emacs-startup
  :END:
Hi Rúdi,

Here's a different kind of request. If you're interested, maybe we could make it the top priority. However, it's not strictly speaking hacking in elisp, so feel free to turn it down if it doesn't interest you and we can just proceed with the Emacs functions.

I'd like to make some of my many Emacs abbrevs shortcuts available in other applications. On my Mac OSX, I use an app called TextExpander to expand text. So I'd like to convert my abbrevs file to TextExpander format.

This task involves programmatically converting an abbrevs file, which looks something like this:

#+BEGIN_QUOTE
(define-abbrev-table 'global-abbrev-table '(
 ("qo" "without" nil 1)
 ("ty" "they" nil 3)
 ("tyr" "they're" nil 5)
))
#+END_QUOTE

...into a TextExpander file, which looks something like this:

#+BEGIN_QUOTE
<dict>
			<key>abbreviation</key>
			<string>qo</string>
			<key>abbreviationMode</key>
			<integer>2</integer>
			<key>creationDate</key>
			<date>2015-06-11T01:04:09Z</date>
			<key>flags</key>
			<integer>0</integer>
			<key>label</key>
			<string></string>
			<key>lastUsed</key>
			<date>2015-06-11T01:05:05Z</date>
			<key>modificationDate</key>
			<date>2015-06-11T01:04:14Z</date>
			<key>plainText</key>
			<string>without</string>
			<key>snippetType</key>
			<integer>0</integer>
			<key>useCount</key>
			<integer>0</integer>
			<key>uuidString</key>
			<string>12D393EE-F929-4F9B-AFF6-F43D718E8048</string>
		</dict>
		<dict>
			<key>abbreviation</key>
			<string>ty</string>
			<key>abbreviationMode</key>
			<integer>2</integer>
			<key>creationDate</key>
			<date>2015-06-11T01:03:06Z</date>
			<key>flags</key>
			<integer>0</integer>
			<key>label</key>
			<string></string>
			<key>modificationDate</key>
			<date>2015-06-11T01:03:06Z</date>
			<key>plainText</key>
			<string>they</string>
			<key>snippetType</key>
			<integer>0</integer>
			<key>useCount</key>
			<integer>0</integer>
			<key>uuidString</key>
			<string>6341B244-BC48-48B9-8E1E-ABAF34C44BC3</string>
		</dict>
		<dict>
			<key>abbreviation</key>
			<string>tyr</string>
			<key>abbreviationMode</key>
			<integer>2</integer>
			<key>creationDate</key>
			<date>2015-06-11T01:03:02Z</date>
			<key>flags</key>
			<integer>0</integer>
			<key>label</key>
			<string></string>
			<key>lastUsed</key>
			<date>2015-06-11T01:03:31Z</date>
			<key>modificationDate</key>
			<date>2015-06-11T01:03:02Z</date>
			<key>plainText</key>
			<string>they're</string>
			<key>snippetType</key>
			<integer>0</integer>
			<key>useCount</key>
			<integer>0</integer>
			<key>uuidString</key>
			<string>A1A1B41E-B8BF-4562-B977-143419E30695</string>
		</dict>
#+END_QUOTE

Let me know if this interests you, and if so, I'll send you my abbrev file. Again, if not, no worries. Thanks!
** DONE Request for clarification                            :followup:

   Sure, I'll handle it. It sure is just hacking elisp...

: Excellent. :-)

   Here's my proposal: a new function, say ~abbrev-table-export-to-text-expander~, which prompts you for the abbrev table name, and creates a new buffer with the result of converting to TextExpander, which you then can save in the location you desire. Does that look good?

: It would be cool if I could just export all my existing abbrevs. Here's what I would like to do: export all my abbrevs where the abbrev is 4 characters or less. No confirmation, no prompt.
: e.g. ehrs → behaviors
: anything longer than that, I don't need to export to TextExpander.
: Is this feasible?

   Now, before I start, a question: is there information about the file format? I cannot deduce the meaning of all XML tags in your example. I have searched the web for the format, to no available.

: Good question. The format is called TextExpander for OSX.

http://smilesoftware.com/help/TextExpander/creating.html

http://brettterpstra.com/2013/01/04/mass-creating-textexpander-snippets/

http://smilesoftware.com/help/TextExpander%204%20Help.pdf

http://smilesoftware.com/help/TextExpander/groups.html

Take a look and let me know whether that's helpful. If not you may ask a question on StackExchange? Or if not I can contact Smile support.

Thank you! Let me know.

Thanks,
Jay

* DONE Request
  :PROPERTIES:
  :ARCHIVE_TIME: 2015-06-16 Tue 16:48
  :ARCHIVE_FILE: ~/Dropbox/emacs/prelude/personal/gnu-emacs-startup.org
  :ARCHIVE_CATEGORY: gnu-emacs-startup
  :END:
For the above whitespace and sentence functions, can we make it so that Emacs will recognize three hyphens in a row---as punctuation same as a comma?

** DONE Request for clarification

   Not sure which functions you mean. The ones in the "Sentences" Heading?
** DONE Answer
- my/fix-space
- kill-clause
- my-delete-backward
- kill-word-correctly
- backward-kill-word-correctly

Basically I'd like to make it so that org-mode treats --- as a singles punctuation mark in any function that looks for :punct:

*** Example
Take a look at the function kill-word-correctly. I want it so that kill-word-correctly counts --- as a word.

Take this sentence below:

: The quick brown fox jumped---jumped high.

In the sentence above, if I place the point on the "h" in "high" and then do kill-word-correctly TWICE, it should first delete the word jumped and fix the space, and THEN on the second invocation, it should deletes the unwanted --- and fix the space.

So the first invocation should result in this:

: The quick brown fox jumped---high.

...and second invocation should then delete the --- and fix the space so the result is this:

: The quick brown fox jumped high.

Thanks!

*** DONE Note & question

    OK. But it is not straightforward. You see, [:punct:] denotes a set of characters; --- a *sequence* of characters. It is not simply a case of changing the meaning of [:punct:]. I don't see a way to do it other than changing each function individually.

    However, according to the syntax table of my org-mode, - is considered a punctuation. So if I ~kill-word-correctly~ over "open-source" (point on 'o'), I then get "-source", and if I do it again, I get "source". Is that the same for you?

: Yes it is.

    If that is the case, then would killing all *consecutive* punctuation marks cover this case? What about "--", "?!", "...?" (and possibly other consecutive punctuation marks, like "--," - some authors like that style)? They would also be killed completely. Is that according to your requirements?

: Yes, automatically killing all consecutive punctuation in cases like "---" "--", "?!", and "...?" would certainly be according to my requirements. So yes, I think that solves the problem! Thank you!

** DONE More questions

   - ~my/fix-space~
     - What should be the difference here?

: The difference is that there should be a space after ; : , ? ! or . but no space after ---
*or after -*

   - ~kill-clause~
     - Since this is already sensitive to --, it should also be sensitive to ---. It should also be sensitive to other sequences of punctuation marks. Let me know otherwise.

: Excellent.

   - ~my/delete-backward~
     - Again, I don't think this requires any change. It deletes all spaces when it is looking at a punctuation mark. Since - is a punctuation mark, any space before --- will also be deleted.

: Correct. I think the difference is the space following ---

     - Note: there were two versions of ~my/delete-backward~; I assumed the first one was a failed attempt to give it some ability to get rid of extra whitespaces, so I took the liberty of adding that functionality. So, what it does is the following: after deleting the region or character, checks if immediately before or after the point there is a space, and if that is the case, uses ~my/fix-space~. Does this behaviour make sense to you?

   - ~kill-word-correctly~ & ~backward-kill-word-correctly~
     - Regarding these two functions, I have added new versions of them. Note however that they tend to fsck up the kill-ring, because of their calls to ~my/fix-space~. This already occurred in the old versions. Consider the following example:

: Kill them all!

   If you place the point at 'K', and call ~kill-word-correctly~ four times, all of the text will be killed. After killing each word, two consecutive spaces are left, and ~my/fix-space~ will get rid of one. However, ~my/fix-space~ is not a kill command, so it does not affect the kill-ring. Consequently, if you yank after killing all the words, you'll get:

: Killthemall!

   Would you like me to try to fix this or is the kill ring really not your concern?

: Haha, no, this is not a problem! Thank you!


* TODO [#B] smart-colon exception for smiley emoticon
  :PROPERTIES:
  :ARCHIVE_TIME: 2015-06-18 Thu 15:56
  :ARCHIVE_FILE: ~/Dropbox/emacs/prelude/personal/gnu-emacs-startup.org
  :ARCHIVE_CATEGORY: gnu-emacs-startup
  :ARCHIVE_TODO: TODO
  :END:
I'd like to make it easy for me to type something like the above:
: Thanks! :-)

Currently if I type it the way it looks, I wind up with this:
: Thanks!: -)

Should we somehow make an exception for the above, or should I just disable smart-punctuation for colon?


* DONE [#C] yet another edge case for kill-word-correctly-and-capitalize
  :PROPERTIES:
  :ARCHIVE_TIME: 2015-06-26 Fri 13:15
  :ARCHIVE_FILE: ~/Dropbox/emacs/prelude/personal/gnu-emacs-startup.org
  :ARCHIVE_CATEGORY: gnu-emacs-startup
  :ARCHIVE_TODO: DONE
  :END:
Here's another edge case.

: Into the book her sister was reading, but it had no pictures or conversations in it. "And what is the use of a book," thought thought Alice, "without pictures or conversations?"

Suppose the point is on the "t" in the first "thought" and I invoke kill-word-correctly-and-capitalize.

Current output:
: Into the book her sister was reading, but it had no pictures or conversations in it. "And what is the use of a book,"thought Alice, "without pictures or conversations?"

Desired output:
: Into the book her sister was reading, but it had no pictures or conversations in it. "And what is the use of a book," thought Alice, "without pictures or conversations?"

This function is becoming more and more useful!

** NOTE-TO-JAY Question

   The culprit here seems to be again ~my/fix-space~. I see you added the following clause:

: (looking-back "\" ")

   This means that after fixing the spaces, if you look back from point to '" ', you should delete the space. I suppose that's only true if: (1) the quotation marks are starting a quote, or (2) there is a punctuation mark ahead (which is handled by another clause).

   So, what was the intention here?
** NOTE-TO-RÚDI Answer
Hmm, I'm not sure I remember what I intended there. I must have been trying to address an edge case I found myself. If it makes sense to remove that clause again, let's do so, and if I find another edge case, we can address it at that point.

In general, I will use quotation marks and punctuation in the style/sequence reflected below:

#+BEGIN_QUOTE
Alice was beginning to get very tired of sitting by her sister on the bank (and of having nothing to do). Once or twice she had peeped into the book her sister was reading, but it had no pictures or conversations in it. "And what is the use of a book," thought Alice, "without pictures or conversations."
#+END_QUOTE

Thanks!

** NOTE-TO-JAY About the quotation marks

OK, I removed the clauses pertaining to the quotation marks. Indeed, it is hard to determine, when you are looking at a single quotation mark, if it is starting or ending the quote. You must pair it with the previous or next; in the limit you have to take into account the whole buffer. There is probably code out there that does it (note that ~emacs-lisp-mode~, for example, colourises strings -- therefore, it must know when a string starts or ends). I can search for it if you want.
** NOTE-TO-RÚDI yes, later
Yes, that would be great, but let's deprioritize it. Thanks!


#+BEGIN_SRC emacs-lisp
(defvar *punctuation-markers-to-cycle-between*  ".?!")

(defun cycle-punctuation ()
  (interactive)
  (save-excursion
    (forward-sentence)
    (when (re-search-backward (format "\\>\\([%s]\\)[[:space:]]*\\="
                                      *punctuation-markers-to-cycle-between*)
                              nil t)
      (let ((next (elt *punctuation-markers-to-cycle-between*
                       ;; circular string; should be abstracted
                       (mod (1+ (position (elt (match-string 1) 0)
                                          *punctuation-markers-to-cycle-between*))
                            (length *punctuation-markers-to-cycle-between*)))))
        (replace-match (format "%c" next) t t nil 1)))))

(define-key key-minor-mode-map (kbd "M-.") 'cycle-punctuation)
#+END_SRC


* italicize next word
:PROPERTIES:
:ARCHIVE_TIME: 2015-11-21 Sat 19:59
:ARCHIVE_FILE: ~/Dropbox/emacs/prelude/personal/gnu-emacs-startup.org
:ARCHIVE_OLPATH: experiments - tested/words - some interesting utilities for text in Emacs/Send email to a list of users
:ARCHIVE_CATEGORY: gnu-emacs-startup
:END:

deprecated. use embolden next word, and bold words will be changed into italics during export. for purposes of visual display within Emacs, we'll display as bold. but semantically we'll treat these as italics, since there is no bold in books.

   #+BEGIN_EXAMPLE emacs-lisp
(define-minor-mode italicize-next-word
    "Make the next word you type bold."
  nil
  :lighter " ITALICIZE"
  :keymap (let ((map (make-sparse-keymap)))
            (define-key map (kbd "SPC") (lambda ()
                      (interactive)
                      (save-excursion
                        (goto-char (get-register 'p))
                        (insert "/"))
                      (insert "/ ")
                      (italicize-next-word -1)))
        (define-key map (kbd ".") (lambda ()
                    (interactive)
                    (save-excursion
                      (goto-char (get-register 'p))
                      (insert "/"))
                    (insert "/. ")
                    (italicize-next-word -1)))
            map)
  (if italicize-next-word
      (set-register 'p (point))
    (set-register 'p nil)))

(global-set-key "\C-i" 'italicize-next-word)
(define-key key-minor-mode-map (kbd "C-i") 'italicize-next-word)
   #+END_EXAMPLE

* old version, works
:PROPERTIES:
:ARCHIVE_TIME: 2015-11-21 Sat 20:21
:ARCHIVE_FILE: ~/Dropbox/emacs/prelude/personal/gnu-emacs-startup.org
:ARCHIVE_OLPATH: spacecraft-mode - superior handling of whitespace for writing and editing prose/self insert space/smart-org-meta-return-dwim
:ARCHIVE_CATEGORY: gnu-emacs-startup
:END:
 #+BEGIN_EXAMPLE emacs-lisp
(setq org-blank-before-new-entry
      '((heading . always)
       (plain-list-item . nil)))
(setq org-return-follows-link t)

(defun call-rebinding-org-blank-behaviour (fn)
  (let ((org-blank-before-new-entry
         (copy-tree org-blank-before-new-entry)))
    (when (org-at-heading-p)
      (rplacd (assoc 'heading org-blank-before-new-entry) nil))
    (call-interactively fn)))

(defun smart-org-meta-return-dwim ()
  (interactive)
  (call-rebinding-org-blank-behaviour 'org-meta-return))

(defun smart-org-insert-todo-heading-dwim ()
  (interactive)
  (call-rebinding-org-blank-behaviour 'org-insert-todo-heading))

(define-key org-mode-map (kbd "M-<return>") 'smart-org-meta-return-dwim)
(define-key org-mode-map (kbd "M-S-<return>") 'smart-org-insert-todo-heading-dwim)
 #+END_EXAMPLE

* code not currently in use
:PROPERTIES:
:ARCHIVE_TIME: 2023-02-14 Tue 12:47
:ARCHIVE_FILE: ~/emacs/emacs-settings/gnu-emacs-startup.org
:ARCHIVE_CATEGORY: gnu-emacs-startup
:END:
*** keybindings not currently in use
 (define-key key-minor-mode-map (kbd "DEL")  'new-org-delete-backward-char)
 (global-set-key (kbd "C-c s") 'org-copy-subtree)
 (define-key key-minor-mode-map (kbd "C-v s") 'org-paste-subtree)
;; (define-key key-minor-mode-map (kbd "s-l") 'org-insert-link)
(define-key key-minor-mode-map (kbd "C-c C-l") 'org-insert-link)
 (define-key key-minor-mode-map (kbd "s-i") 'markdown-insert-image)
 (define-key key-minor-mode-map (kbd "s-\\") 'org-ctrl-c-ctrl-c)
 (define-key key-minor-mode-map (kbd "s-u") 'ido-dired)
 (define-key key-minor-mode-map (kbd "H-n") 'org-narrow-to-subtree)
 (define-key key-minor-mode-map (kbd "H-G") 'prelude-google)
 (define-key key-minor-mode-map (kbd "s-G") 'osx-browse-guess)
 (define-key key-minor-mode-map (kbd "s-") 'google-define-word-or-phrase)
 (define-key key-minor-mode-map (kbd "C-c C-x C-o") 'org-pomodoro)
 (define-key key-minor-mode-map (kbd "s-R") 'web-research)


;; (define-key key-minor-mode-map (kbd "<right>") 'aquamacs-right-char)
;; (define-key key-minor-mode-map (kbd "<right>") 'switch-to-next-buffer)
;; (define-key key-minor-mode-map (kbd "<right>") 'switch-to-next-buffer)
;; (define-key key-minor-mode-map (kbd "<down>") 'aquamacs-next-line)


* experiments - tested
:PROPERTIES:
:ARCHIVE_TIME: 2023-02-27 Mon 00:39
:ARCHIVE_FILE: ~/emacs/emacs-settings/gnu-emacs-startup.org
:ARCHIVE_CATEGORY: gnu-emacs-startup
:END:
** words - some interesting utilities for text in Emacs
The idea is a command called words that will be run interactively. It will grab the word at point, or operate on a selected region, and then offer a menu to lookup the definition, find it in a thesaurus, google it, etc.

We structure the code so you can add functions to it later, without directly modifying this code. The only limitation of this code is that the functions must have a signature with no arguments. That does not seem terribly limiting, as we can check for a region, and use it if we want (see the words-google function).

#+BEGIN_SRC emacs-lisp
(defun words-dictionary ()
  (interactive)
  (browse-url
   (format
    "http://dictionary.reference.com/browse/%s?s=t"
    (thing-at-point 'word))))

(defun words-thesaurus ()
  (interactive)
  (browse-url
   (format
    "http://www.thesaurus.com/browse/%s"
    (thing-at-point 'word))))

(defun words-google ()
  (interactive)
  (browse-url
   (format
    "http://www.google.com/search?q=%s"
    (if (region-active-p)
	(url-hexify-string (buffer-substring (region-beginning)
					     (region-end)))
      (thing-at-point 'word)))))


(defvar words-funcs '()
 "functions to run in `words'. Each entry is a list of (key menu-name function).")

(setq words-funcs
  '(("d" "ictionary" words-dictionary)
    ("t" "hesaurus" words-thesaurus)
    ("g" "oogle" words-google)))


(defun words ()
  (interactive)
   (message
   (concat
    (mapconcat
     (lambda (tup)
       (concat "[" (elt tup 0) "]"
	       (elt tup 1) " "))
     words-funcs "") ": "))
   (let ((input (read-char-exclusive)))
     (funcall
      (elt
       (assoc
	(char-to-string input) words-funcs)
       2))))
#+END_SRC

#+RESULTS:
: words

This works nicely. Now, let us add a new function that looks up the word or selection on twitter. We just define a new function, and add the menu selection to the words-func variable.

#+BEGIN_SRC emacs-lisp
(defun words-twitter ()
  (interactive)
  (browse-url
   (format
    "https://twitter.com/search?q=%s"
    (if (region-active-p)
	(url-hexify-string (buffer-substring (region-beginning)
					     (region-end)))
      (thing-at-point 'word)))))

(add-to-list 'words-funcs
  '("w" "twitter" words-twitter)
  t) ; append

#+END_SRC

#+RESULTS:
| d | ictionary | words-dictionary |
| t  | hesaurus  | words-thesaurus  |
| g | oogle     | words-google     |
| w | twitter   | words-twitter    |

Finally, the most complicated idea: spelling and grammar. I know there is flyspell, and such, but they are build on an ancient dictionary. Here, for fun, we explore a web api. This next function is not a trivial one, and I will not explain it here beyond saying it sends a selection of text to a url, gets an xml response back, and that response is parsed and printed to a buffer by this function. The main point is to illustrate we can do interesting things with a selection of text!

#+BEGIN_SRC emacs-lisp
(defun words-atd ()
  "Send paragraph at point to After the deadline for spell and grammar checking."
  (interactive)

  (let* ((url-request-method "POST")
	 (url-request-data (format
			    "key=some-random-text-&data=%s"
			    (url-hexify-string
			     (thing-at-point 'paragraph))))
	 (xml  (with-current-buffer
		   (url-retrieve-synchronously
		    "http://service.afterthedeadline.com/checkDocument")
		 (xml-parse-region url-http-end-of-headers (point-max))))
	 (results (car xml))
	 (errors (xml-get-children results 'error)))

    (switch-to-buffer-other-frame "*ATD*")
    (erase-buffer)
    (dolist (err errors)
      (let* ((children (xml-node-children err))
	     ;; for some reason I could not get the string out, and had to do this.
	     (s (car (last (nth 1 children))))
	     ;; the last/car stuff doesn't seem right. there is probably
	     ;; a more idiomatic way to get this
	     (desc (last (car (xml-get-children children 'description))))
	     (type (last (car (xml-get-children children 'type))))
	     (suggestions (xml-get-children children 'suggestions))
	     (options (xml-get-children (xml-node-name suggestions) 'option))
	     (opt-string  (mapconcat
			   (lambda (el)
			     (when (listp el)
			       (car (last el))))
			   options
			   " ")))

	(insert (format "** %s ** %s
Description: %s
Suggestions: %s

" s type desc opt-string))))))

(add-to-list 'words-funcs
  '("s" "spell/grammar" words-atd)
  t) ; append
#+END_SRC

#+RESULTS:
: words-atd

My final words menu looks like:
#+attr_html: :width 400
[[./images/final-menu.png]]

If I have the cursor in the previous paragraph, run the words command and select "s" I get a buffer with these contents:

#+BEGIN_EXAMPLE
*** flyspell ** (spelling)
Description: (Spelling)
Suggestions: flywheel flyball

*** are build on ** (grammar)
Description: (Auxiliary Verb Agreement)
Suggestions: are built on

*** api ** (spelling)
Description: (Spelling)
Suggestions: app ape apt ai ami

*** url ** (spelling)
Description: (Spelling)
Suggestions: urn ure curl hurl burl

*** xml ** (spelling)
Description: (Spelling)
Suggestions: xl ml

*** selection ** (suggestion)
Description: (Complex Expression)
Suggestions: choice

*** an xml ** (grammar)
Description: (Wrong article)
Suggestions: a xml

*** a selection of ** (grammar)
Description: (Hidden Verbs)
Suggestions:

*** is parsed ** (grammar)
Description: (Passive voice)
Suggestions:

*** selection ** (suggestion)
Description: (Complex Expression)
Suggestions: choice

*** a selection of ** (grammar)
Description: (Hidden Verbs)
Suggestions:
#+END_EXAMPLE

It might be nice to link back to those words, so you could click on them and fix them, but that is a beyond today's goal. In summary, today we looked at a framework to create a user-modifiable menu of commands that are launched from a single command. Here we called the command words, and then built up some different things we might want to do with the word or selection at point. While you can of course just remember the individual commands, remembering one command and then being prompted might have some advantages.

Source: tk

** invisible text in Emacs
Source:    [[http://kitchingroup.cheme.cmu.edu/blog/2014/02/06/Invisible-text-in-Emacs/][invisible text in Emacs]]

** Making org-mode links to files in Emacs packages
#+BEGIN_EXAMPLE
Today I will make a new org-mode link that lets me make links to files inside of Emacs packages. These files may be installed in different places on different systems (e.g. in the system directory, in ELPA directories, or in custom directories), so we need a way to construct paths to them. The application of this is eventually I hope to have some emacs packages of documentation, and I would like to have links between the packages that work no matter how they are installed.

I want a syntax that looks like pkg:rainbow-mode==rainbow-mode-pkg.el. We will have a function that parses that to get the package, and the path to the file in the package. Emacs has a function to find the path to the file that defines a library. I chose == because it seems unlikely that would be a string in a package or path.

#+BEGIN_SRC emacs-lisp :results value
(locate-library "rainbow-mode")
#+END_SRC

#+RESULTS:
: c:/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa/rainbow-mode-0.9/rainbow-mode.elc

We can use that to construct the path to where we want. Say we want the file named "rainbow-mode-pkg.el"

#+BEGIN_SRC emacs-lisp :results value
(expand-file-name
 "rainbow-mode-pkg.el"
 (file-name-directory (locate-library "rainbow-mode")))
#+END_SRC

#+RESULTS:
: c:/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa/rainbow-mode-0.9/rainbow-mode-pkg.el

In org-mode links, the link path gets passed to a function. We can split the string like this to get the package and relative path we are referring to.

#+BEGIN_SRC emacs-lisp :results value
(split-string "rainbow-mode==rainbow-mode-pkg.el" "==")
#+END_SRC

#+RESULTS:
| rainbow-mode | rainbow-mode-pkg.el |

That is all of the pieces we need to construct the link function. Here it is.

#+BEGIN_SRC emacs-lisp
(org-add-link-type
 "pkg"
 (lambda (path)
   (let ((pkg) (relpath)
	 (splitpath (split-string path "==")))
     (setq pkg (car splitpath))
     (setq relpath (nth 1 splitpath))
     (find-file (expand-file-name
		 relpath
		 (file-name-directory (locate-library pkg)))))))
#+END_SRC

#+RESULTS:

pkg:rainbow-mode==rainbow-mode-pkg.el

This works too, but you have to use auctex-pkg as the package name.

pkg:auctex-pkg==doc/intro.texi

I think that is because locate-library looks for the /file/ a library is defined in. That is not quite the same as the root directory of a package. It turns out to be a little more complicated to find that. Below is some code I hacked up looking at the package.el code. First let us examine some pieces.

This gives us information about an installed package.

#+BEGIN_SRC emacs-lisp :results value
(assq 'auctex package-alist)
#+END_SRC

#+RESULTS:
: (auctex . [(11 87 2) nil Integrated environment for *TeX*])

We can get the version of the package like this

#+BEGIN_SRC emacs-lisp :results value
(package-version-join (package-desc-vers (cdr (assq 'auctex package-alist))))
#+END_SRC

#+RESULTS:
: 11.87.2

Ok, finally, we get the directory where it is installed like this:

#+BEGIN_SRC emacs-lisp :results value
(package--dir "auctex" "11.87.2")
#+END_SRC

#+RESULTS:
: c:/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa/auctex-11.87.2

Note that in some places we use a package symbol, and in other places a string name.Putting that together, we have this block to get the install-dir of a package. If we have a package symbol we can get the path like this.

#+BEGIN_SRC emacs-lisp :results value
(let* ((pkg 'auctex)
       (pkg-name (symbol-name pkg)) ; convert symbol to string
       (desc (cdr (assq pkg package-alist)))
       (version (package-version-join (package-desc-vers desc)))
       (pkg-dir (package--dir pkg-name version)))
  pkg-dir)
#+END_SRC

#+RESULTS:
: c:/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa/auctex-11.87.2

Usually, we will have a string though. We just have to make it a symbol with the =intern= function.

#+BEGIN_SRC emacs-lisp :results value
(setq pkg-name "auctex")
(setq pkg (intern pkg-name))
(setq desc (cdr (assq pkg package-alist)))
#+END_SRC

#+RESULTS:
: [(11 87 2) nil "Integrated environment for *TeX*"]

Now, we have all the pieces to get the path from a package name in a string:

#+BEGIN_SRC emacs-lisp :results value
(let* ((pkg-name "auctex")
       (pkg (intern pkg-name))
       (desc (cdr (assq pkg package-alist)))
       (version (package-version-join (package-desc-vers desc)))
       (pkg-dir (package--dir pkg-name version)))
  pkg-dir)
#+END_SRC

#+RESULTS:
: c:/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa/auctex-11.87.2

Let us use that to rewrite the link, and address a few other limitations. We will  use =org-open-link-from-string= so we can use org-link syntax in the path part of the link, e.g. to open a file at a line, or headline. Here is our new link.

#+BEGIN_SRC emacs-lisp
(org-add-link-type
 "pkg2"
 (lambda (path)
   (let ((pkg) (relpath) (pkg-dir) (link-string)
	 (splitpath (split-string path "==")))
     (setq pkg-name (car splitpath))
     (setq relpath (nth 1 splitpath))
     (setq pkg-dir (let* ((pkg-symbol (intern pkg-name)) ;convert string to pkg
			  (desc (cdr (assq pkg-symbol package-alist)))
			  (version (package-version-join (package-desc-vers desc)))
			  (pkg-dir (package--dir pkg-name version)))
		     pkg-dir))
     (setq link-string (format "[[file:%s/%s]]" pkg-dir relpath))
     (message "link: %s" link-string)
     (org-open-link-from-string link-string))))
#+END_SRC

Now, we can do all of these:
pkg2:auctex==doc/faq.texi
pkg2:auctex==doc/faq.texi::should
pkg2:auctex==doc/faq.texi::10
[[pkg2:auctex==doc/faq.texi::first place]]

Awesome!

Just for fun, I made a toy package called =package1= in my elpa directory. That package has an org file in it. Now, I can test out the following links:

pkg2:package1==intro.org

pkg2:package1==intro.org::*Miscellaneous

[[pkg2:package1==intro.org::*subheading with words]]

pkg2:package1==intro.org::#install-section

pkg2:package1==intro.org::intro-target

They all work! That works for packages installed via the package manager. However, when I try this with my custom installed org-mode, it does not work. If I run (describe-package 'org) I see that org is a build in package, and that there is an alternate version avalable. It does not point to my org-installation.

pkg2:org==doc/library-of-babel.org

#+BEGIN_SRC emacs-lisp
(princ (locate-library "org"))
#+END_SRC

#+RESULTS:
: c:/Users/jkitchin/Dropbox/kitchingroup/jmax/org-mode/lisp/org.elc

#+BEGIN_SRC emacs-lisp
(princ (package-installed-p "org"))
#+END_SRC

#+RESULTS:
: nil

Obviously, we need to check if the package is installed via package.el, or if we should look somewhere else. Let us take a final stab at this. Let us review the challenge.

#+BEGIN_SRC emacs-lisp
(print (locate-library "auctex"))
(print (locate-library "auctex-autoloads"))
#+END_SRC

#+RESULTS:
:
: nil
:
: "c:/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa/auctex-11.87.2/auctex-autoloads.el"

We may have to check for a package-autoloads. Ww can wrap that in an =or= macro, which will return the first non-nil result.

#+BEGIN_SRC emacs-lisp :results value
(let ((pkg-name "auctex"))
   (file-name-directory
    (or (locate-library pkg-name)
	(locate-library (format "%s-autoloads" pkg-name)))))
#+END_SRC

#+RESULTS:
: c:/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa/auctex-11.87.2/

Doing this on the org package shows that this points to a lisp directory.
#+BEGIN_SRC emacs-lisp :results value
(let ((pkg-name "org"))
   (file-name-directory
    (or (locate-library pkg-name)
	(locate-library (format "%s-autoloads" pkg-name)))))
#+END_SRC

#+RESULTS:
: c:/Users/jkitchin/Dropbox/kitchingroup/jmax/org-mode/lisp/

So, let's try a final link function.

#+BEGIN_SRC emacs-lisp
(org-add-link-type
 "pkg3"
 (lambda (path)
   (let ((pkg-name) (relpath)(pkg-dir) (link-string)
	 (splitpath (split-string path "==")))
     (setq pkg-name (car splitpath))
     (setq relpath (nth 1 splitpath))
     (setq pkg-dir (file-name-directory
		    (or (locate-library pkg-name)
			(locate-library (format "%s-autoloads" pkg-name)))))
(setq link-string (format "[[file:%s/%s]]" pkg-dir relpath))
     (message "link: %s" link-string)
     (org-open-link-from-string link-string))))
#+END_SRC

#+RESULTS:

Now, we just have to make sure to use the right relative path. This link opens up an org-file in my installed version of org-mode: pkg3:org==../doc/library-of-babel.org

I don't know if there is a more clever way to create these links. There are two parts to them: 1) the package, and 2) the relative path. The link syntax isn't that rich to do it without parsing the linkpath.

#+END_EXAMPLE

** Send email to a list of users
I have a need to send a lot of emails to users in my class. I have to send each student an email containing there userid and a password assigned to them. I have a list of these, so the strategy is to create a function that will email that information to one user, and then use mapc to apply the function to each pair in a list.  First, we work out a function that will send one email to one user.

#+BEGIN_SRC emacs-lisp
(defun send-mail (userid password)
  "send email to sunjaydixit@gmail.com containing their password"
  (interactive)
  (mail)
  (mail-to)
  (insert (format "%s@jaydixit.com" userid))
  (mail-subject)
  (insert "[06-640] account information")
  (mail-text)
  (insert (format "
An account has been created on jaydixit.com
userid: %s
password: %s" userid password))
  (mail-send-and-exit))

;; (send-mail "jkitchin" "trustme99")
#+END_SRC

#+RESULTS:

That worked well. I ran the block and got the email.

Now, suppose I have this data:
#+tblname: users
| userid | password  |
|-------+-----------|
| user1  | trustme99 |
| user2  | foolme99  |
| user3  | blameme99 |

We can pass that to a source block as a list of lists that will look like this:
#+BEGIN_EXAMPLE
 ((user1 trustme99) (user2 foolme99) (user3 blameme99))
#+END_EXAMPLE

Then, we can use a mapc to process each element. Here I use a dummy function with two arguments. If I substitute the function above, each of these users would get an email.

#+BEGIN_SRC emacs-lisp :var data=users
;; (defun fun (a b) (princ (format "user: %s\npassword: %s\n" a but)))

;; (mapc (lambda (x) (fun (car x) (cadr x))) data)
#+END_SRC

#+RESULTS:
: user: user1
: password: trustme99
: user: user2
: password: foolme99
: user: user3
: password: blameme99

I am not sure that is the best way to get the first and second elements in the list element. It looks funny to me, but it works fine. the alternative is not much prettier:

#+BEGIN_SRC emacs-lisp :var data=users
;; (defun fun (a b) (princ (format "user: %s\npassword: %s\n" a but)))

;; (mapc (lambda (x) (fun (nth 0 x) (nth 1 x))) data)
#+END_SRC

#+RESULTS:
: user: user1
: password: trustme99
: user: user2
: password: foolme99
: user: user3
: password: blameme99

Source: [[http://kitchingroup.cheme.cmu.edu/blog/2014/01/13/Send-email-to-a-list-of-users/][The Kitchin Research Group]]


** videos
- [[https://www.youtube.com/watch?v%3D6W82EdwQhxU][Hack Emacs - An Overview of Org Mode - YouTube]]
- [[https://www.youtube.com/watch?v%3DoJTwQvgfgMM][Emacs Org-mode - a system for note-taking and project planning - YouTube]]
- [[https://www.youtube.com/watch?v%3DnsGYet02bEk][Hack Emacs - Org Mode In Depth: Managing Structure - YouTube]]
- [[https://www.youtube.com/watch?v%3DfgizHHd7nOo][Kitchin - org mode is awesome - YouTube]]

** macro to create defuns?

(defmacro make-my-function (name)
  (list 'defun (intern (format "my-%s-function" name)) ()
        (list 'interactive)
        (list (intern (format "mark-%s" name)))
        (list 'do-more-stuff)
        (list (intern (format "modify-%s" name)))))

