#+TITLE: Org-Element Cache Error Fix - Best Practices
#+AUTHOR: Analysis of org-element-cache corruption in custom functions
#+DATE: 2025-10-02

* Problem Overview

The configuration was experiencing frequent org-element-cache errors with the message:
: (error "Invalid search bound (wrong side of point)")

** Affected Files
- =20250918174636-core_mantras.org= (org-roam file)
- Triggered by custom editing functions during normal use

** Root Cause Analysis

*** Why org-element-cache breaks:

1. *The cache maintains position markers* to parsed elements
2. *When buffer text changes*, those positions can become invalid
3. *Mid-modification cache queries* trigger re-parsing with stale positions
4. *Result*: =re-search-forward= gets called with LIMIT < point → "wrong side of point" error

*** The Anti-Pattern in Your Code:

All three problematic functions follow this sequence:
#+begin_example
1. Modify buffer (insert/delete text)
2. Immediately call org-element functions (org-at-item-p, re-search-forward)
3. Modify buffer again based on step 2
#+end_example

Each modification triggers cache invalidation, but step 2 forces cache re-sync *mid-operation*, with partially-updated positions.

* Problematic Functions Identified

** 1. pasteboard-paste-adaptive
- *Location*: =pasteboard-copy-and-paste-functions.org:516-584=
- *Issue*: Modifies buffer text and then uses =save-excursion= + =re-search-forward= within the just-modified region
- *Line 575-580*: After pasting, it searches for headings in the pasted region and calls =demote-org-headings-in-region=
- *Why it breaks*: org-element-cache gets notified of text insertion, but then the function manipulates that same region before the cache can sync, causing invalid buffer position references

** 2. smart-return
- *Location*: =smart-return.el:253-315=
- *Already has a workaround* (lines 241-286) that disables cache during empty list item deletion
- *Issue*: The workaround only applies to ONE branch (empty list items), but ALL branches modify buffer text
- *Lines 298-299, 303, 307, 311*: All these paths insert/delete text without cache protection
- *The pause/resume pattern exists but is too narrow*

** 3. my/delete-backward-and-capitalize
- *Location*: =spacecraft-mode.org:1023+=
- *Issue*: Complex chain of text modifications:
  - =kill-line 0= at line 1027
  - =delete-region= at line 1034
  - =new-org-delete-backward-char= at line 1036
  - =my/fix-space= at line 1045
  - =capitalize-unless-org-heading= at line 1048
- *Why it breaks*: Multiple buffer modifications in quick succession don't give org-element-cache time to update its position markers

* Best Practice Solutions (Ranked)

** Solution 1: Use =combine-after-change-calls= (BEST) ⭐

This is what Emacs core uses. It batches all buffer changes and notifies hooks ONCE at the end:

#+begin_src emacs-lisp
(defmacro with-combined-after-change (&rest body)
  "Execute BODY with all buffer changes combined into a single notification."
  `(combine-after-change-calls
     (with-silent-modifications
       ,@body)))
#+end_src

*Why this is best:*
- ✅ Cache still works and stays valid
- ✅ Standard Emacs approach used by org-mode itself
- ✅ Prevents mid-modification cache queries
- ✅ No performance loss
- ✅ Future-proof

** Solution 2: Separate READ from WRITE phases

Cache all state BEFORE modifying buffer:

#+begin_src emacs-lisp
;; WRONG (current approach):
(when (org-at-item-p)        ; ← queries cache
  (delete-region ...)         ; ← modifies buffer
  (when (org-at-item-p) ...)) ; ← queries cache again with stale data

;; RIGHT:
(let ((was-at-item (org-at-item-p)))  ; ← cache state FIRST
  (when was-at-item
    (combine-after-change-calls
      (delete-region ...)
      (insert ...))))
#+end_src

** Solution 3: Process text BEFORE insertion

For =pasteboard-paste-adaptive=, transform clipboard content before inserting:

#+begin_src emacs-lisp
;; WRONG (current):
(insert raw-clip)                              ; ← insert
(re-search-forward "^\\*+ " paste-end-pos t)  ; ← search what we just inserted
(demote-org-headings-in-region ...)           ; ← modify again

;; RIGHT:
(let ((processed-clip
       (if needs-demotion
           (with-temp-buffer
             (insert raw-clip)
             (demote-headings-in-temp-buffer)
             (buffer-string))
         raw-clip)))
  (insert processed-clip))  ; ← single insertion, done
#+end_src

* Specific Fixes

** Fix 1: pasteboard-paste-adaptive (Process-Before-Insert pattern)

#+begin_src emacs-lisp
(defun demote-org-headings-in-string (text)
  "Demote all org headings in TEXT by one level. Returns modified string."
  (with-temp-buffer
    (insert text)
    (goto-char (point-min))
    (while (re-search-forward "^\\(\\*+\\) " nil t)
      (replace-match "\\1* " nil nil))
    (buffer-string)))

(defun pasteboard-paste-adaptive ()
  "Paste from the macOS pasteboard, choosing method based on current mode and context."
  (interactive)
  (let* ((raw-clip (string-trim (shell-command-to-string "pbpaste")))
         (clipboard-text (downcase raw-clip))
         (is-org-roam (is-org-roam-buffer-p))
         choice)
    (cond
     ;; 1) If region is active and clipboard looks like a URL → bracket link
     ((and (use-region-p)
           (not (string-empty-p raw-clip))
           (string-match-p "\\(https?://\\|www\\.\\)" clipboard-text))
      (setq choice "bracket-link")
      (org-insert-link-from-clipboard (region-beginning) (region-end)))

     ;; 2) In shell/elisp/web → raw paste
     ((or (eq major-mode 'sh-mode)
          (eq major-mode 'emacs-lisp-mode)
          (eq major-mode 'markdown-mode)
          (eq major-mode 'gfm-mode)
          (derived-mode-p 'markdown-mode)
          (eq major-mode 'web-mode))
      (setq choice "verbatim")
      (pasteboard-paste-raw))

     ;; 3) In Org/text modes → clean paste with optional demotion
     ((or (and (eq major-mode 'org-mode)
               (not (bound-and-true-p org-config-files-local-mode)))
          (derived-mode-p 'text-mode))
      (setq choice "clean")
      ;; PRE-PROCESS: Demote headings BEFORE inserting if in org-roam
      (let ((text-to-insert
             (if (and is-org-roam
                      (string-match-p "^\\*+ " raw-clip))
                 (progn
                   (setq choice "clean (org-roam demoted)")
                   (demote-org-headings-in-string raw-clip))
               raw-clip)))
        ;; Clean and insert the pre-processed text
        (pasteboard-paste-clean-with-text text-to-insert)))

     ;; 4) Fallback: decide based on surrounding chars
     (t
      (let* ((prev-char (char-before))
             (next-char (char-after))
             (char-set '(?: ?' ?\( ?\) ?| ?\[ ?\] ?/ ?\\ ?\" ?= ?< ?> ?{ ?}))
             use-no-spaces)
        (setq use-no-spaces
              (or (member prev-char char-set)
                  (member next-char char-set)))
        (if use-no-spaces
            (progn
              (setq choice "paste-raw")
              (pasteboard-paste-raw))
          (setq choice "paste-clean")
          (pasteboard-paste-clean)))))

    (message "Pasted: %s" choice)))

;; Helper function (you may need to adapt pasteboard-paste-clean to accept text)
(defun pasteboard-paste-clean-with-text (text)
  "Insert TEXT with smart quote conversion and cleanup."
  (let ((cleaned (replace-regexp-in-string "'" "'" text)))
    (insert cleaned)))
#+end_src

** Fix 2: smart-return (Cache-State-First + Combine-Changes pattern)

#+begin_src emacs-lisp
(defun smart-return ()
  "Perform a context-aware Return in Org-mode.

This version caches all state checks BEFORE buffer modifications
to prevent org-element-cache corruption."
  (interactive)
  ;; PHASE 1: Read all state (safe to use org-element-cache here)
  (let ((in-empty-item (org-in-empty-item-p))
        (url-is-image (org-url-at-point-is-image-p))
        (on-link (org-link-at-point-p))
        (has-region (use-region-p))
        (at-item (org-at-item-p))
        (at-checklist (and (org-at-item-p) (smart-return--at-checklist-p)))
        (in-org-mode (derived-mode-p 'org-mode))
        ;; For empty item case, cache what we need
        item-begin item-end)

    ;; If in empty item, get the positions NOW before any modifications
    (when in-empty-item
      (save-excursion
        (org-beginning-of-item)
        (setq item-begin (point))
        (setq item-end (line-end-position))))

    ;; PHASE 2: Modify buffer based on cached state
    (cond
     ;; 1) Empty list item - combine all changes into one atomic operation
     (in-empty-item
      (combine-after-change-calls
        ;; Move to beginning and delete the item marker
        (delete-region item-begin item-end)
        ;; Insert newline
        (newline)
        ;; Clean up any auto-inserted list marker
        (when (looking-at "^[ \t]*\\(?:[-+*]\\|[0-9]+[.)]\\)[ \t]+")
          (delete-region (match-beginning 0) (match-end 0)))
        ;; Remove leftover indentation
        (delete-horizontal-space)))

     ;; 2) Image URL - no buffer modification
     (url-is-image
      (display-online-image-in-new-buffer (thing-at-point 'url)))

     ;; 3) Link following - no buffer modification (org-open-at-point is cache-safe)
     ((and on-link org-return-follows-link)
      (org-open-at-point))

     ;; 4) Active region - org-return-indent is cache-safe
     (has-region
      (delete-region (region-beginning) (region-end))
      (org-return-indent))

     ;; 5) Checklist item - our function, should combine changes
     (at-checklist
      (smart-return--insert-checklist-item))

     ;; 6) Regular list item - org-insert-item is cache-safe
     (at-item
      (org-insert-item))

     ;; 7) Org-mode - org-return is cache-safe
     (in-org-mode
      (org-return))

     ;; 8) Fallback
     (t
      (newline)))))
#+end_src

** Fix 3: my/delete-backward-and-capitalize (Combine-All-Changes pattern)

#+begin_src emacs-lisp
(defun my/delete-backward-and-capitalize ()
  "Delete backward and fix whitespace, with all changes combined atomically."
  (interactive)
  ;; PHASE 1: Cache state before any modifications
  (let ((at-heading (looking-back-safe "^[*]+ "))
        (has-region (use-region-p))
        (capitalize capitalize-after-deleting-single-char)
        region-begin region-end)

    (when has-region
      (setq region-begin (region-beginning))
      (setq region-end (region-end)))

    ;; PHASE 2: Perform all buffer modifications as one atomic change
    (combine-after-change-calls
      ;; Handle heading case
      (when at-heading
        (kill-line 0)
        (insert " "))

      ;; Handle region or single character deletion
      (if has-region
          (progn
            (delete-region region-begin region-end)
            (setq capitalize t))
        (new-org-delete-backward-char 1))

      ;; Fix spacing (wrapped in save-excursion to not affect point)
      (save-excursion
        (when (or (looking-at "[[:space:]]")
                  (looking-back-safe "[[:space:]]"))
          ;; Only fix space if not already exactly one space between words
          (unless (and (looking-back-safe "\\w ")
                       (looking-at "\\w"))
            (my/fix-space))))

      ;; Capitalize if at beginning of sentence
      (when (and capitalize (my/beginning-of-sentence-p))
        (save-excursion
          (capitalize-unless-org-heading)))

      ;; Handle period-related logic
      (when (or (and (looking-at "\\.")
                     (looking-back-safe " "))
                (and (looking-at " ")
                     (looking-back-safe "\\.")))
        (delete-horizontal-space)
        (insert " ")))))
#+end_src

* Core Principle: Separate READ from WRITE

#+begin_example
❌ WRONG:                          ✅ RIGHT:
(org-at-item-p)                   (let ((at-item (org-at-item-p)))
(delete-region ...)                 (combine-after-change-calls
(org-at-item-p)  ; stale!            (delete-region ...)
                                     (when at-item ...)))
#+end_example

* Key Patterns to Use

1. *Process-Before-Insert*: Transform text in temp buffer, then insert once
2. *Cache-State-First*: Check all conditions before any modifications
3. *Combine-All-Changes*: Batch multiple edits with =combine-after-change-calls=

* Why This Works

- ✅ org-element-cache gets notified ONCE after all changes complete
- ✅ No mid-modification cache queries with stale positions
- ✅ Cache remains enabled and performant
- ✅ Aligns with how Emacs core and org-mode work internally
- ✅ Future-proof as org-mode evolves

* Implementation Priority

1. *Fix =smart-return= first* (most frequently used)
2. *Fix =my/delete-backward-and-capitalize=* (second most frequent)
3. *Fix =pasteboard-paste-adaptive=* (less frequent but more complex)

* Additional Safety Net (Optional)

If you still get occasional errors (unlikely with these fixes), add this to your config:

#+begin_src emacs-lisp
;; Increase cache tolerance for rapid edits
(setq org-element--cache-self-verify nil)  ; Disable paranoid verification
(setq org-element--cache-self-verify-frequency 0.1)  ; Less frequent checks
#+end_src

But with the fixes above, you *shouldn't need* to disable or pause the cache at all.

* Summary

The key insight is that org-element-cache corruption happens when we:
1. Query cache state (like =org-at-item-p=)
2. Modify buffer
3. Query cache again before it can sync

The solution is to *separate the READ phase from the WRITE phase*:
1. Read all state first (cache all conditions)
2. Then modify buffer atomically using =combine-after-change-calls=
3. Never query cache mid-modification

This aligns with Emacs best practices and keeps the cache working correctly.
