;;; keybinding-docs.el --- Keybinding documentation & frequency system  -*- lexical-binding: t; -*-

;; Requires keys.el to be loaded first (for alist definitions).

;;;; 1. keyfreq setup --------------------------------------------------------

(require 'keyfreq nil t)

(when (featurep 'keyfreq)
  ;; Exclude self-insert, motion, and mouse commands from frequency tracking
  (setq keyfreq-excluded-commands
        '(self-insert-command
          org-self-insert-command
          forward-char
          backward-char
          next-line
          previous-line
          left-char
          right-char
          mwheel-scroll
          mouse-set-point
          mouse-drag-region
          mouse-set-region
          ignore
          newline
          move-beginning-of-line
          move-end-of-line
          handle-switch-frame
          scroll-up-command
          scroll-down-command))

  ;; Auto-save frequency data every 5 minutes
  (setq keyfreq-autosave-mode t)
  (setq keyfreq-file (expand-file-name ".emacs.keyfreq" user-emacs-directory))

  (keyfreq-mode 1)
  (keyfreq-autosave-mode 1))

;;;; 2. Keybinding dump ------------------------------------------------------

(defvar my/keybinding-docs-dir
  (expand-file-name "docs/" (file-name-directory
                              (or load-file-name buffer-file-name
                                  "/Users/jay/emacs/emacs-settings/keybinding-docs.el")))
  "Directory where keybinding documentation files are written.")

(defun my/keybinding-dump ()
  "Dump all declared keybindings to `docs/keybinding-dump.org'.
Iterates the declarative alists in keys.el and writes an org
description-list file grouped by section."
  (interactive)
  (let ((outfile (expand-file-name "keybinding-dump.org" my/keybinding-docs-dir))
        (buf (generate-new-buffer "*keybinding-dump*")))
    (with-current-buffer buf
      ;; Header
      (insert ":PROPERTIES:\n:ID: keybinding-dump\n:END:\n")
      (insert "#+title: Keybinding Dump (auto-generated)\n")
      (insert "#+date: " (format-time-string "[%Y-%m-%d %a]") "\n\n")
      (insert "This file is auto-generated by =M-x my/keybinding-dump=.\n")
      (insert "Do NOT edit — add notes in [[file+emacs:"
              (expand-file-name "keybinding-annotations.org" my/keybinding-docs-dir)
              "][keybinding-annotations.org]] instead.\n\n")

      ;; --- key-minor-mode-map (global overrides) ---
      (insert "* key-minor-mode-map (global overrides)\n\n")
      (my/--dump-alist-with-sections 'my/global-key-bindings)

      ;; --- global-map ---
      (insert "\n* global-map\n\n")
      (my/--dump-alist 'my/global-map-bindings)

      ;; --- minibuffer ---
      (insert "\n* minibuffer-local-map\n\n")
      (my/--dump-alist 'my/minibuffer-bindings)

      ;; --- mode-specific maps ---
      (when (boundp 'my/mode-binding-registry)
        (dolist (entry my/mode-binding-registry)
          (let ((map-name (car entry))
                (alist-sym (cdr entry)))
            (insert "\n* " map-name "\n\n")
            (my/--dump-alist alist-sym))))

      ;; Write file
      (write-region (point-min) (point-max) outfile)
      (kill-buffer buf)
      (message "Keybinding dump written to %s" outfile))))

(defun my/--dump-alist (alist-sym)
  "Insert org description-list items for each binding in ALIST-SYM."
  (when (boundp alist-sym)
    (dolist (b (symbol-value alist-sym))
      (let ((key (car b))
            (cmd (cdr b)))
        ;; Skip comment-only entries (strings starting with ;;)
        (when (and key cmd)
          (insert (format "- ~%s~ :: =%s=\n" key cmd)))))))

(defun my/--dump-alist-with-sections (alist-sym)
  "Insert org description-list items, preserving section comments.
The alist in keys.el uses comment entries like ;; ==== Section Name ====
which appear as string cons cells where the key starts with ;;."
  (when (boundp alist-sym)
    (let ((in-section nil))
      (dolist (b (symbol-value alist-sym))
        (let ((key (car b))
              (cmd (cdr b)))
          (when (and key cmd)
            (insert (format "- ~%s~ :: =%s=\n" key cmd))))))))

;;;; 3. Annotation merge -----------------------------------------------------

(defun my/keybinding-merge ()
  "Merge keybinding-dump.org with keybinding-annotations.org.
Produces keybinding-reference.org — the one doc to read."
  (interactive)
  (let* ((dump-file (expand-file-name "keybinding-dump.org" my/keybinding-docs-dir))
         (ann-file  (expand-file-name "keybinding-annotations.org" my/keybinding-docs-dir))
         (ref-file  (expand-file-name "keybinding-reference.org" my/keybinding-docs-dir))
         (annotations (my/--parse-annotations ann-file))
         (prev-keys (my/--parse-reference-keys ref-file))
         (buf (generate-new-buffer "*keybinding-ref*")))

    (unless (file-exists-p dump-file)
      (user-error "Run M-x my/keybinding-dump first"))

    (with-current-buffer buf
      ;; Header
      (insert ":PROPERTIES:\n:ID: keybinding-reference\n:END:\n")
      (insert "#+title: Keybinding Reference (merged)\n")
      (insert "#+date: " (format-time-string "[%Y-%m-%d %a]") "\n\n")
      (insert "Auto-generated by =M-x my/keybinding-merge=.\n")
      (insert "Annotations from [[file+emacs:"
              ann-file "][keybinding-annotations.org]].\n\n")

      ;; Read dump and merge annotations
      (let ((dump-contents (with-temp-buffer
                             (insert-file-contents dump-file)
                             (buffer-string)))
            (current-keys '()))

        ;; Process line by line, skipping dump file header
        (dolist (line (split-string dump-contents "\n"))
          (cond
           ;; Skip dump-file header lines
           ((or (string-match "^:PROPERTIES:" line)
                (string-match "^:ID:" line)
                (string-match "^:END:" line)
                (string-match "^#\\+title:" line)
                (string-match "^#\\+date:" line)
                (string-match "^This file is auto-generated" line)
                (string-match "^Do NOT edit" line))
            nil)
           ;; Heading lines — pass through
           ((string-match "^\\*" line)
            (insert line "\n"))
           ;; Description list entry: - ~KEY~ :: =CMD=
           ((string-match "^- ~\\([^~]+\\)~ :: =\\([^=]+\\)=" line)
            (let* ((key (match-string 1 line))
                   (cmd (match-string 2 line))
                   (lookup (concat key "::" cmd))
                   (ann (gethash lookup annotations)))
              (push lookup current-keys)
              ;; Flag new bindings
              (when (and prev-keys (not (gethash lookup prev-keys)))
                (insert "- *[NEW]* "))
              (if ann
                  (insert (format "- ~%s~ :: =%s= -- %s\n" key cmd ann))
                (insert line "\n"))))
           ;; Other lines — pass through
           (t (insert line "\n"))))

        ;; Flag removed bindings
        (when prev-keys
          (let ((removed '()))
            (maphash (lambda (k _v)
                       (unless (member k current-keys)
                         (push k removed)))
                     prev-keys)
            (when removed
              (insert "\n* Removed Bindings\n\n")
              (dolist (r (sort removed #'string<))
                (insert (format "- *[REMOVED]* =%s=\n" r)))))))

      ;; Write
      (write-region (point-min) (point-max) ref-file)
      (kill-buffer buf)
      (message "Keybinding reference written to %s" ref-file))))

(defun my/--parse-annotations (file)
  "Parse annotations file into a hash table.
Each line should be: - KEY::COMMAND :: Your note here
Returns hash: \"KEY::COMMAND\" → \"note\"."
  (let ((table (make-hash-table :test 'equal)))
    (when (file-exists-p file)
      (with-temp-buffer
        (insert-file-contents file)
        (goto-char (point-min))
        (while (re-search-forward
                "^- \\([^:]+\\)::\\([^ ]+\\) :: \\(.+\\)$" nil t)
          (puthash (concat (match-string 1) "::" (match-string 2))
                   (match-string 3) table))))
    table))

(defun my/--parse-reference-keys (file)
  "Parse existing reference file to get set of known KEY::CMD pairs.
Returns hash table or nil if file doesn't exist."
  (when (file-exists-p file)
    (let ((table (make-hash-table :test 'equal)))
      (with-temp-buffer
        (insert-file-contents file)
        (goto-char (point-min))
        (while (re-search-forward
                "~\\([^~]+\\)~ :: =\\([^=]+\\)=" nil t)
          (puthash (concat (match-string 1) "::" (match-string 2))
                   t table)))
      table)))

;;;; 4. Frequency report -----------------------------------------------------

(defun my/keybinding-frequency-report ()
  "Generate a frequency report from keyfreq data.
Cross-references usage counts with declared keybindings to find:
1. Most used commands and their bindings
2. Ergonomic mismatches (high frequency on awkward sequences)
3. Underused prime keys (single s-KEY with low usage)"
  (interactive)
  (unless (featurep 'keyfreq)
    (user-error "keyfreq is not loaded; install it first"))
  (let* ((outfile (expand-file-name "keybinding-frequency-report.org"
                                     my/keybinding-docs-dir))
         (freq-table (keyfreq-table))
         (cmd-counts (make-hash-table :test 'equal))
         (buf (generate-new-buffer "*keyfreq-report*")))

    ;; Aggregate counts across all major modes
    (maphash (lambda (_mode-cmd-pair count)
               ;; keyfreq-table returns ((mode . cmd) . count)
               ;; but the hash is keyed by (mode . cmd)
               (let ((cmd (cdr _mode-cmd-pair)))
                 (puthash cmd
                          (+ (gethash cmd cmd-counts 0) count)
                          cmd-counts)))
             freq-table)

    ;; Build sorted list of (count . cmd)
    (let ((sorted '()))
      (maphash (lambda (cmd count)
                 (push (cons count cmd) sorted))
               cmd-counts)
      (setq sorted (sort sorted (lambda (a b) (> (car a) (car b)))))

      ;; Build reverse lookup: command → list of key bindings
      (let ((cmd-to-keys (make-hash-table :test 'equal)))
        (when (boundp 'my/global-key-bindings)
          (dolist (b my/global-key-bindings)
            (let ((cmd (cdr b)))
              (when cmd
                (puthash cmd
                         (cons (car b) (gethash cmd cmd-to-keys))
                         cmd-to-keys)))))
        (when (boundp 'my/global-map-bindings)
          (dolist (b my/global-map-bindings)
            (let ((cmd (cdr b)))
              (when cmd
                (puthash cmd
                         (cons (car b) (gethash cmd cmd-to-keys))
                         cmd-to-keys)))))

        (with-current-buffer buf
          ;; Header
          (insert ":PROPERTIES:\n:ID: keybinding-frequency-report\n:END:\n")
          (insert "#+title: Keybinding Frequency Report\n")
          (insert "#+date: " (format-time-string "[%Y-%m-%d %a]") "\n\n")
          (insert "Auto-generated by =M-x my/keybinding-frequency-report=.\n\n")

          ;; Most used commands
          (insert "* Most Used Commands\n\n")
          (let ((n 0))
            (dolist (entry sorted)
              (when (< n 50)
                (let* ((count (car entry))
                       (cmd (cdr entry))
                       (keys (gethash cmd cmd-to-keys))
                       (key-str (if keys
                                    (mapconcat (lambda (k) (format "~%s~" k))
                                               keys " / ")
                                  "(no custom binding)"))
                       (ergo (my/--classify-ergonomics keys)))
                  (insert (format "- =%s= (%d uses) :: %s | %s\n"
                                  cmd count key-str ergo))
                  (setq n (1+ n))))))

          ;; Ergonomic mismatches
          (insert "\n* Ergonomic Mismatches (high frequency, awkward binding)\n\n")
          (let ((n 0))
            (dolist (entry sorted)
              (when (< n 200)
                (let* ((count (car entry))
                       (cmd (cdr entry))
                       (keys (gethash cmd cmd-to-keys)))
                  (when (and keys (> count 20))
                    (let ((worst (my/--worst-ergonomic keys)))
                      (when (and worst (string-match-p "triple\\|quad" worst))
                        (insert (format "- =%s= (%d uses) :: %s -- %s\n"
                                        cmd count
                                        (mapconcat (lambda (k) (format "~%s~" k))
                                                   keys " / ")
                                        worst))))))
                (setq n (1+ n)))))

          ;; Underused prime keys
          (insert "\n* Underused Prime Keys (single s-KEY, low frequency)\n\n")
          (when (boundp 'my/global-key-bindings)
            (dolist (b my/global-key-bindings)
              (let ((key (car b))
                    (cmd (cdr b)))
                (when (and key cmd
                           (string-match "^s-[a-zA-Z]$" key))
                  (let ((count (gethash cmd cmd-counts 0)))
                    (when (< count 10)
                      (insert (format "- ~%s~ :: =%s= (%d uses) -- prime real estate, rarely used\n"
                                      key cmd count))))))))

          ;; Write file
          (write-region (point-min) (point-max) outfile)
          (kill-buffer buf)
          (message "Frequency report written to %s" outfile))))))

(defun my/--classify-ergonomics (keys)
  "Classify the ergonomic quality of a list of key strings.
Returns a string like \"single-key | home-row\"."
  (if (null keys)
      "no binding"
    (let ((best "quad-key"))
      (dolist (k keys)
        (let ((class (my/--key-complexity k)))
          (when (< (my/--ergo-rank class) (my/--ergo-rank best))
            (setq best class))))
      best)))

(defun my/--worst-ergonomic (keys)
  "Return the worst ergonomic classification among KEYS."
  (if (null keys)
      nil
    (let ((worst "single-key"))
      (dolist (k keys)
        (let ((class (my/--key-complexity k)))
          (when (> (my/--ergo-rank class) (my/--ergo-rank worst))
            (setq worst class))))
      worst)))

(defun my/--key-complexity (key)
  "Classify KEY string complexity.
Returns one of: single-key, double-key, triple-key, quad-key."
  (let ((parts (split-string key " ")))
    (cond
     ((= (length parts) 1) "single-key")
     ((= (length parts) 2) "double-key")
     ((= (length parts) 3) "triple-key")
     (t "quad-key"))))

(defun my/--ergo-rank (class)
  "Numeric rank for ergonomic CLASS (lower is better)."
  (cond
   ((string= class "single-key") 1)
   ((string= class "double-key") 2)
   ((string= class "triple-key") 3)
   ((string= class "quad-key") 4)
   (t 5)))

(provide 'keybinding-docs)
;;; keybinding-docs.el ends here
