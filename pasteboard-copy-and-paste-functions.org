#+auto_tangle: t
#+BEGIN_SRC emacs-lisp
;; -*- lexical-binding: t; -*-
(require 'subr-x)
#+END_SRC

* Replace smart quotes with straight quotes

#+BEGIN_SRC emacs-lisp
(setq smart-quote-regexp-replacements
      '(
        ("\\(\\w\\)- " . "\\1")
        ("\\(\\w\\)\\(  [-‚Äî] \\|‚Äî\\)" . "\\1---")))


(defun replace-smart-quotes-regexp (beg end)
  "Replace 'smart quotes' in buffer or region with ascii quotes."
  (interactive "r")
  (mapcar
   (lambda (r)
     (save-excursion
       (goto-char beg)
       (let ((end-marker (copy-marker (min end (point-max)))))
         (while (re-search-forward (car r) end-marker t)
           (replace-match (cdr r) t t))
         (set-marker end-marker nil))))
   smart-quote-regexp-replacements))

(defun replace-non-heading-double-asterisks (beg end)
  "Convert markdown style **bold** to Org *bold* unless the line is an Org heading."
  (interactive "r")
  (save-excursion
    (goto-char beg)
    (while (re-search-forward "\\*\\*" end t)
      (let ((match-beg (match-beginning 0)))
        (when match-beg
          (goto-char match-beg)
          (if (looking-at "^\\*+ ")
              (forward-char 2)
            (replace-match "*" t t)))))))

(defgroup smart-quotes nil
  "Customization group for smart quote replacements."
  :group 'convenience)

(defcustom smart-quotes-replacement-pairs
  '(("‚Äú" . "\"")
    ("‚Äù" . "\"")
    ("‚Äò" . "'")
    ("‚Äô" . "'")
    ("‚Äö" . "'")
    ("Ô¨É" . "ffi")
    ("‚Äõ" . "'")
    ("‚Äû" . "\"")
    ("‚Äü" . "\"")
    ("‚Äπ" . "'")
    ("‚Ä∫" . "'")
    ("¬´" . "\"")
    ("¬ª" . "\"")
    ("‚Äì" . "-")
    ("ÓàÉ" . "")
    ("ÓàÑ" . "")
    ("‚Äî" . "---")
    ("‚Ä¶" . "...")
    ("‚Ä¢ " . "- ")
    ("‚Ä¢" . "-")
    ("‚ÄØ" . " ")
    ("‚∏ª" . "-----")
    ("Ô¨Ä" . "ff")
    ("¬∑" . "-")
    ("‚Äß" . "-")
    ("‚ÅÉ" . "-")
    ("‚Äê" . "-")
    ("‚Äë" . "-")
    ("‚Äí" . "-")
    ("‚Äæ" . "-")
    ("¬†" . " ")       ; Non-breaking space
    ("‚ÄØ" . " ")       ; Narrow no-break space
    ("\u200B" . "")   ; Zero-width space
    ("\u200C" . "")   ; Zero-width non-joiner
    ("\u200D" . "")   ; Zero-width joiner
    ("\t" . " ")      ; Tab character replaced with a space
    ("#####" . "*****")
    ("####" . "****")
    ("###" . "***")
    ("##" . "**")
    ("- \\*\\* TODO" . "*** TODO")
    ("okay" . "OK")
    ("  SCHEDULED" . " SCHEDULED")
    ("  DEADLINE" . " DEADLINE"))
  "Alist of replacement pairs for `replace-smart-quotes` function."
  :type '(alist :key-type string :value-type string)
  :group 'smart-quotes)

(require 'cl-lib)  ; Ensure cl-lib is loaded for cl-every


(defun replace-smart-quotes (beg end)
  "Replace smart quotes and format text appropriately in the specified region.

The replacements are defined in the `smart-quotes-replacement-pairs` variable."
  (interactive "r")
  ;; Ensure beg <= end
  (when (> beg end)
    (let ((temp beg))
      (setq beg end)
      (setq end temp)))
  ;; Error checking for smart-quotes-replacement-pairs
  (unless (and (boundp 'smart-quotes-replacement-pairs)
               (listp smart-quotes-replacement-pairs)
               (cl-every (lambda (pair)
                           (and (consp pair)
                                (stringp (car pair))
                                (stringp (cdr pair))))
                         smart-quotes-replacement-pairs))
    (error "Invalid `smart-quotes-replacement-pairs` format; must be a list of string pairs"))
  ;; Convert end into a marker that adjusts with buffer changes
  (let ((end-marker (copy-marker end)))
    (save-excursion
      ;; Replace markdown bold **text** with org bold *text*
      ;; Skip pairs that belong to the leading stars of an Org heading
      (goto-char beg)
      (while (re-search-forward "\\*\\*" end-marker t)
        (let* ((match-pos (match-beginning 0))
               (match-end (match-end 0))
               (line-start (line-beginning-position))
               (heading-bound
                (save-excursion
                  (goto-char line-start)
                  (let ((has-stars nil))
                    (while (eq (char-after) ?*)
                      (setq has-stars t)
                      (forward-char 1))
                    (when (and has-stars (looking-at "\\s-"))
                      (point))))))
          (unless (and heading-bound (< match-pos heading-bound))
            (goto-char match-pos)
            (delete-region match-pos match-end)
            (insert "*"))))
      ;; Remove lines that contain only '---' (possibly with surrounding spaces)
      (goto-char beg)
      (while (re-search-forward "^\\s-*---\\s-*$" end-marker t)
        (replace-match "" t t))
      ;; Remove space before "-" at the beginning of lines
      (goto-char beg)
      (while (re-search-forward "^\\(\\s-*\\) -" end-marker t)
        (replace-match "\\1-" nil nil))
      ;; Perform replacements using the external `smart-quotes-replacement-pairs`
      (dolist (pair smart-quotes-replacement-pairs)
        (goto-char beg)
        (while (re-search-forward (regexp-quote (car pair)) end-marker t)
          (replace-match (cdr pair) t t))))))


#+END_SRC


* don't forget any üôÇ
#+begin_src emacs-lisp
(dolist (pair '(("\u2019" . "'")   ; ‚Äô  RIGHT SINGLE QUOTATION MARK
                ("\u02BC" . "'")   ;  º  MODIFIER LETTER APOSTROPHE
                ("\uFF07" . "'"))) ; Ôºá FULLWIDTH APOSTROPHE
  (add-to-list 'smart-quotes-replacement-pairs pair))

;; Ensure THREE‚ÄëEM‚ÄëDASH (U+2E3B) is actually mapped.
(add-to-list 'smart-quotes-replacement-pairs '("‚∏ª" . "")) ; or "-----"
;; Make sure curly double‚Äëquotes convert to straight ASCII quotes.
(dolist (pair '(("‚Äù" . "\"")   ; U+201D RIGHT DOUBLE QUOTATION MARK
                ("‚Äú" . "\""))) ; U+201C LEFT  DOUBLE QUOTATION MARK
  (add-to-list 'smart-quotes-replacement-pairs pair))

;; smart-quotes-replacements.el ‚Äî build pair list incrementally with explicit add-to-list calls -*- lexical-binding: t; -*-

;; Ensure the variable exists.
(defvar smart-quotes-replacement-pairs nil
  "Alist of (FROM . TO) strings used by `replace-smart-quotes'.")

;; ---------------------------------------------------------------------------
;; Core replacements (added one by one so they‚Äôre easy to tweak/remove later)
;; ---------------------------------------------------------------------------

(add-to-list 'smart-quotes-replacement-pairs '("‚Äú" . "\"") t)
(add-to-list 'smart-quotes-replacement-pairs '("‚Äù" . "\"") t)
(add-to-list 'smart-quotes-replacement-pairs '("‚Äò" . "'") t)
(add-to-list 'smart-quotes-replacement-pairs '("‚Äô" . "'") t)
(add-to-list 'smart-quotes-replacement-pairs '("‚Äö" . "'") t)
(add-to-list 'smart-quotes-replacement-pairs '("‚Äõ" . "'") t)
(add-to-list 'smart-quotes-replacement-pairs '("‚Äû" . "\"") t)
(add-to-list 'smart-quotes-replacement-pairs '("‚Äü" . "\"") t)
(add-to-list 'smart-quotes-replacement-pairs '("‚Äπ" . "'") t)
(add-to-list 'smart-quotes-replacement-pairs '("‚Ä∫" . "'") t)
(add-to-list 'smart-quotes-replacement-pairs '("¬´" . "\"") t)
(add-to-list 'smart-quotes-replacement-pairs '("¬ª" . "\"") t)
(add-to-list 'smart-quotes-replacement-pairs '("‚Äì" . "-") t)
(add-to-list 'smart-quotes-replacement-pairs '("ÓàÉ" . "") t)
(add-to-list 'smart-quotes-replacement-pairs '("ÓàÑ" . "") t)
(add-to-list 'smart-quotes-replacement-pairs '("‚Äî" . "---") t)
(add-to-list 'smart-quotes-replacement-pairs '("‚Ä¶" . "...") t)
(add-to-list 'smart-quotes-replacement-pairs '("‚Ä¢ " . "- ") t)
(add-to-list 'smart-quotes-replacement-pairs '("‚Ä¢" . "-") t)
(add-to-list 'smart-quotes-replacement-pairs '("‚ÄØ" . " ") t)   ; narrow NBSP
(add-to-list 'smart-quotes-replacement-pairs '("‚∏ª" . "‚Äî‚Äî") t) ; 3‚Äëem dash ‚Üí 2‚Äëem (edit as desired)
(add-to-list 'smart-quotes-replacement-pairs '("Ô¨Ä" . "ff") t)
(add-to-list 'smart-quotes-replacement-pairs '("¬∑" . "-") t)
(add-to-list 'smart-quotes-replacement-pairs '("‚Äß" . "-") t)
(add-to-list 'smart-quotes-replacement-pairs '("‚ÅÉ" . "-") t)
(add-to-list 'smart-quotes-replacement-pairs '("‚Äê" . "-") t)
(add-to-list 'smart-quotes-replacement-pairs '("‚Äë" . "-") t)
(add-to-list 'smart-quotes-replacement-pairs '("‚Äí" . "-") t)
(add-to-list 'smart-quotes-replacement-pairs '("‚Äæ" . "-") t)
(add-to-list 'smart-quotes-replacement-pairs '("¬†" . " ") t)    ; NBSP
(add-to-list 'smart-quotes-replacement-pairs '("\u200B" . "") t) ; ZW space
(add-to-list 'smart-quotes-replacement-pairs '("\u200C" . "") t) ; ZWNJ
(add-to-list 'smart-quotes-replacement-pairs '("\u200D" . "") t) ; ZWJ
(add-to-list 'smart-quotes-replacement-pairs '("\t" . " ") t)
(add-to-list 'smart-quotes-replacement-pairs '("#####" . "*****") t)
(add-to-list 'smart-quotes-replacement-pairs '("####" . "****") t)
(add-to-list 'smart-quotes-replacement-pairs '("###" . "***") t)
(add-to-list 'smart-quotes-replacement-pairs '("##" . "**") t)
(add-to-list 'smart-quotes-replacement-pairs '("- \\*\\* TODO" . "*** TODO") t)
(add-to-list 'smart-quotes-replacement-pairs '("okay" . "OK") t)
(add-to-list 'smart-quotes-replacement-pairs '("  SCHEDULED" . " SCHEDULED") t)
(add-to-list 'smart-quotes-replacement-pairs '("  DEADLINE" . " DEADLINE") t)

;; ---------------------------------------------------------------------------
;; Extra apostrophes & dashes caught in the wild
;; ---------------------------------------------------------------------------

(add-to-list 'smart-quotes-replacement-pairs '("\u2019" . "'") t) ; RIGHT SINGLE QUOTATION MARK
(add-to-list 'smart-quotes-replacement-pairs '("\u02BC" . "'") t) ; MODIFIER LETTER APOSTROPHE
(add-to-list 'smart-quotes-replacement-pairs '("\uFF07" . "'") t) ; FULLWIDTH APOSTROPHE

(add-to-list 'smart-quotes-replacement-pairs '("\u2011" . "-") t) ; NB‚Äëhyphen
(add-to-list 'smart-quotes-replacement-pairs '("\u2010" . "-") t) ; Unicode hyphen
(add-to-list 'smart-quotes-replacement-pairs '("\u00AD" . "-") t) ; soft hyphen
(add-to-list 'smart-quotes-replacement-pairs '("\u2E3B" . "-----") t) ; THREE‚ÄëEM DASH

(provide 'smart-quotes-replacements)

#+end_src

* no weird spaces
#+begin_src emacs-lisp
(defun replace-weird-spaces (beg end)
  "Replace NBSP, narrow NBSP, thin, hair, and zero‚Äëwidth space with ASCII space.
Preserves ZWJ (U+200D) and ZWNJ (U+200C) for proper emoji rendering."
  (save-excursion
    (goto-char beg)
    (while (re-search-forward "[\u00A0\u202F\u2009\u200A\u200B]" end t)
      (replace-match " " t t))))
#+end_src

* space before emoji
#+begin_src emacs-lisp
(defun ensure-heading-emoji-space (beg end)
  "Turn \"***üîÅ\" into \"*** üîÅ\" in Org headings.

Looks at the first non‚Äëspace char right after the stars; if it‚Äôs
non‚ÄëASCII (code‚Äëpoint >¬†127) and there‚Äôs no space already, insert one."
  (save-excursion
    (goto-char beg)
    (while (re-search-forward "^\\(\\*+\\)\\([^[:space:]]\\)" end t)
      (let* ((stars  (match-string 1))
             (char   (match-string 2))
             (cp     (string-to-char char)))
        (when (and (> cp 127)
                   ;; only if we *haven‚Äôt* already got a space
                   (not (string-match-p " " (buffer-substring (match-beginning 0)
                                                              (match-end 0)))))
          (replace-match (concat stars " " char) t t))))))
#+end_src

* convert markdown to org on paste
#+begin_src emacs-lisp
(defun convert-markdown-headings-to-org (beg end)
  "Turn #, ##, ### etc. at bol into *, **, *** etc. in the region."
  (save-excursion
    (goto-char beg)
    (let ((limit (copy-marker end))
          (in-fence nil))
      (while (< (point) limit)
        (cond
         ((looking-at "^\\s-*```")
          (setq in-fence (not in-fence)))
         ((and (not in-fence)
               (looking-at "^\\s-*\\(#+\\)\\s-+"))
          (replace-match (concat (make-string (length (match-string 1)) ?*) " ")
                         t t)))
        (let ((before (point)))
          (forward-line 1)
          (when (<= (point) before)
            (goto-char limit)))))))

(defun convert-markdown-blockquotes-to-org (beg end)
  "Turn '> ' at bol into ': ' (Org quote) in the region."
  (save-excursion
    (goto-char beg)
    (while (re-search-forward "^> " end t)
      (replace-match ": " t t)))
  )
#+end_src

* isolate Emacs kill ring from the OSX system pasteboard (clipboard).
Very important, I use this all the time.  These are custom functions to separate
the OSX clipboard from Emacs' kill ring, effectively giving me two separate
clipboards to work from. The below are the traditional OSX keybindings for
cut/copy/paste, and they will now work with the OSX clipboard. The yank and pop functions still work, and use the Emacs kill ring instead.


** pasteboard setup
#+BEGIN_SRC emacs-lisp
(setq interprogram-cut-function nil)
(setq interprogram-paste-function nil)
#+END_SRC

** safe
#+begin_src emacs-lisp
(defun safe-replace (pattern replacement beg end)
  "Safely replace PATTERN with REPLACEMENT between BEG and END."
  (save-excursion
    (goto-char beg)
    (let ((last-point beg))
      (while (re-search-forward pattern end t)
        (unless (> (point) last-point)  ; Prevent infinite loops
          (error "Infinite loop detected in regex replacement."))
        (setq last-point (point))
        (replace-match replacement t t)))))

(defun safe-pbpaste ()
  "Run pbpaste with a timeout to prevent hanging."
  (let ((default-directory "/tmp/"))  ; Avoid issues with remote TRAMP paths
    (with-temp-buffer
      (if (zerop (call-process "gtimeout" nil t nil "2" "pbpaste"))  ; Requires coreutils for `gtimeout`
          (buffer-string)
        (error "pbpaste timed out")))))
#+end_src

** different behavior depending on whether I'm working with code or prose

#+begin_src emacs-lisp
(defun pasteboard-copy-adaptive ()
  "Smart copy to macOS pasteboard: choose verbatim vs. cleaned text."
  (interactive)
  (let* ((result
          (cond
           ;; ------------------------------------------ verbatim buckets ------------------------------------------
           ;; 1) Messages buffer - ALWAYS verbatim
           ((string= (buffer-name) "*Messages*")
            (cons "verbatim (Messages buffer)" #'pasteboard-copy-verbatim))
           
           ;; 2) Shell / Elisp / Web / Markdown / Backtrace
           ((or (eq major-mode 'sh-mode)
                (eq major-mode 'emacs-lisp-mode)
                (eq major-mode 'web-mode)
                (eq major-mode 'markdown-mode)
                (eq major-mode 'gfm-mode)
                (derived-mode-p 'markdown-mode)
                (derived-mode-p 'backtrace-mode))
            (cons "verbatim (mode match)" #'pasteboard-copy-verbatim))

           ;; 3) Org buffer **with** org-config-files-local-mode enabled
           ((and (eq major-mode 'org-mode)
                 (bound-and-true-p org-config-files-local-mode))
            (cons "verbatim (org-local)" #'pasteboard-copy-verbatim))

           ;; 4) Any file ending in .mdx
           ((and buffer-file-name
                 (string-match-p "\\.mdx\\'" buffer-file-name))
            (cons "verbatim (.mdx)" #'pasteboard-copy-verbatim))

           ;; 5) Any programming mode
           ((derived-mode-p 'prog-mode)
            (cons "verbatim (prog)" #'pasteboard-copy-verbatim))

           ;; ------------------------------------------ clean buckets ------------------------------------------
           ;; 6) Org or generic text (when org-config-files-local-mode is off)
           ((or (eq major-mode 'text-mode)
                (and (eq major-mode 'org-mode)
                     (not (bound-and-true-p org-config-files-local-mode))))
            (cons "clean" #'pasteboard-copy-and-replace-em-dashes-in-clipboard))

           ;; ---------------------------------------- heuristic fallback --------------------------------------
           ((and (use-region-p)
                 (save-excursion
                   (goto-char (region-beginning))
                   (looking-at-p "\\s-*\\([({[]\\|[#;]\\|https?://\\)")))
            (cons "verbatim (heuristic)" #'pasteboard-copy-verbatim))
           
           (t
            (cons "clean (default)" #'pasteboard-copy-and-replace-em-dashes-in-clipboard))))
         (choice (car result))
         (handler (cdr result)))
    (when handler
      (call-interactively handler))
    (message "Copied text %s" choice)))
#+end_src

** pasteboard-copy

*** pasteboard copy
#+BEGIN_SRC emacs-lisp

(defun pasteboard-copy ()
  "Copy region to OS X system pasteboard."
  (interactive)
  (let* ((txt (buffer-substring (region-beginning) (region-end))))
    (shell-command-to-string
     (format "echo -n %s | pbcopy" (shell-quote-argument txt)))))
#+END_SRC

*** pasteboard copy raw
#+begin_src emacs-lisp
(defun pasteboard-copy-verbatim (beg end)
  "Copy region between BEG and END to the macOS pasteboard verbatim.

Unlike the old echo‚Üípbcopy helper, this uses Emacs' built-in
`x-select-text`, so it follows the identical encoding path that
`kill-region` uses when `x-select-enable-clipboard` is non-nil."
  (interactive "r")
  (unless (use-region-p)
    (user-error "No region selected"))
  ;; Grab the bytes exactly as they live in the buffer.
  (let ((txt (buffer-substring-no-properties beg end)))
    ;; Same function `kill-region` calls under the hood.
    (x-select-text txt))
  (message "Copied %d characters verbatim." (- end beg)))
#+end_src

*** and replace em dashes
#+begin_src emacs-lisp
(defun pasteboard-copy-and-replace-em-dashes-in-clipboard (&optional arg)
  "Copy region to macOS pasteboard.

No ARG ‚Üí behave contextually (verbatim in code, replacement in text).
ARG positive or plain C-u ‚Üí force verbatim.
ARG zero or negative       ‚Üí force replacement."
  (interactive "P")
  (unless (use-region-p)
    (user-error "No region selected"))
  (let* ((txt (buffer-substring-no-properties (region-beginning) (region-end)))
         ;; Decide which behaviour to use.
         (verbatim
          (cond
           ;; Forced by user
           (arg
            (> (prefix-numeric-value arg) 0))
           ;; Heuristic (original behaviour)
           (t (or (derived-mode-p 'prog-mode)
                  (eq major-mode 'shell-script-mode)
                  (eq major-mode 'emacs-lisp-mode)
                  (eq major-mode 'web-mode)
                  (bound-and-true-p org-config-files-local-mode))))))
    (with-temp-buffer
      (insert (if verbatim
                  txt
                (replace-regexp-in-string "\\(---\\|--\\)" "‚Äî" txt)))
      (shell-command-on-region (point-min) (point-max) "pbcopy"))
    (message (if verbatim
                 "Copied text verbatim."
               "Copied text with em dashes."))))
#+end_src

*** to the end
#+begin_src emacs-lisp
(defun pasteboard-copy-to-end-of-buffer ()
  "Copy text from point to the end of the buffer to OS X system pasteboard."
  (interactive)
  (let* ((txt (buffer-substring (point) (point-max))))
    (shell-command-to-string
     (format "echo -n %s | pbcopy" (shell-quote-argument txt)))))

#+end_src

*** pasteboard-copy-and-convert-to-markdown-link
#+BEGIN_SRC emacs-lisp
(defun pasteboard-copy-and-convert-to-markdown-link ()
  "Copy region to OS X system pasteboard, converting Org-style links to Markdown format."
  (interactive)
  (if (use-region-p)
      (let* ((txt (buffer-substring (region-beginning) (region-end)))
             (txt-updated-links
              (replace-regexp-in-string
               "\\[\\[\\([^]]*\\)\\]\\(\\[\\([^]]*\\)\\]\\)?\\]"
               (lambda (m)
                 ;; The match data is set up so match-string works
                 (concat "[" (or (match-string 3 m)
                                 (match-string 1 m))
                         "](" (match-string 1 m) ")"))
               txt)))
        (shell-command-to-string
         (format "echo -n %s | pbcopy" (shell-quote-argument txt-updated-links)))
        (message "Copied and converted Org links to Markdown."))
    (message "No region selected")))
#+END_SRC

** pasteboard-paste

*** pasteboard-paste-adaptive
    #+BEGIN_SRC emacs-lisp
(setq select-enable-clipboard t)
(setq select-enable-primary t)

(defun org-insert-link-from-clipboard (beg end &optional url)
  "Replace text in region with an Org bracket link using the macOS clipboard URL."
  (interactive "r")
  (unless (use-region-p)
    (error "No region selected."))

  (let* ((url (string-trim (or url (pasteboard--clipboard-string))))
         (region-text (buffer-substring-no-properties beg end))
         (bracket-link (format "[[%s][%s]]" url region-text)))
    ;;  (message "DEBUG: In `org-insert-link-from-clipboard`. region-text='%s', url='%s'" region-text url)
    (delete-region beg end)
    (insert bracket-link)))

(defun is-org-roam-buffer-p ()
  "Check if the current buffer is an org-roam buffer by looking for ID property at the beginning."
  (save-excursion
    (goto-char (point-min))
    (and (eq major-mode 'org-mode)
         (looking-at-p "^:PROPERTIES:\n:ID:\\s-+[^\n]+\n:END:"))))

(defun demote-org-headings-in-region (beg end)
  "Demote all Org headings in the region between BEG and END by one level."
  (save-excursion
    (let ((end-marker (copy-marker end)))
      (goto-char beg)
      (while (re-search-forward "^\\(\\*+\\)" end-marker t)
        (let ((stars (match-string 1)))
          (replace-match (concat "*" stars) t t)))
      (set-marker end-marker nil))))

(defun demote-org-headings-adaptive ()
  "Demote all Org headings by one level.
If a region is active, demote only headings within the region.
Otherwise, demote from point to the end of the buffer."
  (interactive)
  (let ((beg (if (use-region-p) (region-beginning) (point)))
        (end (if (use-region-p) (region-end) (point-max))))
    (demote-org-headings-in-region beg end)
    (message "Demoted all headings in %s"
             (if (use-region-p) "region" "buffer from point to end"))))

(defun pasteboard--clipboard-string ()
  "Return the current macOS clipboard as a normalised string."
  (shell-command-to-string "pbpaste | perl -p -e 's/\\r$//' | tr '\\r' '\\n'"))

(defun convert-markdown-links-to-org-mode (beg end)
  "Convert [label](url) style links in region to Org [[url][label]] links."
  (interactive "r")
  (save-excursion
    (let ((end-marker (copy-marker end)))
      (goto-char beg)
      (while (re-search-forward "\\[\\([^][]+\\)\\](\\([^()]+\\))" end-marker t)
        (replace-match "[[\\2][\\1]]" t))
      (set-marker end-marker nil))))

(defun pasteboard--text-contains-markdown-headings-p (text)
  "Return non-nil if TEXT includes Markdown heading markers (##, ###, etc.)."
  (with-temp-buffer
    (insert text)
    (goto-char (point-min))
    (re-search-forward "^[ \t]*#\\{2,6\\}[ \t]+" nil t)))

(defun pasteboard--analyse-clipboard-text (text)
  "Return a plist describing TEXT, detecting whether it looks like Markdown or Org."
  (with-temp-buffer
    (insert text)
    (goto-char (point-min))
    (let ((line-number 1)
          (heading-lines '()))
      (while (not (eobp))
        (when (looking-at "^[ \t]*#[ \t]+")
          (push line-number heading-lines))
        (forward-line 1)
        (cl-incf line-number))
      (let ((md-score 0)
            (org-score 0)
            (asterisk-bullets 0)
            (case-fold-search nil))
        (dolist (spec
                 '((md-score "^[ \t]*#\\{1,6\\} " 3)
                   (md-score "^[ \t]*[-+] \\S-" 1)
                   (md-score "^[ \t]*\\d+\\. \\S-" 1)
                   (md-score "^[ \t]*> " 1)
                   (md-score "^[ \t]*`\\{3\\}" 2)
                   (md-score "\\[[^][]+\\](https?://[^)]+)" 1)
                   (org-score "^[ \t]*#\\+" 3)
                   (org-score "^[ \t]*\\*+ \\(TODO\\|DONE\\|NEXT\\|WAIT\\|HOLD\\|CANCELLED\\|NOTE\\|IDEA\\|FIXME\\|PROJ\\)\\b" 3)
                   (org-score "^[ \t]*\\*+ .*:[[:alnum:]_@#%:]+:[ \t]*$" 2)
                   (org-score "^[ \t]*:PROPERTIES:[ \t]*$" 3)
                   (org-score "^[ \t]*:END:[ \t]*$" 1)
                   (org-score "^[ \t]*SCHEDULED:" 2)
                   (org-score "^[ \t]*DEADLINE:" 2)
                   (org-score "^[ \t]*\\*\\{2,\\} \\S-" 2)))
          (pcase-let ((`(,target ,regex ,weight) spec))
            (goto-char (point-min))
            (while (re-search-forward regex nil t)
              (pcase target
                ('md-score  (cl-incf md-score weight))
                ('org-score (cl-incf org-score weight))))))
        (goto-char (point-min))
        (while (re-search-forward "^[ \t]*\\* \\S-" nil t)
          (cl-incf asterisk-bullets))
        (let ((style
               (cond
                ((>= md-score (+ org-score 2)) 'markdown)
                ((>= org-score (+ md-score 2)) 'org)
                ((and (>= md-score 3) (= org-score 0)) 'markdown)
                ((and (= md-score 0) (> org-score 0)) 'org)
                ((and (>= asterisk-bullets 3) (= org-score 0)) 'markdown)
                (t nil))))
          (list
           :style style
           :markdown-heading-lines (nreverse heading-lines)
           :md-score md-score
           :org-score org-score
           :asterisk-bullets asterisk-bullets))))))

(defun pasteboard--line-kind-at-pos (pos)
  "Return the syntactic 'kind' of line at POS."
  (save-excursion
    (goto-char pos)
    (cond
     ((looking-at "^\\s-*$") 'blank)
     ((looking-at "^[ \t]*\\*\\{2,\\} \\S-") 'org-heading)
     ((looking-at "^[ \t]*\\* \\S-") 'asterisk-bullet)
     ((looking-at "^[ \t]*[-+] \\S-") 'dash-bullet)
     ((looking-at "^[ \t]*\\d+\\. \\S-") 'ordered-bullet)
     ((looking-at "^[ \t]*:") 'definition)
     (t 'text))))

(defun pasteboard--neighbor-nonblank-kind (pos direction)
  "Return the first non-blank line kind from POS in DIRECTION (`prev or `next)."
  (save-excursion
    (goto-char pos)
    (let ((step (pcase direction
                  ('next 1)
                  ('prev -1)
                  (_ (error "Unknown direction %S" direction)))))
      (catch 'result
        (while t
          (let ((status (forward-line step)))
            (when (/= status 0)
              (throw 'result 'none))
            (forward-line 0)
            (unless (looking-at "^\\s*$")
              (throw 'result (pasteboard--line-kind-at-pos (point))))))))))

(defun pasteboard--should-convert-asterisk-line (pos indent skip-lines)
  "Heuristic to decide whether the single-asterisk line at POS should become a dash bullet.
INDENT is the number of leading spaces.  SKIP-LINES is a list of line numbers preserved as headings."
  (let ((line-no (line-number-at-pos pos)))
    (unless (and skip-lines (memq line-no skip-lines))
      (if (> indent 0)
          t
        (let* ((prev-kind (pasteboard--neighbor-nonblank-kind pos 'prev))
               (next-kind (pasteboard--neighbor-nonblank-kind pos 'next))
               (listish '(asterisk-bullet dash-bullet ordered-bullet definition)))
          (or (memq prev-kind listish)
              (memq next-kind listish)))))))

(defun pasteboard--convert-asterisk-bullets-to-dashes (beg end &optional skip-lines)
  "Convert Markdown-style leading '*' bullets to '-' between BEG and END.
SKIP-LINES is a list of 1-based line numbers that should remain untouched."
  (let (targets)
    (save-excursion
      (goto-char beg)
      (while (re-search-forward "^\\([ \t]*\\)\\* \\(.*\\)$" end t)
        (let* ((line-beg (match-beginning 0))
               (line-end (match-end 0))
               (indent-str (match-string 1))
               (body (match-string 2))
               (indent (length indent-str)))
          (when (pasteboard--should-convert-asterisk-line line-beg indent skip-lines)
            (push (list line-beg line-end indent-str body) targets)))))
    (save-excursion
      (dolist (target targets)
        (pcase-let ((`(,line-beg ,line-end ,indent-str ,body) target))
          (goto-char line-beg)
          (delete-region line-beg line-end)
          (insert indent-str "- " body)))))) 

(defun pasteboard--clean-string (text)
  "Apply the same normalisation steps as `pasteboard-paste-clean' to TEXT."
  (let* ((markdown-headings-present (pasteboard--text-contains-markdown-headings-p text))
         (analysis (pasteboard--analyse-clipboard-text text))
         (style (plist-get analysis :style))
         (heading-line-numbers (plist-get analysis :markdown-heading-lines)))
    (when markdown-headings-present
      (setq style 'markdown))
    (with-temp-buffer
      (insert text)
      (let* ((beg (point-min))
             (end (point-max))
             (heading-markers
              (when heading-line-numbers
                (save-excursion
                  (goto-char beg)
                  (let ((current-line 1)
                        (markers nil))
                    (dolist (target heading-line-numbers)
                      (forward-line (- target current-line))
                      (push (copy-marker (line-beginning-position)) markers)
                      (setq current-line target))
                    (nreverse markers))))))
        (unwind-protect
            (progn
              ;; Convert markdown headings FIRST before processing asterisks
              (convert-markdown-headings-to-org beg end)
              (replace-smart-quotes beg end)
              (replace-smart-quotes-regexp beg end)
              (replace-weird-spaces beg end)
              (convert-markdown-blockquotes-to-org beg end)
              (convert-markdown-links-to-org-mode beg end)
              ;; Buffer size may have changed; refresh region bounds before further narrowing.
              (setq beg (point-min)
                    end (point-max))
              (when (eq style 'markdown)
                (save-restriction
                  (narrow-to-region beg end)
                  (let* ((region-beg (point-min))
                         (region-end (point-max))
                         (skip-lines (when heading-markers
                                       (mapcar #'line-number-at-pos heading-markers))))
                    (pasteboard--convert-asterisk-bullets-to-dashes region-beg region-end skip-lines)
                    ;; Fallback: if any single-asterisk lines slipped through, coerce them now.
                    (goto-char region-beg)
                    (while (re-search-forward "^\\([ \t]*\\)\\* \\(.*\\)$" region-end t)
                      (let ((line-no (line-number-at-pos (match-beginning 0))))
                        (unless (and skip-lines (memq line-no skip-lines))
                          (replace-match "\\1- \\2" t))))
                    (when (fboundp 'normalize-dashes)
                      (normalize-dashes))
                    (when (fboundp 'convert-markdown-to-org-code-blocks-simple)
                      (convert-markdown-to-org-code-blocks-simple)))))
              (buffer-string))
          (when heading-markers
            (mapc (lambda (marker) (set-marker marker nil)) heading-markers)))))))

(defun pasteboard--demote-headings-in-string (text)
  "Demote all Org headings found in TEXT by one level."
  (with-temp-buffer
    (insert text)
    (goto-char (point-min))
    (while (re-search-forward "^\\(\\*+\\) " nil t)
      (let ((stars (match-string 1)))
        (replace-match (concat "*" stars " ") t t)))
    (buffer-string)))

(defun pasteboard-paste-adaptive ()
  "Paste from the macOS pasteboard, choosing behaviour based on context while keeping Org's cache stable."
  (interactive)
  (let* ((clipboard-raw (pasteboard--clipboard-string))
         (trimmed (string-trim clipboard-raw))
         (clipboard-text (downcase trimmed))
         choice)
    (cond
     ((and (use-region-p)
           (not (string-empty-p trimmed))
           (string-match-p "\\(https?://\\|www\\.\\)" clipboard-text))
      (setq choice "bracket-link")
      (org-insert-link-from-clipboard (region-beginning) (region-end) trimmed))
     ((or (eq major-mode 'sh-mode)
          (eq major-mode 'python-mode)
          (eq major-mode 'emacs-lisp-mode)
          (eq major-mode 'markdown-mode)
          (eq major-mode 'gfm-mode)
          (derived-mode-p 'markdown-mode)
          (derived-mode-p 'prog-mode)
          (eq major-mode 'web-mode))
      (setq choice "verbatim")
      (pasteboard-paste-verbatim clipboard-raw))
     ((or (and (eq major-mode 'org-mode)
               (not (bound-and-true-p org-config-files-local-mode)))
          (derived-mode-p 'text-mode))
      (setq choice "clean")
      (pasteboard-paste (pasteboard--clean-string clipboard-raw)))
     (t
      (let* ((prev-char (char-before))
             (next-char (char-after))
             (char-set '(?: ?' ?\( ?\) ?| ?\[ ?\] ?/ ?\\ ?\" ?= ?< ?> ?{ ?}))
             (use-no-spaces (or (member prev-char char-set)
                                (member next-char char-set))))
        (if use-no-spaces
            (progn
              (setq choice "paste-raw")
              (pasteboard-paste-verbatim clipboard-raw))
          (setq choice "paste-clean")
          (pasteboard-paste (pasteboard--clean-string clipboard-raw))))))
    (when choice
      (message "Pasted: %s" choice))))

(defun pasteboard-paste (&optional text)
  "Paste TEXT (or the current clipboard) at point, normalising whitespace."
  (interactive)
  (let* ((start (point))
         (end (if mark-active (mark) (point)))
         (ins-text (or text (pasteboard--clipboard-string))))
    (combine-after-change-calls
      (atomic-change-group
        (delete-region start end)
        (insert ins-text)
        (let ((paste-end (point)))
          (my/fix-space)
          (save-excursion
            (goto-char start)
            (my/fix-space))
          (goto-char paste-end))))))
#+END_SRC

*** pasteboard-paste-clean (and without spaces)
#+BEGIN_SRC emacs-lisp
(defun pasteboard-paste-clean (&optional raw text)
  "Paste from the macOS clipboard and normalise the text in a single edit."
  (interactive "P")
  (let* ((source (or text (pasteboard--clipboard-string)))
         (insert-text (if raw source (pasteboard--clean-string source))))
    (pasteboard-paste insert-text)))
#+END_SRC

*** pasteboard-paste-verbatim
#+BEGIN_SRC emacs-lisp
(defun pasteboard-paste-verbatim (&optional text)
  "Paste verbatim text at point, bypassing smart cleanup."
  (interactive)
  (let* ((start (point))
         (end (if mark-active (mark) (point)))
         (ins-text (or text (pasteboard--clipboard-string))))
    (combine-after-change-calls
      (atomic-change-group
        (delete-region start end)
        (insert ins-text)))))


#+END_SRC

*** pasteboard paste and adjust heading levels
#+begin_src emacs-lisp
(defun pasteboard-paste-adjusted-subtrees ()
  "Paste text from the system pasteboard, adjusting Org headings to be subheadings.
This function ensures that all Org-mode headings in the pasted text
are adjusted so they become subheadings under the current Org heading."
  (interactive)
  (let* ((text (shell-command-to-string "pbpaste"))
         ;; Ensure we have the correct current heading level
         (current-level (save-excursion
                          (if (org-before-first-heading-p)
                              0
                            (or (org-current-level)
                                (progn
                                  (org-back-to-heading t)
                                  (org-current-level))
                                0)))))
    ;; Clean up the text by removing carriage returns
    (setq text (replace-regexp-in-string "\r" "" text))
    ;; Adjust the heading levels in the pasted text
    (with-temp-buffer
      (insert text)
      (goto-char (point-min))
      (let ((min-level nil))
        ;; Find the minimum heading level in the pasted text
        (while (re-search-forward "^\\(\\*+\\) " nil t)
          (let ((level (length (match-string 1))))
            (when (or (not min-level) (< level min-level))
              (setq min-level level))))
        (when min-level
          ;; Calculate the shift needed to adjust heading levels
          (let ((shift (- (+ current-level 1) min-level)))
            (goto-char (point-min))
            ;; Adjust each heading in the pasted text
            (while (re-search-forward "^\\(\\*+\\)" nil t)
              (let* ((stars (match-string 1))
                     (level (length stars))
                     (new-level (max 1 (+ level shift))))
                (replace-match (make-string new-level ?*) t t)))))
        ;; Retrieve the adjusted text
        (setq text (buffer-string))))
    ;; Insert the adjusted text at point
    (insert text)))

(defun pasteboard-paste-adjusted-subtrees-adaptive ()
  "Paste from pasteboard using adaptive paste logic, then adjust Org heading levels
to be subheadings under the current heading."
  (interactive)
  (let* ((current-level (save-excursion
                          (if (org-before-first-heading-p)
                              0
                            (or (org-current-level)
                                (progn
                                  (org-back-to-heading t)
                                  (org-current-level))
                                0))))
         (paste-start-pos (point)))
    
    ;; First, use pasteboard-paste-adaptive to get all its smart features
    ;; (markdown conversion, smart quotes, link conversion, etc.)
    (pasteboard-paste-adaptive)
    
    ;; Now adjust the heading levels of what was just pasted
    (let ((paste-end-pos (point)))
      (when (> paste-end-pos paste-start-pos)
        (save-excursion
          (goto-char paste-start-pos)
          ;; Find the minimum heading level in the pasted text
          (let ((min-level nil))
            (while (re-search-forward "^\\(\\*+\\) " paste-end-pos t)
              (let ((level (length (match-string 1))))
                (when (or (not min-level) (< level min-level))
                  (setq min-level level))))
            
            ;; If we found headings, adjust them to be under current heading
            (when min-level
              (let ((shift (- (+ current-level 1) min-level)))
                ;; Only shift if necessary
                (when (not (zerop shift))
                  (goto-char paste-start-pos)
                  (while (re-search-forward "^\\(\\*+\\)" paste-end-pos t)
                    (let* ((stars (match-string 1))
                           (level (length stars))
                           (new-level (max 1 (+ level shift))))
                      (replace-match (make-string new-level ?*) t t))))))))))
    (message "Pasted with adjusted heading levels")))

#+end_src



*** paste adjusted subtrees adaptive

doesn't work yet

it doesn't do the adjusted subtrees

o3
#+BEGIN_EXAMPLE emacs-lisp
;;;; ------------------------------------------------------------
;;;; 1.  Grab‚Äëadaptive helper ‚Äì NO side‚Äëeffects in current buffer
;;;; ------------------------------------------------------------

(defun pasteboard--adaptive-as-string ()
  "Return the text that `pasteboard-paste-adaptive' would insert,
without modifying the current buffer."
  (with-temp-buffer
    ;; Give the temp buffer the same major mode you‚Äôre in so the
    ;; adaptive logic follows the same code paths.
    (let ((major-mode major-mode)) (funcall major-mode))
    (pasteboard-paste-adaptive)      ; inserts into *this* temp buffer
    (buffer-string)))                ; hand the text back as a string

;;;; ------------------------------------------------------------
;;;; 2.  Your subtree‚Äëadjusting paste, now using the helper above
;;;; ------------------------------------------------------------

(defun pasteboard-paste-adjusted-subtrees-adaptive ()
  "Paste Org text from the clipboard, shift headings so they
become sub‚Äëheadings of the point‚Äôs heading, and handle spacing
around punctuation (borrows adaptive‚Äëpaste logic)."
  (interactive)
  (let* ((text (pasteboard--adaptive-as-string))  ; << changed line
         (current-level
          (save-excursion
            (if (org-before-first-heading-p) 0
              (or (org-current-level)
                  (progn (org-back-to-heading t) (org-current-level))
                  0))))
         (prev-char (char-before))
         (next-char (char-after))
(char-set
       '( ?:  ?'  ?\( ?\)  ?|  ?\[ ?\]  ?/  ?\\  ?\"  ?=  ?<  ?>  ?{  ?}  ?$ )))

    ;; Clean up CL‚Äëstyle CRs that sometimes appear in pbpaste output
    (setq text (replace-regexp-in-string "\r" "" text))

    ;; ---------- Re‚Äëlevel the pasted subtree ----------
    (with-temp-buffer
      (insert text)
      (goto-char (point-min))
      (let ((min-level nil))
        (while (re-search-forward "^\$begin:math:text$\\\\*+\\$end:math:text$ " nil t)
          (let ((level (length (match-string 1))))
            (when (or (null min-level) (< level min-level))
              (setq min-level level))))
        (when min-level
          (let ((shift (- (+ current-level 1) min-level)))
            (goto-char (point-min))
            (while (re-search-forward "^\$begin:math:text$\\\\*+\\$end:math:text$" nil t)
              (let* ((stars (match-string 1))
                     (level (length stars))
                     (new-level (max 1 (+ level shift))))
                (replace-match (make-string new-level ?*) t t))))))
      (setq text (buffer-string)))

    ;; ---------- Insert + straight‚Äëquote replacements ----------
    (let ((start (point)))
      (insert text)
      (let ((end-pos (point)))
        (unless (or (member prev-char char-set)
                    (member next-char char-set))
          (save-excursion
            (goto-char start)
            (while (ignore-errors (re-search-forward "['‚Äô]" end-pos t))
              (replace-match "'" t t))
            (goto-char start)
            (while (ignore-errors (re-search-forward "[\"‚Äú‚Äù]" end-pos t))
              (replace-match "\"" t t))))))))
#+END_EXAMPLE


** pasteboard-cut
#+BEGIN_SRC emacs-lisp
(defun pasteboard-cut ()
  "Cut region and put on OS X system pasteboard."
  (interactive)
  (pasteboard-copy)
  (delete-region (region-beginning) (region-end))
  (my/fix-space)
  )

(defun pasteboard-cut-and-capitalize ()
  "Cut region and put on OS X system pasteboard."
  (interactive)
  (pasteboard-copy)
  (delete-region (region-beginning) (region-end))
  (my/fix-space)
  (save-excursion
    (when (my/beginning-of-sentence-p)
      (capitalize-unless-org-heading))))

(defun pasteboard-cut-and-capitalize-and-replace-em-dashes ()
  "Cut region and put on OS X pasteboard, replacing dash sequences with em dashes.
Then delete the region, fix spacing, and, if at the beginning of a sentence,
capitalize the text (unless it's an Org heading)."
  (interactive)
  ;; Use the copy-and-replace function instead of pasteboard-copy.
  (pasteboard-copy-and-replace-em-dashes-in-clipboard)
  (delete-region (region-beginning) (region-end))
  (my/fix-space)
  (save-excursion
    (when (my/beginning-of-sentence-p)
      (capitalize-unless-org-heading))))

(defun pasteboard-cut-and-capitalize-and-replace-em-dashes-maybe ()
  "Cut region and put it on the OS X pasteboard using a command selected by the current mode.

When working with prose (in `org-mode` without `org-config-files-local-mode`
or in a mode derived from `text-mode`), replace dash sequences with em dashes.
When working with code (any mode other than `org-mode` or in `org-mode` when
`org-config-files-local-mode` is active), cut region and copy verbatim by calling
`pasteboard-cut-and-capitalize`."
  (interactive)
  (if (or (and (eq major-mode 'org-mode)
               (not (bound-and-true-p org-config-files-local-mode)))
          (derived-mode-p 'text-mode))
      (pasteboard-cut-and-capitalize-and-replace-em-dashes)
    (pasteboard-cut-and-capitalize)))
#+END_SRC




* wrapped-search-forward
#+BEGIN_SRC emacs-lisp

(defvar-local failed-search nil)

(defun wrapped-search-forward (str)
  (interactive "sWrappedSearch:")
  (if (and
       failed-search
       (>= (car failed-search) (point))
       (string-equal (cdr failed-search) str))
      (let ((p (save-excursion
                 (goto-char 0)
                 (search-forward str nil t))))
        (if p
            (progn
              (goto-char p)
              (setq-local failed-search nil))
          (message "WrappedSearch: Not found.")))
    (let ((p (search-forward str nil t)))
      (unless p
        (setq-local failed-search (cons (point) str))
        (message "Search: Not found.")))))

#+END_SRC
** pasteboard-search-for-clipboard-contents
#+BEGIN_SRC emacs-lisp
(defun pasteboard-search-for-clipboard-contents ()
  (interactive)
  (let ((search-term
         (with-temp-buffer
          (pasteboard-paste-verbatim)
           (buffer-string))))
    (wrapped-search-forward search-term)))

#+END_SRC

** kill ring to pasteboard functions
*** push kill ring to MacOS pasteboard
  #+BEGIN_SRC emacs-lisp
(setq x-select-enable-clipboard t)

(defun push-kill-ring-pasteboard-to-MacOS-clipboard ()
  (interactive)
  (x-select-text (current-kill 0)))
  #+END_SRC

*** push MacOS pasteboard to kill ring
#+begin_src emacs-lisp
(defun push-MacOS-clipboard-to-kill-ring ()
 "Push the content of the MacOS clipboard to the Emacs kill ring."
 (interactive)
 (let ((clipboard-content (shell-command-to-string "pbpaste")))
  (when (and clipboard-content (not (string= clipboard-content "")))
   (kill-new clipboard-content)
   (message "Pushed clipboard content to kill ring: %s" clipboard-content))))
#+end_src

*** gist-buffer-to-pasteboard
  #+BEGIN_SRC emacs-lisp
(defun gist-buffer-to-pasteboard ()
  (interactive)
  (gist-buffer)
  (push-kill-ring-pasteboard-to-MacOS-clipboard)
  )
  #+END_SRC



* Local Variables & The End
These have to be at the end.

# Local Variables:
# org-config-files-local-mode: t
# enable-local-eval: t
# eval: (org-config-files-local-mode 1)
# End:
