* file settings                                                     :ARCHIVE:
#+OPTIONS: f:t
#+ TODO: TODO PLEASE-TEST TESTING PLEASE-DEBUG | DONE
#+TODO: | NOTE-TO-JAY NOTE-TO-RUDI NOTE-TO-RÚDI
#+TODO: PLEASE-CHECK-MY-INEPT-CODE PLEASE-HELP-ME-DEBUG-MY-INEPT-CODE TRY-THIS | DONE

#+TITLE: #+TITLE: Jay Dixit's GNU Emacs setup
#+TITLE: Jay Dixit's GNU Emacs setup
* environment settings
** Handle Emacs UTF-8 input

#+BEGIN_SRC emacs-lisp
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
(setenv "LANG" "en_US.UTF-8")
#+END_SRC

** Sticky windows
#+BEGIN_SRC emacs-lisp
(global-set-key [(control x) (?0)] 'delete-other-windows)
(global-set-key [(control x) (?9)] 'sticky-window-keep-window-visible)
(global-set-key  (kbd "s-0") 'delete-window)
(global-set-key  (kbd "s-1") 'delete-other-windows)
(global-set-key  (kbd "s-9") 'sticky-window-keep-window-visible)
(global-set-key  (kbd "s-2") 'split-window-vertically)
(global-set-key  (kbd "s-3") 'split-window-horizontally)
#+END_SRC

* abbreviations
Automatically load abbreviations table:
#+BEGIN_SRC emacs-lisp
(setq-default abbrev-mode t)
(read-abbrev-file "/Users/jay/emacs/aquamacs-jay/.abbrev_defs")
(setq abbrev-file-name "/Users/jay/emacs/aquamacs-jay/.abbrev_defs")
(setq save-abbrevs t)
(setq save-abbrevs 'silently)
(setq only-global-abbrevs t)
#+END_SRC

* reflash-indentation
#+BEGIN_SRC emacs-lisp
(defun reflash-indentation ()
  "Fix spacing on the screen."
  (interactive)
  (org-indent-mode 1)
  (recenter-top-bottom)
  )
#+END_SRC

* org predicates
  #+BEGIN_SRC emacs-lisp
(use-package org-element
:defer
  )

  (defun org-checkbox-p ()
  "Predicate: Checks whether the current line org-checkbox"
    (and
;; (org-or-orgalist-p)
      (string-match "^\s*\\([-+*]\\|[0-9]+[.\\)]\\)\s\\[.?\\]\s" (or (thing-at-point 'line) ""))))

  (defun org-plain-text-list-p ()
  "Predicate: Checks whether the current line org-plain-text-list"
    (and
;; (org-or-orgalist-p)
      (string-match "^\s*\\([-+]\\|\s[*]\\|[0-9]+[.\\)]\\)\s" (or (thing-at-point 'line) ""))))
  #+END_SRC

* org-mode hooks
  #+BEGIN_SRC emacs-lisp
(setq org-hierarchical-todo-statistics nil)
  #+END_SRC


* fullscreen settings

[[http://amitp.blogspot.ca/2008/05/emacs-full-screen-on-mac-os-x.html][(Source)]]

#+BEGIN_SRC emacs-lisp
(defvar maxframe-maximized-p nil "maxframe is in fullscreen mode")

(defun toggle-maxframe ()
  "Toggle maximized frame"
  (interactive)
  (setq maxframe-maximized-p (not maxframe-maximized-p))
  (cond (maxframe-maximized-p (maximize-frame))
        (t (restore-frame))))

(define-key global-map [(s-return)] 'toggle-maxframe)
;; make it easy to go fullscreen
(defun toggle-fullscreen ()
  "Toggle full screen"
  (interactive)
  (set-frame-parameter
   nil 'fullscreen
   (when (not (frame-parameter nil 'fullscreen)) 'fullboth)))

;; and the keybinding
(unless (fboundp 'toggle-frame-fullscreen)
  (global-set-key (kbd "<f11>") 'toggle-fullscreen))
(unless (fboundp 'toggle-frame-fullscreen)
  (global-set-key (kbd "<f17>") 'toggle-fullscreen))

  (global-set-key (kbd "<f17>") 'toggle-fullscreen)

#+END_SRC


* tabbar
So Emacs text doesn't appear on the MacBook Pro notch.

#+begin_src emacs-lisp
(use-package tab-bar
:defer
 :config
 (tab-bar-mode 1))
 #+end_src


#+begin_src emacs-lisp
(defun my-toggle-tab-bar-mode ()
 "Toggle `tab-bar-mode' based on the current frame fullscreen state in order to hide the MacBook Pro notch when in fullscreen mode."
 (if (frame-parameter nil 'fullscreen)
  (tab-bar-mode 1)
 (tab-bar-mode -1)))

(add-hook 'window-configuration-change-hook #'my-toggle-tab-bar-mode)
#+end_src


* directory settings

There is probably a lot of redundancy here, I don't understand this stuff too
well.

#+BEGIN_SRC emacs-lisp

;; (use-package dired-details+)



;; (defadvice dired-readin
;;     (after dired-after-updating-hook first () activate)
;;   "Sort dired listings with directories first before adding marks."
;;   (mydired-sort)
;;   (let ((dired-details-internal-overlay-list  ())) (dired-details-hide)))

(defcustom dired-details-hidden-string ""
  "*This string will be shown in place of file details and symbolic links."
  :group 'dired-details
  :type 'string)

(defcustom dired-details-initially-hide t
  "*Hide dired details on entry to dired buffers."
  :group 'dired-details
  :type 'boolean)
#+END_SRC

* other functions

Manually remove the scrollbar if default setting fails when creating a new frame:

#+BEGIN_SRC emacs-lisp
(defun scrollbar-init ()
  (interactive)
  (scroll-bar-mode -1)
  )

(defun scrollbar-mode-turn-off-scrollbar ()
  (interactive)
  (scroll-bar-mode -1)
  )

(defun scrollbar-mode-turn-on-scrollbar ()
  (interactive)
  (scroll-bar-mode 1)
  )
#+END_SRC

Forgot what this does, I think it's in case Emacs crashes maybe to recover
autosaves?
#+BEGIN_SRC emacs-lisp
(defadvice recover-session (around disable-dired-omit-for-recover activate)
  (let ((dired-mode-hook dired-mode-hook))
    (remove-hook 'dired-mode-hook 'enable-dired-omit-mode)
    ad-do-it))
#+END_SRC

* isolate Emacs kill ring from the OSX system pasteboard (clipboard).

Very important, I use this all the time.  These are custom functions to separate
the OSX clipboard from Emacs' kill ring, effectively giving me two separate
clipboards to work from. The below are the traditional OSX keybindings for
cut/copy/paste, and they will now work with the OSX clipboard. The yank and pop functions still work, and use the Emacs kill ring instead.


** pasteboard setup
#+BEGIN_SRC emacs-lisp
(setq interprogram-cut-function nil)
(setq interprogram-paste-function nil)
#+END_SRC

** pasteboard-copy
#+BEGIN_SRC emacs-lisp
(defun pasteboard-copy ()
  "Copy region to OS X system pasteboard."
  (interactive)
  (let* ((txt (buffer-substring (region-beginning) (region-end)))
         (txt-updated-links
          (replace-regexp-in-string
           "\\[\\[\\([^]]*\\)\\]\\(\\[\\([^]]*\\)\\]\\)?\\]"
           (lambda (m)
             (concat "[" (or (match-string 3 m)
                             (match-string 1 m))
                     "](" (match-string 1 m) ")"))
           txt)))
;; (message "Copied: %s" txt-updated-links)
    (shell-command-to-string
     (format "echo -n %s | pbcopy" (shell-quote-argument txt-updated-links)))))
#+END_SRC

** pasteboard-paste

*** pasteboard-paste (with smart quotes by default)
#+BEGIN_SRC emacs-lisp
(defun pasteboard-paste ()
  "Paste from OS X system pasteboard via `pbpaste' to point."
  (interactive)
  (let ((start (point))
        (end (if mark-active
                (mark)
                (point)))
        (ins-text
         (replace-regexp-in-string
          "\\[\\([^][]*\\)\\](\\([^)]*\\))"
          (lambda (m)
             (let ((m1 (match-string 1 m))
                   (m2 (match-string 2 m)))
                (if (string= m1 m2)
                  (concat "[[" m1 "]]")
                  (concat "[[" m2 "][" m1 "]]"))))
          (shell-command-to-string "pbpaste | perl -p -e 's/\r$//' | tr '\r' '\n'"))))
    (delete-region start end)
    (insert ins-text)
    (my/fix-space)
    (save-excursion
     (goto-char start)
     (my/fix-space)))
  ; (reflash-indentation)
  )
#+END_SRC

*** pasteboard-paste-without-smart-quotes (and without spaces)
#+BEGIN_SRC emacs-lisp
(defun pasteboard-paste-without-smart-quotes ()
  (interactive)
  (let ((beg (point)))
    (pasteboard-paste)
    (replace-smart-quotes beg (point))))
#+END_SRC

*** pasteboard-paste-spaces-maybe
    #+BEGIN_SRC emacs-lisp
(defun pasteboard-paste-spaces-maybe ()
(interactive)
;; begin if
(if
(or
(looking-back "'")
(looking-back ":")
(looking-at "'")
(looking-back "(")
(looking-back "'")
(looking-at ")")
(looking-at "|")
(looking-back "|")
(looking-back "\\[")
(looking-at "\\]")
(looking-at "\\/")
(looking-at "\\\\")
(looking-back "\\\\")
(looking-back "/")
(looking-back "\"")
(looking-at "\"")
(looking-back "\"")
(looking-back "=")
(looking-at "<")
(looking-back "<")
(looking-at "<")
(looking-back ">")
(looking-at "{")
(looking-back "{")
(looking-at "}")
(looking-back "}")
)
;; end if

    (pasteboard-paste-no-spaces) ; then
  (pasteboard-paste-without-smart-quotes))   ; else
  )
    #+END_SRC

*** pasteboard-paste-no-spaces - original working version
#+BEGIN_SRC emacs-lisp
(defun pasteboard-paste-no-spaces ()
  "Paste from OS X system pasteboard via `pbpaste' to point."
  (interactive)
  (let ((start (point))
	(end (if mark-active
		 (mark)
	       (point))))
    (shell-command-on-region start end
			     "pbpaste | perl -p -e 's/\r$//' | tr '\r' '\n'"
			     nil t)
    (save-excursion
      )))
#+END_SRC

** pasteboard-cut

#+BEGIN_SRC emacs-lisp
(defun pasteboard-cut ()
  "Cut region and put on OS X system pasteboard."
  (interactive)
  (pasteboard-copy)
  (delete-region (region-beginning) (region-end))
  (my/fix-space)
  )

(defun pasteboard-cut-and-capitalize ()
  "Cut region and put on OS X system pasteboard."
  (interactive)
  (pasteboard-copy)
  (delete-region (region-beginning) (region-end))
  (my/fix-space)
  (save-excursion
    (when (my/beginning-of-sentence-p)
      (capitalize-unless-org-heading))))
#+END_SRC

** wrapped-search-forward
#+BEGIN_SRC emacs-lisp

(defvar-local failed-search nil)

(defun wrapped-search-forward (str)
  (interactive "sWrappedSearch:")
  (if (and
       failed-search
       (>= (car failed-search) (point))
       (string-equal (cdr failed-search) str))
      (let ((p (save-excursion
                 (goto-char 0)
                 (search-forward str nil t))))
        (if p
            (progn
              (goto-char p)
              (setq-local failed-search nil))
          (message "WrappedSearch: Not found.")))
    (let ((p (search-forward str nil t)))
      (unless p
        (setq-local failed-search (cons (point) str))
        (message "Search: Not found.")))))

#+END_SRC
** pasteboard-search-for-clipboard-contents
#+BEGIN_SRC emacs-lisp
(defun pasteboard-search-for-clipboard-contents ()
  (interactive)
  (let ((search-term
         (with-temp-buffer
           (pasteboard-paste-no-spaces)
           (buffer-string))))
    (wrapped-search-forward search-term)))

#+END_SRC

* kill ring to pasteboard functions
** push kill ring to OSX pasteboard
  #+BEGIN_SRC emacs-lisp
(setq x-select-enable-clipboard t)
(defun push-kill-ring-pasteboard-to-clipboard ()
  (interactive)
  (x-select-text (current-kill 0)))
  #+END_SRC

** gist-buffer-to-pasteboard
  #+BEGIN_SRC emacs-lisp
(defun gist-buffer-to-pasteboard ()
  (interactive)
  (gist-buffer)
  (push-kill-ring-pasteboard-to-clipboard)
  )
  #+END_SRC

* keybindings

** Create custom keybinding prefix

#+BEGIN_QUOTE
I have an unconventional approach to this that I recommend highly. I have redefined the C-l ('ell') key to be a prefix key, and I use that to prefix my favorite commands. This key is very easy to type and it is bound to a function ('recenter) that isn't used that much. Well, I don't use 'recenter much, but even if you did, it can be assigned to C-l C-l which is almost as easy to type, and a small price to pay for the possibilities opened up by the Ctrl-L-map. (Actually I prefer 'redraw-display to 'recenter, so I gave that the place of honor.)
#+END_QUOTE
Source: [[http://stackoverflow.com/questions/5682631/what-are-good-custom-keybindings-in-emacs/5682737#5682737][ LenW's answer on keyboard - What are good custom keybindings in emacs? - Stack Overflow]]

Use ⌘-m as prefix for my own custom keybindings:
#+BEGIN_SRC emacs-lisp
(global-unset-key (kbd "s-j"))
(defvar s-j-map (make-keymap)
  "Keymap for local bindings and functions, prefixed by (Command-M)")
(define-key global-map (kbd "s-j") 's-j-prefix)
(fset 's-j-prefix s-j-map)
#+END_SRC


** NOTE-TO-JAY TODO Custom keybindings

Eventually replace these with this? https://github.com/noctuid/general.el



#+BEGIN_SRC emacs-lisp
;; create a custom minor mode to override other keybindings and use mine instead
(defvar key-minor-mode-map (make-keymap) "key-minor-mode keymap.")
(define-minor-mode key-minor-mode
  "A minor mode so that my key settings override annoying major modes."
  t " key" 'key-minor-mode-map)
(key-minor-mode 1)
(defun my-minibuffer-setup-hook ()
  (key-minor-mode 0))
(add-hook 'minibuffer-setup-hook 'my-minibuffer-setup-hook)

;; unbind some existing keybindings
;; (define-key undo-tree-map (kbd "C-x r") nil)

;; and the keybindings
;; mk - mykeybindings

(define-key key-minor-mode-map (kbd "M-3") 'number-region)

(define-key key-minor-mode-map (kbd "s-g") 'consult-grep)

(define-key key-minor-mode-map [mouse-2] 'iloveyou)

(define-key key-minor-mode-map (kbd "M-j") 'aide-openai-complete-buffer-insert)

(define-key key-minor-mode-map (kbd "C-c C-x C-r") 'org-clock-report)

(define-key key-minor-mode-map (kbd "s-j r t") 'org-render-table-at-point)

(define-key key-minor-mode-map (kbd "s-j m c") 'multiple-cursors-reflash)

(define-key key-minor-mode-map (kbd "s-J") 'dired-jump)

(define-key key-minor-mode-map (kbd "s-j n s") 'yas/new-snippet)
(define-key key-minor-mode-map (kbd "s-j y n") 'yas/new-snippet)

(define-key help-mode-map (kbd "C-s-]") 'help-go-back)
(define-key key-minor-mode-map (kbd "C-s-]") 'help-go-forward)


(define-key key-minor-mode-map (kbd "s-j c m") 'css-mode)
;; (define-key css-mode-map (kbd "s-j c s") 'css-mode)
(define-key key-minor-mode-map (kbd "s-j s h") 'sh-mode)
(define-key key-minor-mode-map (kbd "s-j s m") 'sh-mode)

(define-key key-minor-mode-map (kbd "s-k") 'kill-buffer)

(define-key key-minor-mode-map (kbd "s-i") 'avy-goto-char)
;; (define-key key-minor-mode-map (kbd "s-p") 'org-html-export-to-html-and-open)


;; (define-key key-minor-mode-map (kbd "M-y") 'helm-show-kill-ring)

(define-key key-minor-mode-map (kbd "M-h M-k") 'describe-key)

(define-key key-minor-mode-map (kbd "s-M") 'visit-messages-buffer)

(defun visit-messages-buffer ()
(interactive)
()
  (interactive)
  (view-echo-area-messages)
(other-window 1)
)


;; (define-key key-minor-mode-map (kbd "s-p") 'move-region-to-other-window)

(defun visit-messages-buffer-full-screen ()
  (interactive)
  (with-current-buffer (messages-buffer)
  (goto-char (point-max))
  (switch-to-buffer (current-buffer)))
  )

(define-key key-minor-mode-map (kbd "<s-backspace>") 'kill-region)

(define-key key-minor-mode-map (kbd "s-j t c") 'org-table-create)

(define-key key-minor-mode-map (kbd "C-;") 'org-def)

(define-key flyspell-mode-map (kbd "C-;") 'org-def)

(define-key key-minor-mode-map (kbd "s-j u p") 'unfill-paragraph)

(define-key key-minor-mode-map (kbd "C-w") 'copy-region-as-kill)

;; (define-key key-minor-mode-map (kbd "=") 'insert-equals-sign)

(define-key key-minor-mode-map (kbd "s-j w s") 'isearch-forward-word)

(define-key key-minor-mode-map (kbd "s-f") 'isearch-forward-ignore-case)

; (define-key key-minor-mode-map (kbd "s-f") 'avy-goto-char-timer)

(define-key key-minor-mode-map (kbd "s-j w m") 'whitespace-mode)

(define-key key-minor-mode-map (kbd "s-j h l") 'spacemacs/toggle-highlight-current-line-globally-off)

(define-key key-minor-mode-map (kbd "s-j r b") 'revert-buffer)

(define-key key-minor-mode-map (kbd "s-j s b") 'scrollbar-mode-turn-off-scrollbar)

(define-key key-minor-mode-map (kbd "s-j i l") 'imenu-list)
(define-key key-minor-mode-map (kbd "s-j i m") 'imenu-list)

(define-key key-minor-mode-map (kbd "s-j g t") 'google-translate-at-point)

(define-key key-minor-mode-map (kbd "M-?") 'insert-question-mark)


(define-key key-minor-mode-map (kbd "<s-S-down>") 'scratch)


(define-key key-minor-mode-map (kbd "s-j g a") 'adobe-garamond-pro)
(define-key key-minor-mode-map (kbd "s-j ag") 'adobe-garamond-pro)
(define-key key-minor-mode-map (kbd "s-j gf") 'adobe-garamond-pro)
(define-key key-minor-mode-map (kbd "s-j mf") 'monaco-font)
(define-key key-minor-mode-map (kbd "s-j mo") 'monaco-font)

(define-key key-minor-mode-map (kbd "s-j t t") 'toggle-between-src-and-example-block)

;; working with an external monitor
(define-key key-minor-mode-map (kbd "s-n") 'make-frame)
;; (define-key key-minor-mode-map (kbd "s-~") 'other-frame)


(define-key key-minor-mode-map (kbd "s-`") 'other-window-or-frame)


(define-key key-minor-mode-map (kbd "C-x C-d") 'dired)

(define-key key-minor-mode-map (kbd "s-j c p") 'path-copy-path-to-kill-ring)


(define-key org-mode-map (kbd "s-j c s") 'org-clone-subtree)
(define-key key-minor-mode-map (kbd "s-j p s") 'org-paste-subtree)
(define-key key-minor-mode-map (kbd "s-j v") 'org-paste-subtree)
(define-key key-minor-mode-map (kbd "s-j x") 'org-cut-subtree)
(define-key key-minor-mode-map (kbd "s->") 'org-mark-subtree)


(define-key key-minor-mode-map (kbd "M-'") 'insert-one-double-quote)
(define-key key-minor-mode-map (kbd "M-s-.") 'mark-paragraph)

(define-key key-minor-mode-map (kbd "M-_") 'em-dash)

(define-key key-minor-mode-map (kbd "s-/") 'rgrep)

(define-key key-minor-mode-map (kbd "C-v") 'html2org-clipboard)


(define-key key-minor-mode-map (kbd "s-r") 'counsel-recentf)

(define-key key-minor-mode-map (kbd "M-.") 'insert-period)
(define-key key-minor-mode-map (kbd "M-,") 'insert-comma)


(define-key key-minor-mode-map (kbd "s-j g b") 'gist-buffer-to-pasteboard)

;; (define-key key-minor-mode-map (kbd "<M-s-up>") 'scroll-down-command)
;; (define-key key-minor-mode-map (kbd "<M-s-down>") 'scroll-up-command)


(define-key key-minor-mode-map (kbd "M-s b") 'book-search)
(define-key key-minor-mode-map (kbd "M-s c") 'current-buffers-search)


;; (define-key key-minor-mode-map (kbd "s-;") 'helm-resume)
(define-key key-minor-mode-map (kbd "s-j o m") 'org-mode)
(define-key key-minor-mode-map (kbd "s-j f m") 'fundamental-mode)
(define-key key-minor-mode-map (kbd "s-j e l") 'emacs-lisp-mode)


(define-key key-minor-mode-map (kbd "s-j w c") 'wc-mode)
(define-key key-minor-mode-map (kbd "s-j o c") 'org-wc-count-subtrees)
(define-key key-minor-mode-map (kbd "s-j o c") 'org-wc-display)

(global-set-key (kbd "C-c m") 'compose-mail)
;; (global-set-key (kbd "C-c m") 'yale-or-vivovii-compose)


(define-key key-minor-mode-map (kbd "s-j m b") 'menu-bar-mode)

(define-key key-minor-mode-map (kbd "s-m") 'mc/mark-all-like-this)

(define-key key-minor-mode-map (kbd "s-j d c") 'org-table-delete-column)
(define-key key-minor-mode-map (kbd "s-j i c") 'org-table-insert-column)
(define-key key-minor-mode-map (kbd "s-j i r") 'org-table-insert-row)


;; mu4e-gmail
;; (define-key key-minor-mode-map (kbd "s-L") 'mu4e-gmail)
(define-key key-minor-mode-map (kbd "]gi") 'mu4e-gmail)
(define-key key-minor-mode-map (kbd "]gm") 'mu4e-gmail)



;; don't know why this stopped working
(define-key key-minor-mode-map (kbd "C-c C-x <C-i>") 'org-clock-in)
(define-key key-minor-mode-map (kbd "C-c C-x <C-i>") 'org-clock-in)


(define-key key-minor-mode-map (kbd "M-s-=") 'calc-eval-region)

(define-key key-minor-mode-map (kbd "s-j p m") 'poetry-mode)

;; (define-key key-minor-mode-map (kbd "s-p") 'zin/org-checkbox-next)

(define-key key-minor-mode-map (kbd "<f20>") 'pomodoro-start-jay)
(define-key key-minor-mode-map (kbd "s-j p o") 'pomodoro-start-jay)



(define-key key-minor-mode-map (kbd "<C-s-left>") 'work-on-book)



(define-key key-minor-mode-map (kbd "s-j t d") 'jd-org-today)
(define-key key-minor-mode-map (kbd "s-j c i") 'jd-clock-in)



;; (define-key key-minor-mode-map (kbd "s-.") 'org-select-line)
(define-key key-minor-mode-map (kbd "C-.") 'searchlink)


;; (define-key key-minor-mode-map (kbd "s-p") 'jay-refile-region)

(define-key key-minor-mode-map (kbd "M-0") 'copy-region-to-other-window)


(define-key key-minor-mode-map (kbd "s-b") 'narrow-or-widen-dwim)
                                        ; org-narrow-to-subtree

;; (define-key key-minor-mode-map (kbd "s-B") 'helm-mini)


(define-key key-minor-mode-map (kbd "C-x <return> RET") 'mc/mark-all-dwim)

;; (define-key key-minor-mode-map (kbd "s-H") 'hyperbole)

(define-key key-minor-mode-map (kbd "M-e") 'smart-forward-sentence)

(define-key key-minor-mode-map (kbd "M-q") 'prelude-switch-to-previous-buffer)

(define-key key-minor-mode-map (kbd "s-]") 'org-forward-heading-same-level)
(define-key key-minor-mode-map (kbd "s-[") 'org-backward-heading-same-level)


(define-key key-minor-mode-map (kbd "C-M-]") 'org-next-subtree-and-narrow)
(define-key key-minor-mode-map (kbd "C-M-[") 'org-previous-subtree-and-narrow)

(define-key key-minor-mode-map (kbd "C-]") 'org-next-subtree-same-level-and-narrow)

(define-key key-minor-mode-map (kbd "ESC ESC") 'org-previous-subtree-same-level-and-narrow)


(define-key key-minor-mode-map (kbd "s-F") 'pasteboard-search-for-clipboard-contents)

(define-key key-minor-mode-map (kbd "M-\"") 'open-abbrevs)

(define-key key-minor-mode-map (kbd "s-|") 'path-copy-path-to-clipboard)

(define-key key-minor-mode-map (kbd "<s-return>") 'toggle-fullscreen)

;; (define-key key-minor-mode-map (kbd "s-v") 'pasteboard-paste-without-smart-quotes)
;; (define-key orgalist-mode-map (kbd "s-v") 'pasteboard-paste-without-smart-quotes)
(global-set-key (kbd "s-v") 'pasteboard-paste-no-spaces)
(define-key org-mode-map (kbd "s-v") 'pasteboard-paste-spaces-maybe)
;; (define-key orgalist-mode-map (kbd "s-v") 'pasteboard-paste-spaces-maybe)
;; (define-key fundamental-mode-map (kbd "s-v") 'pasteboard-paste-without-smart-quotes)
(define-key text-mode-map (kbd "s-v") 'pasteboard-paste-without-smart-quotes)
;; (define-key markdown-mode-map (kbd "s-v") 'pasteboard-paste-without-smart-quotes)

;; (define-key sh-mode-map (kbd "s-v") 'pasteboard-paste-no-spaces)
(define-key emacs-lisp-mode-map (kbd "s-v") 'pasteboard-paste-no-spaces)
(define-key key-minor-mode-map (kbd "C-s-v") 'html2org-clipboard)
(define-key key-minor-mode-map (kbd "C-s-c") 'ox-clip-formatted-copy)
(define-key key-minor-mode-map (kbd "M-v") 'html2org-clipboard)


(define-key key-minor-mode-map (kbd "s-x") 'pasteboard-cut-and-capitalize)
(define-key key-minor-mode-map (kbd "s-c") 'pasteboard-copy)
(define-key key-minor-mode-map (kbd "s-V") 'pasteboard-paste-no-spaces)


(define-key emacs-lisp-mode-map (kbd "s-v") 'pasteboard-paste-no-spaces)
;; (define-key rebuilder-mode-map (kbd "s-v") 'pasteboard-paste-no-spaces)


(define-key key-minor-mode-map (kbd "s-h") 'replace-string)

(global-unset-key (kbd "C-S-r"))
(define-key key-minor-mode-map (kbd "C-S-r") nil)
(define-key org-mode-map (kbd "C-S-r") nil)


(define-key key-minor-mode-map (kbd "M-s-g") 'gnugol-word-at-point)
(define-key key-minor-mode-map (kbd "M-s-d") 'define-word-at-point)


(define-key key-minor-mode-map (kbd "C-s-o") 'dired-jump)

;; (define-key org-mode-map (kbd "s-O") 'uo-byword-file)


(define-key org-mode-map (kbd "s-O") 'reveal-in-finder)


;; pop mark
(define-key key-minor-mode-map (kbd "C-x p")'pop-to-mark-command)

;; projectile
;; (define-key key-minor-mode-map (kbd "s-P") 'projectile-commander)

(define-key key-minor-mode-map (kbd "s-E") 'new-email-from-subtree-no-signature)

;; and make it work in the minibuffer too
(define-key minibuffer-local-map (kbd "s-v") 'pasteboard-paste-no-spaces)
(define-key minibuffer-local-map (kbd "s-x") 'pasteboard-cut)
(define-key minibuffer-local-map (kbd "s-c") 'copy-minibuffer-contents)
(define-key minibuffer-local-map (kbd "s-a") 'copy-minibuffer-contents)

(defun copy-minibuffer-contents (arg)
  (interactive "p")
  (beginning-of-visual-line)
  (end-of-buffer)
  (copy-region-as-kill (mark) (point))
  (push-kill-ring-pasteboard-to-clipboard)
  )




(define-key key-minor-mode-map (kbd "C-c C-v") 'refile-region)

;; (define-key key-minor-mode-map (kbd "s-0") 'copy-region-to-other-window)
(define-key key-minor-mode-map (kbd "s-0") 'move-region-to-other-window)

(define-key emacs-lisp-mode-map (kbd "C-c e") 'eval-buffer)
(define-key org-mode-map (kbd "C-c e") 'eval-subtree)

(define-key key-minor-mode-map (kbd "C-c r") 'eval-region)


(define-key key-minor-mode-map (kbd "C-9") 'goto-last-change-reverse) ; super useful when editing
(define-key key-minor-mode-map (kbd "C--") 'goto-last-change) ; super useful when editing

;; (define-key key-minor-mode-map (kbd "s-=") 'zoom-in-and-disable-menu-bar-mode)

(define-key key-minor-mode-map (kbd "M-=") 'er/expand-region)
(define-key key-minor-mode-map (kbd "C-=") 'er/expand-region)
;; (define-key key-minor-mode-map (kbd "C-8") 'embolden-or-bold)
;; replaced it with multiple-cursors-hydra/body for now

;; (define-key key-minor-mode-map (kbd "C-8") '(lambda (arg) (interactive "p") (wrap-region-trigger arg "*"))) ; wow this was a stroke of genius

(define-key key-minor-mode-map (kbd "s-j r e") 'set-rectangular-region-anchor)

(define-key key-minor-mode-map (kbd "C-d") 'kill-word-correctly-and-capitalize)
;; (define-key key-minor-mode-map (kbd "m-d") 'kill-word-correctly-and-capitalize)

;; (define-key key-minor-mode-map (kbd "m-D") 'org-shiftleft)



(define-key key-minor-mode-map (kbd "C-l") 'reflash-indentation)
;; (define-key org-mode-map (kbd "C-l") 'reflash-indentation)

(define-key key-minor-mode-map (kbd "s-E") 'embark-act)


(define-key key-minor-mode-map (kbd "=") 'smex) ; call any function with easiest keystroke possible
;; (define-key key-minor-mode-map (kbd "M-x") 'helm-M-x) ; call helm-M-x instead of regular M-x
;; (define-key key-minor-mode-map (kbd "\|") 'deft)

(define-key org-mode-map (kbd "M-K") 'kill-clause)
(define-key emacs-lisp-mode-map (kbd "M-K") 'kill-sexp)

(define-key key-minor-mode-map (kbd "C-M-8") 'org-toggle-heading) ; i.e. subheading


(define-key key-minor-mode-map (kbd "M-8") 'org-toggle-heading-same-level)
(define-key key-minor-mode-map (kbd "M-*") 'org-toggle-todo-heading)
;; (define-key key-minor-mode-map (kbd "C-M-*") 'org-toggle-todo-subheading)


(define-key key-minor-mode-map (kbd "M-t") 'transpose-words)

(define-key key-minor-mode-map (kbd "M--") 'cycle-hyphenation-or-toggle-item)



(define-key key-minor-mode-map (kbd "s-'") 'refile-region-or-subtree)

;; (define-key key-minor-mode-map (kbd "C-c j") 'helm-org-headlines) ; also bound to keychord jj
;; helm-mini) ; shows recent files; also bound to ⌘-r
(define-key key-minor-mode-map (kbd "M-b M-d") 'book-dired) ; show directory of my book folder
(define-key key-minor-mode-map (kbd "M-b r") 'read-a-book) ; show directory of my PDF books
(define-key key-minor-mode-map (kbd "M-b j") 'read-jd) ; show PDF books I have annotated
(define-key key-minor-mode-map (kbd "M-b M-b") 'work-on-book) ;

(define-key key-minor-mode-map (kbd "M-b M-w") 'work-on-book) ;

(define-key key-minor-mode-map (kbd "M-b lc") 'book-load-current) ;

;; (define-key key-minor-mode-map (kbd "M-b ho") 'spacemacs/toggle-highlight-current-line-globally)


;; book bindings
(define-key key-minor-mode-map (kbd "M-b M-p") 'book-proposal-directory)
(define-key key-minor-mode-map (kbd "M-b M-m") 'book-mistakes-directory)

;; helm-strict) ; this is a smart function, show recent files in my book folder

;; can't get this to work. for some reason GNU Emacs interprets ⌘-shift-d as s-c

(define-key key-minor-mode-map (kbd "s-D") 'org-roam-dailies-capture-today)

;; own structure editing
(define-key key-minor-mode-map (kbd "s-o") 'move-region-to-other-window) ; very useful when working with a split frame
;; (define-key org-mode-map (kbd "s-o") 'move-region-to-other-window)


(define-key key-minor-mode-map (kbd "s-j o l") 'olivetti-mode)
(define-key key-minor-mode-map (kbd "] ol") 'olivetti-mode)
(define-key key-minor-mode-map (kbd "s-j o e") 'olivetti-expand)
(define-key key-minor-mode-map (kbd "s-+") 'copy-region-to-other-window)
(define-key key-minor-mode-map (kbd "s-_") 'olivetti-shrink)

(define-key key-minor-mode-map (kbd "s-l") 'org-insert-link)


(define-key key-minor-mode-map (kbd "s-T") 'words-thesaurus)

;; For extracting content from my browser

(define-key key-minor-mode-map (kbd "s-W") 'org-mac-chrome-insert-frontmost-url)
;; (define-key key-minor-mode-map (kbd "s-V") 'html2org-clipboard) ; paste HTML content that I've copied from the web, automatically converting to proper org-mode syntax


;; indirect buffer
(define-key key-minor-mode-map (kbd "s-I") 'clone-indirect-buffer-other-window)



;; and the keybinding
(define-key org-mode-map (kbd "C-k") 'my/kill-line-dwim)
(define-key key-minor-mode-map (kbd "C-k") 'my/kill-line-dwim)

;; use OSX standard keybindings ⌘-up and ⌘-down to go to top or bottom of buffer
(define-key key-minor-mode-map [s-up] 'beginning-of-buffer)
(define-key key-minor-mode-map [s-down] 'end-of-buffer)

(define-key key-minor-mode-map (kbd "S-s-SPC") 'set-mark-command)

;; mark commands
(define-key key-minor-mode-map (kbd "C-M-SPC") 'set-mark-command)
(define-key key-minor-mode-map (kbd "C-M-x") 'exchange-point-and-mark)


;; (define-key key-minor-mode-map (kbd "C-s-SPC") 'helm-all-mark-rings)

; (define-key key-minor-mode-map (kbd "s-+") 'set-mark-command)

;; (define-key key-minor-mode-map (kbd "s-_") 'avy-pop-mark)
;; use OSX standard keybinding for "Redo"
(define-key key-minor-mode-map (kbd "s-y") 'undo-tree-redo)

;; use OSX standard keybinding to increase or decrease font size
;; (define-key key-minor-mode-map (kbd "s-=") 'text-scale-increase)
;; (define-key key-minor-mode-map (kbd "s--") 'text-scale-decrease)

(define-key key-minor-mode-map (kbd "s-=") 'embiggen-text)
(define-key key-minor-mode-map (kbd "s--") 'ensmallen-text)


;; rebind global help command so that I can use C-h for backspace
(define-key key-minor-mode-map (kbd "M-h") 'help-command)

;; very useful when encountering names and other unfamiliar words
(define-key key-minor-mode-map (kbd "M-+") 'add-word-to-personal-dictionary)

(define-key key-minor-mode-map (kbd "s-j s w") 'crux-swap-windows)

(define-key key-minor-mode-map (kbd "s-j l a") 'jay-load-latex)
(define-key key-minor-mode-map (kbd "s-j l t") 'jay-load-latex)
(define-key key-minor-mode-map (kbd "s-j k a") 'load-koma-letter)
(define-key key-minor-mode-map (kbd "s-j k o") 'load-koma-letter)

(define-key key-minor-mode-map (kbd "M-s-v") 'html2org-clipboard)


;; navigate between buffers, including uninteresting ones that are hidden by default
(define-key key-minor-mode-map (kbd "M-s-<right>") 'switch-to-next-buffer)
(define-key key-minor-mode-map (kbd "M-s-<left>") 'previous-buffer)

;; deleting things
;; (define-key key-minor-mode-map (kbd "<backspace>") 'my/delete-backward)
(define-key key-minor-mode-map (kbd "<backspace>") 'my/delete-backward-and-capitalize)

;; a keybinding for "delete" in addition to "backspace"
(define-key key-minor-mode-map (kbd "C-<backspace>") 'delete-char)
(define-key key-minor-mode-map (kbd "M-<backspace>") 'backward-kill-word-correctly-and-capitalize)

;; pomodoro
(define-key key-minor-mode-map (kbd "C-c C-x pi") 'pomodoro-start)
(define-key key-minor-mode-map (kbd "C-c C-x po") 'pomodoro-stop)

;; find files using helm
;; (define-key key-minor-mode-map (kbd "C-x C-f") 'helm-find-files)

;; search using helm-swoop
;(global-set-key (kbd "M-I") 'helm-swoop-back-to-last-point)
;(global-set-key (kbd "C-c M-i") 'helm-multi-swoop)
;(global-set-key (kbd "C-x M-i") 'helm-multi-swoop-all)
;(global-set-key (kbd "M-i") 'helm-multi-swoop-all)

;; edit Emacs preferences using standard OSX keybinding for preferences
(define-key key-minor-mode-map (kbd "s-,") 'customize-group)


(define-key key-minor-mode-map (kbd "s-G") 'consult-grep)
(define-key key-minor-mode-map (kbd "s-g") 'isearch-repeat-forward)

(define-key key-minor-mode-map (kbd "M-x") 'execute-extended-command) ; call helm-M-x instead of regular M-x

;; ag, using current folder as default
;; (define-key key-minor-mode-map (kbd "C-u s-g") 'helm-ag)
;; does that keyvinding work?

;; some custom functions

(define-key key-minor-mode-map (kbd "C-c v i") 'org-insert-src-block)

;; org-mime
;; (define-key org-mode-map (kbd "M-n") 'new-email-from-subtree-no-signature)
;; (define-key key-minor-mode-map (kbd "M-N") 'new-email-from-subtree)


#+END_SRC


* sentences

Make ~kill-sentence~ work in a more intuitive way:
#+BEGIN_SRC emacs-lisp
(defun kill-sentence-to-period ()
  "Leave the period in there."
  (interactive)
  (kill-sentence)
  (push-mark)
  (insert ".")
  (backward-char)
)
#+END_SRC

[[http://emacs.stackexchange.com/questions/12266/how-change-behavior-of-kill-sentence-based-on-position-in-sentence/12321?iemail=1&noredirect=1#12321][Source]]

#+BEGIN_SRC emacs-lisp
(defun my/forward-to-sentence-end ()
  "Move point to just before the end of the current sentence."
  (forward-sentence)
  (backward-char)
  (unless (looking-back "[[:alnum:]]")
    (backward-char)))

(defun my/beginning-of-sentence-p ()
  "Return  t if point is at the beginning of a sentence."
  (let ((start (point))
        (beg (save-excursion (forward-sentence) (forward-sentence -1))))
    (eq start beg)))

(defun my/kill-sentence-dwim ()
  "Kill the current sentence up to and possibly including the punctuation.
When point is at the beginning of a sentence, kill the entire
sentence. Otherwise kill forward but preserve any punctuation at the sentence end."
  (interactive)
(smart-expand)
  (if (my/beginning-of-sentence-p)
      (progn
        (kill-sentence)
        (just-one-space)
        (when (looking-back "^[[:space:]]+") (delete-horizontal-space)))
      (kill-region (point) (progn (my/forward-to-sentence-end) (point)))
      (just-one-space 0))

;; don't leave two periods in a row
(when
(or
(looking-at "\\.\\. ")
(and
(looking-at "\\.")
(looking-back "\\.")
)
)
(delete-forward-char 1))

(when
    (and
     (looking-at ".")
     (looking-back ",")
     )
  (delete-backward-char 1)
  (forward-char 1)
  )

)
#+END_SRC

* my/kill-line-dwim

#+BEGIN_SRC emacs-lisp


(defun my/kill-line-dwim ()
  "Kill the current line."
  (interactive)
;; don't leave stray stars behind when killing a line
(when
(or
(looking-back "\\[")
(looking-back "\* ")
(looking-back "\* TODO ")
(looking-back "^\*+")
(looking-back "- ")
(looking-back "# ")
)
(beginning-of-line)
)
;;  (expand-abbrev)
  (org-kill-line)
;;  (save-excursion
;;    (when (my/beginning-of-sentence-on)
;;      (capitalize-unless-org-heading)))
)
#+END_SRC

* kill-sentence-maybe-else-kill-line


  #+BEGIN_SRC emacs-lisp
(defun kill-sentence-maybe-else-kill-line ()
  (interactive)
(when
    (not (looking-at "$"))
  (my/kill-sentence-dwim))
  (when
      (looking-at "$")
    (my/kill-line-dwim))
)
;; and the keybinding
(global-set-key (kbd "M-k") 'kill-sentence-maybe-else-kill-line)

  #+END_SRC


* Browsing

#+BEGIN_SRC emacs-lisp
(setq browse-url-browser-function 'browse-url-default-macosx-browser)
#+END_SRC

* spacecraft-mode - superior handling of whitespace for writing and editing prose


** smart-space
#+BEGIN_SRC emacs-lisp
(defun smart-period-or-smart-space ()
"double space adds a period!"
(interactive)
  (if
(looking-back "[A-Za-z0-9] ")
(smart-period)
(smart-space)
))

(defun smart-space ()
  "Insert space and then clean up whitespace."
  (interactive)
(cond (mark-active
 (progn (delete-region (mark) (point)))))

;; (if (org-at-heading-p)
 ;;    (insert-normal-space-in-org-heading)

  (unless
      (or
(let ((case-fold-search nil)
(looking-back "\\bi\.e[[:punct:][:punct:]]*[ ]*") ; don't add extra spaces to ie.
)
(looking-back "\\bvs.[ ]*") ; don't add extra spaces to vs.
(looking-back "\\be\.\g[[:punct:]]*[ ]*") ; don't add extra spaces to eg.

(looking-back "^[[:punct:]]*[ ]*") ; don't expand previous lines - brilliant!

(looking-back ">") ; don't expand days of the week inside timestamps

(looking-back "][\n\t ]*") ; don't expand past closing square brackets ]
       ))
  (smart-expand))

(insert "\ ")
(just-one-space)
)




;; this is probably convuluted logic to invert the behavior of the SPC key when in org-heading
(defun insert-smart-space-in-org-heading ()
 "Insert space and then clean up whitespace."
 (interactive)
(unless
   (or
(looking-back "\\bvs.[ ]*") ; don't add extra spaces to vs.
(looking-back "\\bi\.e[[:punct:][:punct:]]*[ ]*") ; don't add extra spaces to ie.
(looking-back "\\be\.\g[[:punct:][:punct:]]*[ ]*") ; don't add extra spaces to eg.

(looking-back "^[[:punct:][:punct:]]*[ ]*") ; don't expand previous lines---brilliant!

(looking-back ">") ; don't expand days of the week inside timestamps

(looking-back "][\n\t ]*") ; don't expand past closing square brackets ]
    )
 (smart-expand))
(insert "\ ")
 (just-one-space))



; (define-key org-mode-map (kbd "<SPC>") 'smart-period-or-smart-space) ; I disabled this for DragonSpeak
(define-key org-mode-map (kbd "<SPC>") 'smart-space)
;; (define-key orgalist-mode-map (kbd "<SPC>") 'smart-period-or-smart-space)
(global-set-key (kbd "M-SPC") 'insert-space)
(define-key org-mode-map (kbd "<M-SPC>") 'insert-space)
;; (define-key orgalist-mode-map (kbd "<M-SPC>") 'insert-space)
#+END_SRC




** my/fix-space
#+BEGIN_SRC emacs-lisp
;;; I changed this a)) bunch, not sure if it still works correctly.
;; (defun my/fix-space ()
;;   "Delete all spaces and tabs around point, leaving one space except at the beginning of a line and before a punctuation mark."
;;   (interactive)
;;   (just-one-space)
;;
;;     (when (or
;;            (looking-back "^[[:space:]]+")
;;            (looking-back "-[[:space:]]+")
;;            (looking-at "[.,:;!?»)-]")
;;            (looking-back"( ")
;;            (looking-at " )")
;;            ))
;;       (unless
;;       (looking-back "^-[[:space:]]+")
;;   (delete-horizontal-space))
;;
;; (unless
;;  (looking-back "^")
;; (just-one-space)
;; )
;;
;; )

(defun my/fix-space ()
  "Delete all spaces and tabs around point, leaving one space except at the beginning of a line and before a punctuation mark."
  (interactive)
  (just-one-space)
  (when (and (or
              (looking-back "^[[:space:]]+")
              (looking-back "-[[:space:]]+")
              (looking-at "[.,:;!?»)-]")
              (looking-back"( ")
              (looking-at " )")
              )
             (not (looking-back "^-[[:space:]]+"))
             (not (looking-back " - "))

)
    (delete-horizontal-space)))
#+END_SRC

. This.
** insert-space
#+BEGIN_SRC emacs-lisp


(defun insert-space ()
  (interactive)
(if (org-at-heading-p)
(insert-smart-space-in-org-heading)
(cond (mark-active
   (progn (delete-region (mark) (point)))))
  (insert " ")
))
(defun insert-normal-space-in-org-heading ()
 (interactive)
(cond (mark-active
 (progn (delete-region (mark) (point)))))
 (insert " ")
)
;; this is probably convuluted logic to invert the behavior of the SPC key when in org-heading


(defun insert-period ()
"Inserts a fuckin' period!"
 (interactive)
(cond (mark-active
   (progn (delete-region (mark) (point)))))

 (insert ".")
)


(defun insert-comma ()
 (interactive)
(cond (mark-active
   (progn (delete-region (mark) (point)))))
 (insert ",")
)

(defun insert-exclamation-point ()
 (interactive)
(cond (mark-active
  (progn (delete-region (mark) (point)))))
 (insert "!")
)


(defun insert-colon ()
"Insert a goodamn colon!"
 (interactive)
(cond (mark-active
  (progn (delete-region (mark) (point)))))
 (insert ":")
)

(defun insert-question-mark ()
"Insert a freaking question mark!!"
 (interactive)
(cond (mark-active
 (progn (delete-region (mark) (point)))))
 (insert "?")
)


#+END_SRC

** smart insertion of headings and subheadings
*** smart-org-meta-return-dwim
 #+BEGIN_SRC emacs-lisp
(setq org-blank-before-new-entry
      '((heading . always)
       (plain-list-item . always)))

(defun call-rebinding-org-blank-behaviour (fn)
  (let ((org-blank-before-new-entry
         (copy-tree org-blank-before-new-entry)))
    (when (org-at-heading-p)
      (rplacd (assoc 'heading org-blank-before-new-entry) nil))
    (call-interactively fn)))

(defun smart-org-meta-return-dwim ()
  (interactive)

(if

    (and
     (looking-back "^")
     (looking-at ".+")
     )                               ; if
    (org-toggle-heading-same-level) ; then
 (call-rebinding-org-blank-behaviour 'org-meta-return)) ; else
)


#+END_SRC

*** smart-org-insert-heading-respect-content-dwim
#+BEGIN_SRC emacs-lisp
(defun smart-org-insert-heading-respect-content-dwim ()
(interactive)
  (call-rebinding-org-blank-behaviour 'org-insert-heading-respect-content)
)
#+END_SRC

*** smart-org-insert-todo-heading-dwim
#+BEGIN_SRC emacs-lisp
(defun smart-org-insert-todo-heading-dwim ()
  (interactive)
  (let ((listitem-or-checkbox (org-plain-text-list-p)))
    (call-rebinding-org-blank-behaviour 'org-insert-heading)
    (if listitem-or-checkbox
        (insert "[ ] ")
        (insert "TODO ")))
)

#+END_SRC

*** smart-org-insert-todo-heading-respect-content-dwim
#+BEGIN_SRC emacs-lisp
(defun smart-org-insert-todo-heading-respect-content-dwim ()
  (interactive)
  (call-rebinding-org-blank-behaviour 'org-insert-todo-heading-respect-content)
)
#+END_SRC

*** smart-org-insert-subheading
#+BEGIN_SRC emacs-lisp
(defun smart-org-insert-subheading ()
  (interactive)
(call-rebinding-org-blank-behaviour 'org-meta-return)
(org-demote-subtree)
)
#+END_SRC

*** smart-org-insert-todo-subheading
#+BEGIN_SRC emacs-lisp
(defun smart-org-insert-todo-subheading ()
  (interactive)
(call-rebinding-org-blank-behaviour 'org-insert-todo-subheading)
)
#+END_SRC

*** keybindings
#+BEGIN_SRC emacs-lisp
(define-key org-mode-map (kbd "M-<return>") 'smart-org-meta-return-dwim)
(define-key org-mode-map (kbd "M-S-<return>") 'smart-org-insert-todo-heading-dwim)
(define-key org-mode-map (kbd "C-<return>") 'return-insert-blank-line-before)
(define-key org-mode-map (kbd "C-S-<return>") 'smart-org-insert-todo-heading-respect-content-dwim)
(define-key org-mode-map (kbd "C-M-<return>") 'smart-org-insert-subheading)
(define-key org-mode-map (kbd "<C-S-M-return>") 'smart-org-insert-todo-subheading)
(define-key org-mode-map (kbd "<C-s-return>") 'smart-org-insert-todo-subheading)
(define-key key-minor-mode-map (kbd "<s-S-return>") 'smart-org-insert-todo-heading-dwim)
(define-key key-minor-mode-map (kbd "<s-return>") 'toggle-fullscreen)
 #+END_SRC


*** length of previous line
#+BEGIN_SRC emacs-lisp

(defun length-of-previous-line ()
 (save-excursion
  (forward-line -1)
  (end-of-line)
  (current-column)))
#+END_SRC

*** smart-return - without org-run-like-in-org-mode
In this version, I removed this line:

(org-run-like-in-org-mode (lambda () (interactive)

... it seems to work. But not knowing what that line does, or what I'm doing more generally, I don't know what unexpected effects this redaction may have...

Also, the refreshing of the buffer still seems to happen when I hit smart-return when I'm in a bulleted list. also it seems to be replacing the hyphen (-) with an n dash (-)

#+BEGIN_SRC emacs-lisp

(defun smart-return ()
  (interactive)

  ;; don't leave stray stars or links
  (when
      (or
       (looking-back "\\[")
       (looking-back "^\*+[ ]*") ; hopefully this means: at the beginning of the line, 1 or more asterisks followed by zero or more spaces
       (looking-back "^# ")
       ;; (looking-back "* TODO ") ; actually I don't think I want this
       ;; (looking-back "^*+")
       ;; (looking-back "- ")
       )
    (beginning-of-line)
    )
  ;;
  (cond (mark-active
         (progn (delete-region (mark) (point))
                (newline)))
        ;; Lifted from `org-return'. Why isn't there an
        ;; `org-at-link-p' function?!
        ((and
          org-return-follows-link
          (org-in-regexp org-any-link-re))
         (cond
          ((or
            ;;(looking-at "\\[\\[.*")
            (looking-back ">")
            (looking-back "\\]\\]")
            (and (thing-at-point 'url)
                 (let ((bnds (bounds-of-thing-at-point 'url)))
                   (or (>= (car bnds) (point))
                       (<= (cdr bnds) (point))))))
           (newline))
          ((char-equal (string-to-char "]") (following-char))
           (progn (forward-char 2)
                  (newline)))
          (t (call-interactively 'org-open-at-point))))

        ((and
          (let ((el (org-element-at-point)))
            (and el
                 ;; point is at an item
                 (eq (first el) 'item)
                 ;; item is empty
                 (eql (getf (second el) :contents-begin)
                      (getf (second el) :contents-end)))))
         (message "at 1")
         (beginning-of-line)
         (let ((kill-whole-line nil))
           (kill-line))
         (newline))
        ((and
          (let ((el (org-element-at-point)))
            (and (not (org--line-empty-p 1))
                 (and el
                      (or (member (first el) '(item plain-list))
                          (let ((parent (getf (second el) :parent)))
                            (and parent
                                 (member (first parent) '(item plain-list)))))))))
         (let ((is-org-chbs (org-checkbox-p)))
           (org-run-like-in-org-mode (lambda () (interactive) (call-interactively 'org-meta-return)))
           (when is-org-chbs
             (insert "[ ] "))))
        ((and
          (not (and
                org-return-follows-link
                (looking-back ">"))))
(call-interactively 'org-return))

        (t (newline))))

(define-key org-mode-map (kbd "<return>") 'smart-return)
;; (define-key orgalist-mode-map (kbd "<return>") 'smart-return)
#+END_SRC


** kill word correctly
#+BEGIN_SRC emacs-lisp
(defun kill-word-correctly ()
  "Kill word."
  (interactive)
  (smart-expand)
  (if (or (re-search-forward "\\=[ 	]*\n" nil t)
          (re-search-forward "\\=\\W*?[[:punct:]]+" nil t)) ; IF there's a sequence of punctuation marks at point
      (kill-region (match-beginning 0) (match-end 0)) ; THEN just kill the punctuation marks
    (kill-word 1))                                    ; ELSE kill word
  (my/fix-space)
;; don't leave two periods in a row
(when
(or
(looking-at "\\,\\, ")

(and
(looking-at "\\,")
(looking-back "\\,")
)
)
(delete-forward-char 1))
)

#+END_SRC

** kill word correctly and capitalize

#+BEGIN_SRC emacs-lisp
(defun kill-word-correctly-and-capitalize ()
  "Check to see if the point is at the beginning of the sentence. If yes, then kill-word-correctly and endless/capitalize to capitalize the first letter of the word that becomes the first word in the sentence. Otherwise simply kill-word-correctly."
  (interactive)
(when (looking-at "[ ]")
         (forward-char 1)
          )
;; capitalize correctly if there's point is before the space at the beginning of a sentence

  (let ((fix-capitalization (my/beginning-of-sentence-p)))
    (call-interactively 'kill-word-correctly)
    (when fix-capitalization
      (save-excursion (capitalize-unless-org-heading)))))
#+END_SRC


* character movement
#+BEGIN_SRC emacs-lisp
(defun jay/left-char ()
  "Move point to the left or the beginning of the region.
 Like `backward-char', but moves point to the beginning of the region
provided the (transient) mark is active."
  (interactive)
  (let ((this-command 'left-char)) ;; maintain compatibility
    (let ((left (min (point)
                     ;; `mark' returning nil is ok; we'll only use this
                     ;; if `mark-active'
                     (or (mark t) 0))))
      (if (and transient-mark-mode mark-active)
          (progn
            (goto-char left)
            (setq deactivate-mark t))
        (call-interactively 'left-char)))))


(defun jay/right-char ()
  "Move point to the right or the end of the region.
 Like `right-char', but moves point to the end of the region
provided the (transient) mark is active."
  (interactive)
  (let ((this-command 'right-char)) ;; maintain compatibility
    (let ((right (max (point)
                      ;; `mark' returning nil is ok; we'll only use this
                      ;; if `mark-active'
                      (or (mark t) 0))))
      (if (and transient-mark-mode mark-active)
          (progn (goto-char right)
		 (setq deactivate-mark t))
	(call-interactively 'right-char)))))

(define-key org-mode-map (kbd "<left>") 'jay/left-char)
(define-key org-mode-map (kbd "<right>") 'jay/right-char)

#+END_SRC

* saveplace
;; Save point position between sessions

#+BEGIN_SRC emacs-lisp
;; Save point position between sessions
(use-package saveplace
:defer
 :init (save-place-mode))
#+END_SRC

The saveplace package is part of Emacs, and remembers the position of point - even between emacs sessions.

The last line sets the path to where saveplace stores your position data. Change it at your peril!

* embolden next word

   #+BEGIN_SRC emacs-lisp
(define-minor-mode embolden-next-word
    "Make the next word you type bold."
  nil
  :lighter " EMBOLDEN"
  :keymap (let ((map (make-sparse-keymap)))
            (define-key map (kbd "SPC") (lambda ()
                      (interactive)
                      (expand-abbrev)
                      (save-excursion
                        (goto-char (get-register 'p))
                        (insert "*"))
                      (insert "* ")
                      (embolden-next-word -1)))
        (define-key map (kbd ".") (lambda ()
                    (interactive)
                    (expand-abbrev)
                    (save-excursion
                      (goto-char (get-register 'p))
                      (insert "*"))
                    (insert "*. ")
                    (embolden-next-word -1)))
            map)
  (if embolden-next-word
      (set-register 'p (point))
    (set-register 'p nil)))

(global-set-key "\C-o" 'embolden-or-bold)
(define-key key-minor-mode-map (kbd "C-o") 'embolden-or-bold)
   #+END_SRC

* cycle-hyphenation

#+BEGIN_SRC emacs-lisp
(defun cycle-hyphenation ()
  (interactive)
  (cond ((re-search-forward "\\=\\w*\\(-\\)\\w+" nil t)
         (save-excursion (replace-match " " t t nil 1)))
        ((re-search-forward "\\=\\w*\\( +\\)\\w+" nil t)
         (save-excursion (replace-match "-" t t nil 1)))))
#+END_SRC

* cycle-punctuation

#+BEGIN_SRC emacs-lisp
(defvar *punctuation-markers-to-cycle-between*  ".?!")

(defun cycle-punctuation ()
  (interactive)
  (save-excursion
    (forward-sentence)
    (when (re-search-backward (format "\\>\\([%s]\\)[[:space:]]*\\="
                                      *punctuation-markers-to-cycle-between*)
                              nil t)
      (let ((next (elt *punctuation-markers-to-cycle-between*
                       ;; circular string; should be abstracted
                       (mod (1+ (position (elt (match-string 1) 0)
                                          *punctuation-markers-to-cycle-between*))
                            (length *punctuation-markers-to-cycle-between*)))))
        (replace-match (format "%c" next) t t nil 1)))))

;; (define-key key-minor-mode-map (kbd "M-.") 'cycle-punctuation)
#+END_SRC

* clone subtree
#+BEGIN_SRC emacs-lisp
(defun org-clone-subtree ()
  (interactive)
  (org-clone-subtree-with-time-shift 1)
  (save-excursion
    (org-goto-sibling)
    ;; This part was lifted partly and adapted from
    ;; http://orgmode.org/worg/org-hacks.html#orgheadline10.
    ;; There should be a better way to change the contents of an org heading
    ;; though...
    (when (org-at-heading-p)
      (let ((hl-text (nth 4 (org-heading-components)))
            (buffer-undo-list))
        (when hl-text
          (beginning-of-line)
          (search-forward hl-text (point-at-eol))
          (replace-match (format "%s" hl-text) nil t)
;; (org-align-tags-here org-tags-column)
)))))
#+END_SRC

* smart punctuation

** kill-clause

This version kill org-mode headings by 'kill-line'
#+BEGIN_EXAMPLE emacs-lisp

;; Identify the end of sentences globally.
(setq sentence-end-base "[][.?!…}]+[\"”]?")
(defun kill-clause ()
  (interactive)
  (smart-expand)
  (if (let ((sm (string-match "[*]+\s" (thing-at-point 'line)))) (and sm (= sm 0)))
      (kill-line)
    (progn
      (let ((old-point (point))
            (kill-punct (my/beginning-of-sentence-p)))
        (when (re-search-forward "--\\|[][,;:?!…\"”()}]+\\|\\.+ " nil t)
          (kill-region old-point
                       (if kill-punct
                           (match-end 0)
                         (match-beginning 0)))))

      (my/fix-space)
      (save-excursion
        (when (my/beginning-of-sentence-p)
          (capitalize-unless-org-heading)))

;; below is my own hack to fix the ", , " issue
(when

(or

(looking-back ", , ")
(looking-back ",, ")
(looking-back ",, ")
(looking-back ": : ")
)
(new-org-delete-backward-char 2)
(my/fix-space)


(when
(and
(looking-back "----")
(looking-at "-"))

(delete-backward-char 4)
(delete-char 1)
(insert-space))


t)))

#+END_EXAMPLE


This old version leaves a rogue comma:
#+BEGIN_EXAMPLE emacs-lisp

;; Identify the end of sentences globally.
(setq sentence-end-base "[][.?!…}]+[\"”]?")
(defun kill-clause ()
  (interactive)
  (smart-expand)
  (let ((old-point (point))
        (kill-punct (my/beginning-of-sentence-p)))
    (when (re-search-forward "--\\|[][,;:?!…\"”()}]+\\|\\.+ " nil t)
      (kill-region old-point
                   (if kill-punct
                       (match-end 0)
                     (match-beginning 0)))))
  (my/fix-space)
  (save-excursion
    (when (my/beginning-of-sentence-p)
      (capitalize-unless-org-heading))))

#+END_EXAMPLE

Old version that I retrieved:
#+BEGIN_SRC emacs-lisp
(defun kill-clause ()
  (interactive)
  (smart-expand)

(if
(let ((sm (string-match "*+\s" (thing-at-point 'line)))) (and sm (= sm 0)))
(kill-line)


  (let ((old-point (point))
        (kill-punct (my/beginning-of-sentence-p)))
    (when (re-search-forward "--\\|[][,;:?!…\"”()}]+\\|\\.+ " nil t)
      (kill-region old-point
                   (if kill-punct
                       (match-end 0)
                     (match-beginning 0)))))
  (my/fix-space)
  (save-excursion
    (when (my/beginning-of-sentence-p)
      (capitalize-unless-org-heading)))

(when
(or    (looking-back ", , ")
     (looking-back ":: ")
     )
(new-org-delete-backward-char 2)
(my/fix-space)
t)

;; fix a bug that leaves this: " : "
(when (looking-back " : ")
(progn
(left-char 2)
(new-org-delete-backward-char 1)
(right-char 2)
))


;; fix a bug that leaves this: " , "
(when (looking-back " , ")
(progn
(left-char 2)
(my/fix-space)
(right-char 2)
))


;; fix a bug that leaves this: ",."
(when (looking-back ",. ")
(left-char 2)
(delete-backward-char 1)
(right-char 2)
)


;; fix a bug that leaves this: ", . "
(when (looking-back ", . ")
(left-char 2)
(delete-backward-char 2)
(right-char 2)
)

(when
(and
(looking-back "----")
(looking-at "-"))

(delete-backward-char 4)
(delete-char 1)
(insert-space))



))
#+END_SRC



** smart-punctuation exceptions

   #+BEGIN_SRC emacs-lisp
(defvar *smart-punctuation-marks*
  ".,;:!?-")

(setq *smart-punctuation-exceptions*
  (list "?!" ".." "..." "............................................." "---" ";;" "!!" "!!!" "??" "???" "! :" ". :" ") ; "))

;; How do I add an exception for ") ; "?
;; e.g. if I want to add a comment after a line of lisp?

   #+END_SRC


** smart-punctuation (auxiliary)

#+BEGIN_SRC emacs-lisp
  (defun smart-punctuation (new-punct &optional not-so-smart)
    (smart-expand)
    (save-restriction
      (when (and (eql major-mode 'org-mode)
                 (org-at-heading-p))
        (save-excursion
          (org-beginning-of-line)
          (let ((heading-text (fifth (org-heading-components))))
            (when heading-text
              (search-forward heading-text)
              (narrow-to-region (match-beginning 0) (match-end 0))))))
      (cl-flet ((go-back (regexp)
                  (re-search-backward regexp nil t)
                  (ignore-errors      ; might signal `end-of-buffer'
                    (forward-char (length (match-string 0))))))
        (if not-so-smart
            (let ((old-point (point)))
              (go-back "[^ \t]")
              (insert new-punct)
              (goto-char old-point)
              (forward-char (length new-punct)))
          (let ((old-point (point)))
            (go-back (format "[^ \t%s]\\|\\`" *smart-punctuation-marks*))
            (let ((was-after-space (and (< (point) old-point)
                                        (find ?  (buffer-substring (point) old-point)))))
              (re-search-forward (format "\\([ \t]*\\)\\([%s]*\\)"
                                         ,*smart-punctuation-marks*)
                                 nil t)
              (let* ((old-punct (match-string 2))
                     (was-after-punct (>= old-point (point))))
                (replace-match "" nil t nil 1)
                (replace-match (or (when (and was-after-punct
                                              (not (string= old-punct "")))
                                     (let ((potential-new-punct (concat old-punct new-punct)))
                                       (find-if (lambda (exception)
                                                  (search potential-new-punct exception))
                                                ,*smart-punctuation-exceptions*)))
                                   new-punct)
                               nil t nil 2)
                (if was-after-space
                    (my/fix-space)
                  (when (looking-at "[ \t]*\\<")
                    (save-excursion (my/fix-space))))))))))
    (when (and (eql major-mode 'org-mode)
               (org-at-heading-p))
; (org-align-tags-here org-tags-column)
))
#+END_SRC

** smart-period
#+BEGIN_SRC emacs-lisp
(defun smart-period ()
  (interactive)
(cond (mark-active
 (progn (delete-region (mark) (point)))))
(unless
      (or
(looking-back "\\bvs.[ ]*") ; Don't add extra periods to vs.
(looking-back "\\bi\.e[[:punct:]]*[ ]*") ; don't add extra periods to ie.
(looking-back "\\be\.\g[[:punct:]]*[ ]*") ; don't add extra periods to eg.

       )
  (smart-punctuation "."))
  (save-excursion
    (unless
        (or
         (looking-at "[ ]*$")
         (looking-at "\][[:punct:]]*[ ]*$")
         (looking-at "[[:punct:]]*[ ]*$")
         (looking-at "\"[[:punct:]]*[ ]*$")
         (looking-at "\)[ ]*$")
         (looking-at "\)")
         ) ; or
    (capitalize-unless-org-heading)
      ) ; unless
) ; save excursion

;; if two periods or two commas in a row, delete the second one
(when
(or
(and
(looking-at "\\.")
(looking-back "\\.")
)
(and
(looking-at ",")
(looking-back ",")
))
(delete-char 1)
)

  ) ; defun


(define-key org-mode-map (kbd ".") 'smart-period)
;; (define-key orgalist-mode-map (kbd ".") 'smart-period)
#+END_SRC

** smart-comma
#+BEGIN_SRC emacs-lisp
(defun smart-comma ()
  (interactive)
(cond (mark-active
 (progn (delete-region (mark) (point)))))

  (smart-punctuation ",")
(unless
(or

(looking-at "\]*[[:punct:]]*[ ]*$")
(looking-at "[[:punct:]]*[ ]*$")
(looking-at "[ ]*I\\b")          ; never downcase the word "I"
(looking-at "[ ]*I\'")          ; never downcase the word "I'
(looking-at "[[:punct:]]*[ ]*\"")          ; beginning of a quote
)

(save-excursion (downcase-word 1)))
(when

;; if two periods or two commas in a row, delete the second one
(or
(and
(looking-at "\\.")
(looking-back "\\.")
)
(and
(looking-at ",")
(looking-back ",")
))
(delete-char 1)
)

)


(define-key org-mode-map (kbd ",") 'comma-or-smart-comma)
;; (define-key orgalist-mode-map (kbd ",") 'comma-or-smart-comma)
#+END_SRC

** smart-question-mark
#+BEGIN_SRC emacs-lisp
(defun smart-question-mark ()
  (interactive)
  (cond (mark-active
         (progn (delete-region (mark) (point)))))

  (smart-punctuation "?")
  (save-excursion
    (unless
        (or
         (looking-at "[ ]*$")
         (looking-at "\][[:punct:]]*[ ]*$")
         (looking-at "[[:punct:]]*[ ]*$")
         (looking-at "\"[[:punct:]]*[ ]*$")
         (looking-at "\)[ ]*$")
         (looking-at "\)")
         ) ; or
    (capitalize-unless-org-heading)
      ) ; unless
    ) ; save excursion
  ) ; defun

;; works!!

(define-key org-mode-map (kbd "?") 'smart-question-mark)
;; (define-key orgalist-mode-map (kbd "?") 'smart-question-mark)
#+END_SRC

** smart-exclamation-point
#+BEGIN_SRC emacs-lisp
(defun smart-exclamation-point ()
  (interactive)
(cond (mark-active
 (progn (delete-region (mark) (point)))))

  (smart-punctuation "!")
(save-excursion
(unless (looking-at "[ ]*$")
(capitalize-unless-org-heading))
))

(define-key org-mode-map (kbd "!") 'smart-exclamation-point)
;; (define-key orgalist-mode-map (kbd "!") 'smart-exclamation-point)
#+END_SRC

** smart-hyphen
(defun smart-hyphen ()
  (interactive)
  (smart-punctuation "-"))

(define-key org-mode-map (kbd "-") 'smart-hyphen)
;; (define-key orgalist-mode-map (kbd "-") 'smart-hyphen)
#+END_SRC

** smart-semicolon

#+BEGIN_SRC emacs-lisp
(defun smart-semicolon ()
  (interactive)
(cond (mark-active
 (progn (delete-region (mark) (point)))))
  (smart-punctuation ";")
(unless
(or
(looking-at "[[:punct:]]*[ ]*$")
(looking-at "[ ]*I\\b")     ; never downcase the word "I"
(looking-at "[ ]*I\'")     ; never downcase the word "I'
(looking-at "[[:punct:]]*[ ]*\"")     ; beginning of a quote
)

(save-excursion (downcase-word 1))))

(define-key org-mode-map (kbd ";") 'smart-semicolon)
;; (define-key orgalist-mode-map (kbd ";") 'smart-semicolon)
#+END_SRC

** smart-colon

#+BEGIN_SRC emacs-lisp
(defun smart-colon ()
  (interactive)
(cond (mark-active
  (progn (delete-region (mark) (point)))))
  (smart-punctuation ":")
(unless
(or
(looking-at "[[:punct:]]*[ ]*$")
(looking-at "[ ]*I\\b")     ; never downcase the word "I"
(looking-at "[ ]*I\'")     ; never downcase the word "I'
(looking-at "[[:punct:]]*[ ]*\"")     ; beginning of a quote
)

;; (save-excursion (downcase-word 1))
))


(define-key org-mode-map (kbd ":") 'colon-or-smart-colon)



(define-key org-mode-map (kbd ",") 'comma-or-smart-comma)
;; (define-key orgalist-mode-map (kbd ":") 'smart-colon)
#+END_SRC

** comma-or-smart-comma
#+BEGIN_SRC emacs-lisp
(defun comma-or-smart-comma ()
(interactive)
(if
(or
(bolp)
(org-at-heading-p)
(looking-at " \"")
)
(insert ",")
(smart-comma))
)
#+END_SRC


** colon-or-smart-colon
#+BEGIN_SRC emacs-lisp
(defun line-starts-with-hash-p ()
 (save-excursion
  (beginning-of-line)
  (looking-at-p "#")))

(defun colon-or-smart-colon ()
 (interactive)
 (if (or (bolp)
     (org-at-heading-p)
     (line-starts-with-hash-p))
   (insert ":")
  (smart-colon)))
#+END_SRC

* TODO [#A] check my changes to backward-kill-word-correctly?
Rúdi: desired behavior is that when invoking backward-kill-word-correctly to delete words backwards, Emacs should leave a space after the word to the left of the point UNLESS point is at the beginning of the line or after "---"

I tried to implement this myself, below. My hack seems to work, but it seems slow... Is it possible to make it faster or no? maybe just than a look at the below and see if you think I implemented it in the best way.

#+BEGIN_SRC emacs-lisp
(defun backward-kill-word-correctly ()
  "Kill word."
  (interactive)
  (if (re-search-backward "\\>\\W*[[:punct:]]+\\W*\\=" nil t)
      (kill-region (match-end 0) (match-beginning 0))
    (backward-kill-word 1))
  (my/fix-space)

;; I added this ↓↓↓ #######################
(when (and
(not (looking-back "---")) ; I added this
(not (looking-back "^"))) ; I added this
;; I added this ↑↑↑ #######################

(smart-space)
)
)
#+END_SRC

** NOTE-TO-JAY Question

   Since ~backward-kill-word-correctly~ already calls ~my/fix-space~, isn't a call to ~smart-space~ redundant? What was the use case you were thinking of when you originally added it? Note that if you remove the whole ~(when ...)~ block, it apparently works as you intend it to work...

** NOTE-TO-SERJ Answer
Good question. The answer is that there should never be a space after "---"

Example:
: Alice was tired---tired as hell. ^

Say the point is the carat, and I invoke backward-kill-word-correctly 4 times.

Output if I remove the whole ~(when ...)~ block:
: Alice was tired--- ^
Note the space after "---"

Desired output:
: Alice was tired---^
No space. Does that make sense? Thanks!

* DONE [#B] my-delete-backward                                         :rudi:
#+BEGIN_SRC emacs-lisp
(defun my/delete-backward ()
  "When there is an active region, delete it and then fix up the whitespace"
  (interactive)
  (if (use-region-p)
      (delete-region (region-beginning) (region-end))
    (delete-backward-char 1))
  (save-excursion
    (when (or (looking-at "[[:space:]]")
              (looking-back "[[:space:]]"))
(unless (looking-back "\\w ")
      (my/fix-space)))))
#+END_SRC

** my-delete-backward-and-capitalize

#+BEGIN_SRC emacs-lisp
(defcustom capitalize-after-deleting-single-char nil
  "Determines whether capitalization should occur after deleting a single character.")

(defun my/delete-backward-and-capitalize ()
  "When there is an active region, delete it and then fix up the whitespace"
  (interactive)
(when (looking-back "^[*]+ ")
(kill-line 0)
(insert " ") ; this line is super hacky I put it here because when I tried to use "unless", the rest of the function, and then this at the end, it didn't work; however, this does produce the behavior I desire
)

  (let ((capitalize capitalize-after-deleting-single-char))
    (if (use-region-p)
        (progn
          (delete-region (region-beginning) (region-end))
          (setf capitalize t))
      (new-org-delete-backward-char 1))
    (save-excursion
      (when (or (looking-at "[[:space:]]")
    (looking-back "[[:space:]]"))
;; unless there's already exactly one space between words, since I need to be able to delete backward past spaces
(unless (and
(looking-back "\\w ")
(looking-at "\\w")
)
  (my/fix-space))))
    (when (and capitalize (my/beginning-of-sentence-p))
      (save-excursion
        (capitalize-unless-org-heading))))
(when

(or
(and
(looking-at "\\.")
(looking-back "\\.")
)
(and
(looking-at ",")
(looking-back ",")
))
(delete-char 1)
)
)
#+END_SRC

* backward-kill-word-correctly-and-capitalize
#+BEGIN_SRC emacs-lisp
(defun backward-kill-word-correctly-and-capitalize ()
  "Backward kill word correctly. Then check to see if the point is at the beginning of the sentence. If yes, then kill-word-correctly and endless/capitalize to capitalize the first letter of the word that becomes the first word in the sentence. Otherwise simply kill-word-correctly."
  (interactive)
(call-interactively 'backward-kill-word-correctly)
  (let ((fix-capitalization (my/beginning-of-sentence-p)))
    (when fix-capitalization
      (save-excursion (capitalize-unless-org-heading)))))
#+END_SRC

* defadvice capitalize-word
#+BEGIN_SRC emacs-lisp
(defadvice capitalize-word (after capitalize-word-advice activate)
  "After capitalizing the new first word in a sentence, downcase the next word which is no longer starting the sentence."

  (unless

      (or
       (looking-at "[ ]*\"")          ; if looking at a quote? Might not work

       (looking-at "[[:punct:]]*[ ]*I\\b")          ; never downcase the word "I"
       (looking-at "[[:punct:]]*[ ]*I'")          ; never downcase words like I'm, I'd
       (looking-at "[[:punct:]]*[ ]*\"*I'")    ; never downcase words like I'm, I'd

(looking-at "[ ]*I\'")   ; never downcase the word "I'

       (looking-at "[[:punct:]]*[ ]*\"I\\b")          ; never downcase the word "I"
       (looking-at "[[:punct:]]*[ ]*OK\\b")          ; never downcase the word "OK"

       ;; (looking-at "\\") ; how do you search for a literal backslash?
       (looking-at (sentence-end))

       (looking-at "[[:punct:]]*[ ]*$") ; don't downcase past line break

       (looking-at "[[:punct:]]*[ ]*\"$") ; don't downcase past quotation then line break
       (looking-at "[[:punct:]]*[ ]*)$") ; don't downcase past a right paren then line break
       (looking-at "[[:punct:]]*[ ]*\")$") ; don't downcase past a quotation then a right paren then a line break

       (looking-at "[[:punct:]]*[ ]*http") ; never capitalize http

(looking-at "\"[[:punct:]]*[ ]*$") ; a quotation mark followed by "zero or more whitespace then end of line?"

(looking-at "\)[ ]*$") ; a right paren followed by "zero or more" whitespace, then end of line

(looking-at ")[ ]*$") ; a right paren followed by "zero or more" whitespace, then end of line
(looking-at ")$") ; a right paren followed by "zero or more" whitespace, then end of line

(looking-at "[ ]*-*[ ]*$") ; dashes at the end of a line


       (looking-at (user-full-name))

       )

    (save-excursion
      (downcase-word 1))))
#+END_SRC

I tried to add exceptions for "line-end" and also for user-full name.

* capitalize-unless-org-heading
  #+BEGIN_SRC emacs-lisp
(defun capitalize-unless-org-heading ()
  (interactive)
  (unless
      (or
       (looking-at "[[:punct:]]*[\n\t ]*\\*")
       ;; (looking-at "\\* TODO"); redundant
       (let ((case-fold-search nil))
         (looking-at "[ ]*[\n\t ]*[[:punct:]]*[\n\t ]*[A-Z]")
         (looking-at "[A-Z].*"))
       (looking-at "[\n\t ]*[[:punct:]]*[\n\t ]*#\\+")
       (looking-at "[\n\t ]*[[:punct:]]*[\n\t ]*\(")
       (looking-at "[\n\t ]*[[:punct:]]*[\n\t ]*<")
       (looking-at "[\n\t ]*[[:punct:]]*[\n\t ]*file:")
       (looking-at "[\n\t ]*\\[fn")
       (looking-at "[\n\t ]*)$")
       (looking-at "[\n\t ]*\"$")
       (looking-at "\"[\n\t ]*$")
       (looking-at "[[:punct:]]*[ ]*http")
       (looking-at "[[:punct:]]*[ ]*\")$"); don't capitalize past
       (looking-at "[ ]*I\'")
       (looking-at
        (concat
         "\\("
         (reduce (lambda (a b) (concat a "\\|" b))
                 auto-capitalize-words)
         "\\)")))
    (capitalize-word 1)))
  #+END_SRC

* downcase-save-excursion

  #+BEGIN_SRC emacs-lisp
(defun downcase-save-excursion ()
  (interactive)
(unless
(or
(looking-at "[[:punct:]]*[ ]*$")
(looking-at "[ ]*I\\b") ; never downcase the word "I"
(looking-at "[[:punct:]]*[ ]*[[:punct:]]*I'")  ; never downcase I'm I've etc.
(looking-at "[[:punct:]]*[ ]*$") ; zero or more whitespaces followed by zero or more punctuation followed by zero or more whitespaces followed by a line break
(looking-at "\"[[:punct:]]*[ ]*$") ; a quotation mark followed by "zero or more whitespace then end of line?"
(looking-at "\)[ ]*$") ; a quotation mark followed by "zero or more whitespace then end of line?"
(looking-at (sentence-end)) ; quotation mark followed by "zero or more whitespace then end of line?"
       (looking-at (user-full-name))


)
  (save-excursion
      (downcase-word 1))
  ))
  #+END_SRC


* smart-expand
Don't expand past certain delimiters, e.g. line break, ), and "


#+BEGIN_SRC emacs-lisp

(defun smart-expand ()
  (interactive)

  (unless

    (or
       (looking-back "\)\n*")
(looking-back "[[:punct:]]*\)[ ]*[[:punct:]]*[\n\t ]*[[:punct:]]*>*")
(looking-back ":t[ ]*")
(looking-back "][\n\t ]*[[:punct:]]*[\n\t ]*") ; don't expand past closing square brackets ]

(looking-back ">[\n\t ]*[[:punct:]]*[\n\t ]*") ; don't expand past closing email addresses]


;; (looking-back "\\\w") ; for some reason this matches all words, not just ones that start with a backslash
)
    (expand-abbrev)
)
)

#+END_SRC




(defun smart-expand ()
  (interactive)

  (unless

    (or
       (looking-back "\)\n*")
(looking-back "\)[ ]*")
(looking-back ":t[ ]*")

;; (looking-back "\\\w") ; for some reason this matches all words, not just ones that start with a backslash
)
    (expand-abbrev)
)
)

* fountain
  #+BEGIN_SRC emacs-lisp
;; (load-file "/Users/jay/emacs/emacs-settings/fountain-mode.el")
;; (use-package fountain-mode)

;; (add-hook 'fountain-mode-hook 'turn-on-olivetti-mode)
(add-hook 'fountain-mode-hook '(lambda () (orgalist-mode 1)))
(add-hook 'fountain-mode-hook 'turn-on-auto-capitalize-mode 'append)

(add-hook 'fountain-mode-hook (lambda () (imenu-list-minor-mode 1)))

(defcustom fountain-export-default-command
  'fountain-export-shell-script
  "\\<fountain-mode-map>Default function to call with \\[fountain-export-default]."
  :type '(radio (function-item fountain-export-shell-script)
                (function-item fountain-export-buffer-to-html))
  :group 'fountain-export)

(defcustom fountain-export-shell-script
  "afterwriting --config ~/.config/afterwriting/config.json --source %s --pdf --overwrite"
  "Shell command string to convert Fountain source to ouput.
\"%s\" will be substituted with `buffer-file-name'"
  :type 'string
  :group 'fountain-export)

(defun fountain-export-shell-script (&optional buffer)
  "Call shell script defined in `fountain-export-shell-script'."
  (interactive)
  (let* ((buffer (or buffer (current-buffer)))
         (file (shell-quote-argument (buffer-file-name buffer)))
         (command (format fountain-export-shell-script file)))
    (async-shell-command command "*Fountain Export Process*")))

(setq fountain-export-include-title-page nil)
(setq fountain-export-html-replace-alist
   (quote
    (("&" "&amp;")
     ("<" "&lt;")
     (">" "&gt;")
     ("\\\\ " "&nbsp;")
     ("^\\\\$" "<br>")
     ("\\\\_" "&#95;")
     ("\\\\\\*" "&#42;")
     ("\\\\`" "&#96;")
     ("\\\\'" "&apos;")
     ("``" "&ldquo;")
     ("''" "&rdquo;")
     ("`" "&lsquo;")
     ("'" "&rsquo;")
     ("\\*\\*\\*\\(.+?\\)\\*\\*\\*" "<span class=\"underline\">\\1</span>")
     ("\\*\\*\\(.+?\\)\\*\\*" "<span class=\"underline\">\\1</span>")
     ("\\*\\(.+?\\)\\*" "<span class=\"underline\">\\1</span>")
     ("^~ *\\(.+?\\)$\\*\\*" "<i>\\1</i>")
     ("_\\(.+?\\)_" "<span class=\"underline\">\\1</span>")
     ("

+" "<br><br>")
     ("
" "<br>"))))
  #+END_SRC

* Hook app
[[https://discourse.hookproductivity.com/t/integrating-emacs-and-hook-with-org-mode/932/10][Integrating Emacs and Hook, with org-mode - Discussion & Help - Hook Productivity Forum]]

#+begin_src emacs-lisp

(setq frame-title-format '((:eval buffer-file-name)))

(defun my/hook (hook)
 "Create an org-link target string using `hook://` url scheme."
 (shell-command (concat "open \"" hook "\"")))

 (org-add-link-type "hook" 'my/hook)
#+end_src

* keybindings for terminal
#+BEGIN_SRC emacs-lisp
(define-key key-minor-mode-map (kbd "M-(") 'backward-word)
(define-key key-minor-mode-map (kbd "M-)") 'forward-word)
#+END_SRC


* capitalize sentence
#+BEGIN_SRC emacs-lisp
(defun capitalize-sentence ()
  (interactive)
(unless (my/beginning-of-sentence-p)
(org-backward-sentence))
  (endless/capitalize)
(org-forward-sentence 1)
(jay/right-char)
)
(define-key key-minor-mode-map (kbd "M-C") 'capitalize-word)

#+END_SRC

* downcase sentence
#+BEGIN_SRC emacs-lisp
(defun downcase-sentence ()
  (interactive)
(unless (my/beginning-of-sentence-p)
(org-backward-sentence))
  (downcase-word 1)
(org-forward-sentence 1)
(jay/right-char)
)

(define-key key-minor-mode-map (kbd "M-L") 'downcase-sentence)

#+END_SRC

* return-insert-blank-line-before

#+BEGIN_SRC emacs-lisp
(defun return-insert-blank-line-before ()
  (interactive)
  (beginning-of-line)
(newline)
  )
#+END_SRC


* disable color themes
#+BEGIN_SRC emacs-lisp
(defadvice load-theme (before theme-dont-propagate activate)
 (mapc #'disable-theme custom-enabled-themes))
#+END_SRC

* toggle item or hyphenation
#+BEGIN_SRC emacs-lisp
(defun toggle-item-or-hyphenation ()
(interactive "P")
(if

    (region-active-p)                               ; if
    (org-toggle-item) ; then
    (cycle-hyphenation); else
)
)
#+END_SRC

* my-forward-sentence
#+BEGIN_SRC emacs-lisp
(defun smart-forward-sentence ()
  (interactive)
  (org-forward-sentence)
  (my/fix-space)
  )
#+END_SRC



* replace-inner
#+BEGIN_SRC emacs-lisp
(defun replace-inner ()
  (interactive)
(change-inner)
  (pasteboard-paste-no-spaces)
  )
#+END_SRC

doesn't work.


* bjm-swiper

#+BEGIN_EXAMPLE emacs-lisp
;;advise swiper to recenter on exit
(defun bjm-swiper-recenter (&rest args)
  "recenter display after swiper"
  (recenter)
  )
(advice-add 'swiper :after #'bjm-swiper-recenter)
#+END_EXAMPLE

* available keybindings

s-i
s-N
s-:
s-. searchlink
s-u
m-,

s-i
C->
C-<
M-1 to 9



* embolden-or-bold


#+BEGIN_SRC emacs-lisp

(defun embolden-or-bold (arg)
  (interactive "p")
  (if (region-active-p)
      ;;      (wrap-region-trigger arg "*")
      (let ((s (replace-regexp-in-string
                "[*]" "" (delete-and-extract-region (region-beginning) (region-end)))))
        (insert "*")
        (insert s)
        (insert "*"))
    (embolden-next-word)))

#+END_SRC

* color theme advice
#+BEGIN_SRC emacs-lisp
  (defadvice load-theme (after load-theme-advice activate)
  (custom-set-faces
  '(bold ((t (:inherit font-lock-warning-face :weight bold))))
  '(org-quote ((t (:inherit default))))
  ;; '(org-link ((t (:underline nil))))
  '(org-done ((,class (:weight bold :box (:line-width 1 :color "#BBBBBB") :foreground "#BBBBBB" :background "green"))))



  (org-mode)
    ))
#+END_SRC


* leader key, doesn't need a special mode

#+BEGIN_SRC emacs-lisp
(define-key key-minor-mode-map (kbd "] i t") 'org-inlinetask-insert-task)
(define-key key-minor-mode-map (kbd "] c[") 'load-shared-functions)
(define-key key-minor-mode-map (kbd "] c]") 'load-gnu-startup)
(define-key key-minor-mode-map (kbd "] ]") 'insert-right-bracket)

#+END_SRC


* fix image links
#+BEGIN_EXAMPLE emacs-lisp
(defun fix-image-links ()
(interactive)
(goto-char 1)
(while (search-forward-regexp "[[\(.*?\).jpg][\(.*?\).jpg]]" nil t)
  (replace-match "[[" (match-string 1) ".jpg]]"  t nil))

(while (search-forward-regexp "[[\(.*?\).png][\(.*?\).png]]" nil t)
  (replace-match "[[" (match-string 1) ".png]]"  t nil))
)
#+END_EXAMPLE


* replace garbage characters

Òembedding-

→

"embedding"

#+BEGIN_SRC emacs-lisp
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun replace-garbage-chars ()
  "Replace goofy MS and other garbage characters with latin1 equivalents."
  (interactive)
  (save-excursion				;save the current point
    (replace-string "  " " " nil (point-min) (point-max))
    (replace-string "" "" nil (point-min) (point-max))
    (replace-string "΄" "\"" nil (point-min) (point-max))
    (replace-string "“" "\"" nil (point-min) (point-max))
    (replace-string "’" "'" nil (point-min) (point-max))
    (replace-string "“" "\"" nil (point-min) (point-max))
    (replace-string "—" "--" nil (point-min) (point-max)) ; multi-byte
    (replace-string "" "'" nil (point-min) (point-max))
    (replace-string "" "'" nil (point-min) (point-max))
    (replace-string "" "\"" nil (point-min) (point-max))
    (replace-string "" "\"" nil (point-min) (point-max))
    (replace-string "" "\"" nil (point-min) (point-max))
    (replace-string "" "\"" nil (point-min) (point-max))
    (replace-string "‘" "\"" nil (point-min) (point-max))
    (replace-string "’" "'" nil (point-min) (point-max))
    (replace-string "¡\"" "\"" nil (point-min) (point-max))
    (replace-string "¡­" "..." nil (point-min) (point-max))
    (replace-string "" "..." nil (point-min) (point-max))
    (replace-string "" " " nil (point-min) (point-max)) ; M-SPC
    (replace-string "" "`" nil (point-min) (point-max))  ; \221
    (replace-string "" "'" nil (point-min) (point-max))  ; \222
    (replace-string "" "``" nil (point-min) (point-max))
    (replace-string "" "''" nil (point-min) (point-max))
    (replace-string "" "*" nil (point-min) (point-max))
    (replace-string "" "--" nil (point-min) (point-max))
    (replace-string "" "--" nil (point-min) (point-max))
    (replace-string " " " " nil (point-min) (point-max)) ; M-SPC
    (replace-string "¡" "\"" nil (point-min) (point-max))
    (replace-string "´" "\"" nil (point-min) (point-max))
    (replace-string "»" "<<" nil (point-min) (point-max))
    (replace-string "Ç" "'" nil (point-min) (point-max))
    (replace-string "È" "\"" nil (point-min) (point-max))
    (replace-string "é" "e" nil (point-min) (point-max)) ;; &eacute;
    (replace-string "ó" "-" nil (point-min) (point-max))

    (replace-string " Ñ " "---" nil (point-min) (point-max))


    (replace-string "á" "-" nil (point-min) (point-max))
  (replace-string "     " "" nil (point-min) (point-max))
  (replace-string "    " "" nil (point-min) (point-max))
  (replace-string " " " " nil (point-min) (point-max))
  (replace-string " " "" nil (point-min) (point-max))


  (replace-string "Õ" "'" nil (point-min) (point-max))
  (replace-string "Ò" "\"" nil (point-min) (point-max))
  (replace-string "Ó" "\"" nil (point-min) (point-max))



  ))
#+END_SRC

* replace missing PDF ligatures

different → different

#+BEGIN_SRC emacs-lisp
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun replace-missing-ligatures ()
"Replace goofy MS and other garbage characters with latin1 equivalents."
(interactive)
(save-excursion				; save the current point

  (replace-string "de cit" "deficit" nil (point-min) (point-max))
  (replace-string "di eren" "differen" nil (point-min) (point-max))
  (replace-string "e ective" "effective" nil (point-min) (point-max))
  (replace-string "de ne" "define" nil (point-min) (point-max))
  (replace-string "re ect" "reflect" nil (point-min) (point-max))
  (replace-string "o er" "offer" nil (point-min) (point-max))
  (replace-string "con den" "confiden" nil (point-min) (point-max))
  (replace-string "con ict" "conflict" nil (point-min) (point-max))
;(replace-string "nd" "find" nil (point-min) (point-max)); whole word only
;(replace-string "ve" "five" nil (point-min) (point-max)); this one should be whole word only
; (replace-string "ve" "they" nil (point-min) (point-max)); this one should be whole word only
; (replace-string "ve" "the" nil (point-min) (point-max)); this one should be whole word only
  (replace-string "scientifc" "scientific" nil (point-min) (point-max))



))
#+END_SRC

* web-mode
#+BEGIN_SRC emacs-lisp

    (use-package web-mode
:defer
:init
 (add-hook 'web-mode-hook
      (lambda ()
       (rainbow-mode)
       (rspec-mode)
       (setq web-mode-markup-indent-offset 2)))

;; (setq web-mode-load-hook (quote ((lambda nil (abbrev-mode -1)))))

(add-hook 'web-mode-hook (lambda () (abbrev-mode -1)))

    :bind (:map web-mode-map


  ("s-O" . prelude-open-with)))
#+END_SRC

* flyspell fix
#+BEGIN_SRC emacs-lisp
(setq flyspell-abbrev-p t)
(setq flyspell-use-global-abbrev-table-p t)
(setq global-flyspell-mode t)
#+END_SRC




* mw-thesaurus
#+BEGIN_SRC emacs-lisp
(use-package mw-thesaurus
  :defer)
(load "/Users/jay/emacs/emacs-settings/secret-codes.el")
(define-key key-minor-mode-map (kbd "M-s-t") 'mw-thesaurus-lookup-at-point)
#+END_SRC

