#+auto_tangle: t
* NOTE-TO-JAY file settings             :ARCHIVE:
#+OPTIONS: f:t
#+ TODO: TODO PLEASE-TEST TESTING PLEASE-DEBUG | DONE
#+TODO: | NOTE-TO-JAY NOTE-TO-RUDI NOTE-TO-R√öDI
#+TODO: PLEASE-CHECK-MY-INEPT-CODE PLEASE-HELP-ME-DEBUG-MY-INEPT-CODE TRY-THIS | DONE

#+TITLE: #+TITLE: Jay Dixit's GNU Emacs setup
#+TITLE: Jay Dixit's GNU Emacs setup
* environment settings
** Handle Emacs UTF-8 input
#+BEGIN_SRC emacs-lisp
;; early-init.el  ‚îÄ‚îÄ locale in one place
(set-language-environment "UTF-8")   ; everything speaks UTF-8
(setenv "LANG" "en_US.UTF-8")        ; tell subprocesses
#+END_SRC

** Sticky windows
#+BEGIN_SRC emacs-lisp
;; (global-set-key  (kbd "s-0") 'delete-window)
; (global-set-key  (kbd "s-3") 'split-window-horizontally)
#+END_SRC

* abbreviations
Automatically load abbreviations table:
#+BEGIN_SRC emacs-lisp
(setq-default abbrev-mode t)

(setq abbrev-file-name "/Users/jay/emacs/abbrevs/.abbrev_defs")
(setq save-abbrevs t)
(setq save-abbrevs 'silently)
(setq only-global-abbrevs t)


(run-with-idle-timer
 1 nil
 (lambda ()
   (save-place-mode -1)
   (setq-default abbrev-mode t)
   (read-abbrev-file "/Users/jay/emacs/abbrevs/.abbrev_defs")))
#+END_SRC

* Support batch startup
#+BEGIN_SRC emacs-lisp
;; Ensure dependent keymaps exist even when this file is loaded in batch
;; without the broader Spacemacs environment.
(require 'org nil t)
(require 'help-mode nil t)
(require 'flyspell nil t)
#+END_SRC

* reflash-indentation
#+BEGIN_SRC emacs-lisp
(defun reflash-indentation ()
  "Fix spacing on the screen."
  (interactive)
  (org-indent-mode 1)
  (recenter-top-bottom)
  (jay/adjust-font-size))
#+END_SRC

* org predicates
  #+BEGIN_SRC emacs-lisp
(use-package org-element
:defer t
  )

  (defun org-checkbox-p ()
  "Predicate: Checks whether the current line org-checkbox"
    (and
;; (org-or-orgalist-p)
      (string-match "^\s*\\([-+*]\\|[0-9]+[.\\)]\\)\s\\[.?\\]\s" (or (thing-at-point 'line) ""))))

  (defun org-plain-text-list-p ()
  "Predicate: Checks whether the current line org-plain-text-list"
    (and
;; (org-or-orgalist-p)
      (string-match "^\s*\\([-+]\\|\s[*]\\|[0-9]+[.\\)]\\)\s" (or (thing-at-point 'line) ""))))
  #+END_SRC

* org-mode hooks
  #+BEGIN_SRC emacs-lisp
(setq org-hierarchical-todo-statistics nil)
  #+END_SRC


* fullscreen settings
[[http://amitp.blogspot.ca/2008/05/emacs-full-screen-on-mac-os-x.html][(Source)]]

#+BEGIN_SRC emacs-lisp
(defun jay/toggle-fullscreen ()
  "Toggle fullscreen mode with proper macOS support and reliably manage tab-bar-mode for notch concealment."
  (interactive)
  (let ((was-fullscreen (frame-parameter nil 'fullscreen)))
    ;; Toggle fullscreen
    (set-frame-parameter
     nil 'fullscreen
     (if was-fullscreen nil 'fullboth))

    ;; Adjust font size if applicable
    (when (fboundp 'jay/adjust-font-size)
      (jay/adjust-font-size))

    ;; Update tab bar after brief delay
    (run-with-timer
     0.1 nil
     (lambda ()
       (let ((on-macbook (jay/on-macbook-display-p))
             (now-fullscreen (frame-parameter nil 'fullscreen)))
         (if now-fullscreen
             (progn
               (when on-macbook (tab-bar-mode 1))
               (message "üß≠ Fullscreen engaged, sir. Tab bar deployed in ceremonial defense of the notch."))
           (progn
             (tab-bar-mode -1)
             (message "üé© Fullscreen dismissed. Tab bar has made itself scarce, as propriety demands."))))))))

;; Alternative: Toggle between maximized and normal (no fullscreen)
(defun jay/toggle-maximized ()
  "Toggle between maximized and normal frame size."
  (interactive)
  (let ((maximized-p (eq (frame-parameter nil 'fullscreen) 'maximized)))
    (set-frame-parameter
     nil 'fullscreen
     (if maximized-p nil 'maximized))
    ;; Adjust font size if available
    (when (fboundp 'jay/adjust-font-size)
      (jay/adjust-font-size))
    (message "Frame %s" (if maximized-p "restored" "maximized"))))

#+END_SRC


* maximize when relaunching
#+begin_src emacs-lisp
(add-hook 'after-make-frame-functions
          (lambda (frame)
            ;; Ensure the code runs in the context of the new frame
            (with-selected-frame frame
              (jay/toggle-fullscreen))))

(with-eval-after-load 'server      ; ensure `server.el` is loaded first
  (add-hook 'server-switch-hook #'jay/toggle-fullscreen))
#+end_src

* tabbar
So Emacs text doesn't appear on the MacBook Pro notch.

#+BEGIN_SRC emacs-lisp
(use-package tab-bar
:defer t
 :config
 (tab-bar-mode -1))

(defun jay/toggle-tab-bar-mode ()
(interactive)
  "Toggle `tab-bar-mode' based on the current frame fullscreen state in order to hide the MacBook Pro notch when in fullscreen mode."
  (if (frame-parameter nil 'fullscreen)
      (tab-bar-mode 1)
    (tab-bar-mode -1)))

;; (add-hook 'window-configuration-change-hook #'jay/toggle-tab-bar-mode)
#+END_SRC


* other functions
Manually remove the scrollbar if default setting fails when creating a new frame:

#+BEGIN_SRC emacs-lisp
(defun scrollbar-init ()
  (interactive)
  (scroll-bar-mode -1)
  )

(defun scrollbar-mode-turn-off-scrollbar ()
  (interactive)
  (scroll-bar-mode -1)
  )

(defun scrollbar-mode-turn-on-scrollbar ()
  (interactive)
  (scroll-bar-mode 1)
  )
#+END_SRC


#+BEGIN_SRC emacs-lisp
(require 'dired)                          ; ensure hook is defined

(defun my/recover-session-show-autosaves (orig-fun &rest args)
  "Run `recover-session' with Dired-Omit temporarily disabled."
  (let ((dired-mode-hook
         (remove 'enable-dired-omit-mode dired-mode-hook)))
    (apply orig-fun args)))

(advice-add 'recover-session :around #'my/recover-session-show-autosaves)
#+END_SRC


* load keys
#+begin_src emacs-lisp
(add-to-list 'load-path (expand-file-name "lisp" user-emacs-directory))

;; Now, load your keybindings file.
;; 'keys' corresponds to the (provide 'keys) line at the end of keys.el
(require 'keys)
#+end_src

* keybindings
** Create custom keybinding prefix
#+BEGIN_QUOTE
I have an unconventional approach to this that I recommend highly. I have redefined the C-l ('ell') key to be a prefix key, and I use that to prefix my favorite commands. This key is very easy to type and it is bound to a function ('recenter) that isn't used that much. Well, I don't use 'recenter much, but even if you did, it can be assigned to C-l C-l which is almost as easy to type, and a small price to pay for the possibilities opened up by the Ctrl-L-map. (Actually I prefer 'redraw-display to 'recenter, so I gave that the place of honor.)
#+END_QUOTE
Source: [[http://stackoverflow.com/questions/5682631/what-are-good-custom-keybindings-kn-emacs/5682737#5682737][ LenW's answer on keyboard - What are good custom keybindings in emacs? - Stack Overflow]]

Use ‚åò-m as prefix for my own custom keybindings:
#+BEGIN_SRC emacs-lisp

;; (global-set-key (kbd "s-k") nil)

(with-eval-after-load 'evil
  (defvar s-k-map (make-keymap)
    "Keymap for local bindings and functions, prefixed by (Command-M)")
  (fset 's-k-prefix s-k-map))
#+END_SRC


** Custom Key Bindings
*** Help
#+BEGIN_SRC emacs-lisp
;; Keybindings moved to keys.el
#+END_SRC

*** NOTE-TO-JAY TODO Custom keybindings
Eventually replace these with this? https://github.com/noctuid/general.el



#+BEGIN_SRC emacs-lisp
;; Keybindings moved to keys.el
#+END_SRC

...


*** available key bindings
#+begin_src emacs-lisp
;; (define-key key-minor-mode-map (kbd "s-A") 'available)
;; Define the available key bindings
;; (define-key key-minor-mode-map (kbd "s-H") 'available) ;; ‚åò-H
;; (define-key key-minor-mode-map (kbd "s-n") 'available) ;; ‚åò-n
;; (define-key key-minor-mode-map (kbd "s-N") 'available) ;; ‚åò-N
;; (define-key key-minor-mode-map (kbd "s-P") 'available) ;; ‚åò-P
;; (define-key key-minor-mode-map (kbd "s-U") 'available) ;; ‚åò-U
;; (define-key key-minor-mode-map (kbd "s-X") 'available) ;; ‚åò-X
;; (define-key key-minor-mode-map (kbd "s-Y") 'available) ;; ‚åò-Y
;; (define-key key-minor-mode-map (kbd "s-.") 'available) ;; s-.
;; (define-key key-minor-mode-map (kbd "s-:") 'available) ;; s-:
;; (define-key key-minor-mode-map (kbd "C-\\") 'available) ;; C-\

;; available
;; (define-key key-minor-mode-map (kbd "C-\") 'available)
;;(define-key key-minor-mode-map (kbd "s-:") 'consult-outline)


#+end_src

*** OSX ‚åò key bindings
Recognize the ‚åò key in both GNU Emacs and Aquamacs as hyper key:
#+BEGIN_SRC emacs-lisp
(defvar gnuemacs-flag (string-match "GNU" (emacs-version)))
(defvar aquamacs-flag (string-match "Aquamacs" (emacs-version)))

(defun define-super-key (key fun)
 (cond
 (gnuemacs-flag
 (define-key key-minor-mode-map (kbd (concat "s-" key)) fun))))
#+END_SRC

**** mksuper - shared Aquamacs / GNU Emacs keybindings:
Deprecated in favor of (define-key key-minor-mode-map (kbd "s... in:
[[/Users/jay/emacs/emacs-settings/gnu-emacs-startup.org]]

#+BEGIN_EXAMPLE emacs-lisp
(define-super-key "h" 'replace-string)


(define-super-key "m" 'mc/mark-all-like-this)


(define-super-key "\\" 'visit-most-recent-file)

(define-super-key "F" 'pasteboard-search-for-clipboard-contents)

(define-super-key "R" 'projectile-find-file)
(define-super-key "t" 'new-buffer)
(define-super-key "T" 'org-new-scratch-buffer)
(define-super-key "g" 'isearch-repeat-forward)
(define-super-key "d" 'org-todo)
(define-super-key "L" 'org-mac-link-chrome-insert-frontmost-url)
(define-super-key "S" 'org-mac-link-skim-insert-page)
(define-super-key "a" 'mark-whole-buffer) ; select all
(define-super-key "w" 'delete-window) ; close
(define-super-key "s" 'jay/save-some-buffers ) ; save all
#+END_EXAMPLE

Key bindings I don't use much and should remember to learn:
#+BEGIN_SRC emacs-lisp
;; why not use N and P here? TODO


#+END_SRC

mkprefix: Key bindings for my own custom functions, using ‚åò-m as a prefix:
#+BEGIN_SRC emacs-lisp










;; ;; Accountability

(defun keybinding-read-and-insert (key)
 (interactive "kKey: ")
(insert "(define-key key-minor-mode-map ")
  (insert (format "(kbd \"%s\")" (key-description key)))
  (insert " '")
(save-excursion (insert ")")
    ))



#+END_SRC



* sentences
Make ~kill-sentence~ work in a more intuitive way:
#+BEGIN_SRC emacs-lisp
(defun kill-sentence-to-period ()
  "Leave the period in there."
  (interactive)
  (kill-sentence)
  (push-mark)
  (insert ".")
  (backward-char)
)
#+END_SRC

[[http://emacs.stackexchange.com/questions/12266/how-change-behavior-of-kill-sentence-based-on-position-in-sentence/12321?iemail=1&noredirect=1#12321][Source]]

#+BEGIN_SRC emacs-lisp
(defun my/forward-to-sentence-end ()
  "Move point to just before the end of the current sentence."
  (forward-sentence)
  (backward-char)
  (unless (looking-back "[[:alnum:]]")
    (backward-char)))

(defun my/beginning-of-sentence-p ()
  "Return t if point is at the beginning of a sentence."
  (let* ((start (point))
         (beg (save-excursion
                (ignore-errors
                  (forward-sentence)
                  (forward-sentence -1)
                  (point)))))
    (and beg (eq start beg))))

(defun my/kill-sentence-dwim ()
  "Kill the current sentence up to and possibly including the punctuation.
When point is at the beginning of a sentence, kill the entire
sentence. Otherwise kill forward but preserve any punctuation at the sentence end."
  (interactive)
(smart-expand)
  (if (my/beginning-of-sentence-p)
      (progn
        (kill-sentence)
        (just-one-space)
        (when (looking-back "^[[:space:]]+") (delete-horizontal-space)))
      (kill-region (point) (progn (my/forward-to-sentence-end) (point)))
      (just-one-space 0))

;; don't leave two periods in a row
(when
(or
(looking-at "\\.\\. ")
(and
(looking-at "\\.")
(looking-back "\\.")
)
)
(delete-forward-char 1))

(when
    (and
     (looking-at ".")
     (looking-back ",")
     )
  (delete-backward-char 1)
  (forward-char 1)
  )

)
#+END_SRC

* my/kill-line-dwim
#+BEGIN_SRC emacs-lisp


(defun my/kill-line-dwim ()
  "Kill the current line."
  (interactive)
;; don't leave stray stars behind when killing a line
(when
(or
(looking-back "\\[")
(looking-back "\* ")
(looking-back "\* TODO ")
(looking-back "^\*+")
(looking-back "- ")
(looking-back "# ")
)
(beginning-of-line)
)
;;  (expand-abbrev)
  (org-kill-line)
;;  (save-excursion
;;    (when (my/beginning-of-sentence-on)
;;      (capitalize-unless-org-heading)))
)
#+END_SRC

* kill-sentence-maybe-else-kill-line
  #+BEGIN_SRC emacs-lisp
(defun kill-sentence-maybe-else-kill-line ()
  (interactive)
(when
    (not (looking-at "$"))
  (my/kill-sentence-dwim))
  (when
      (looking-at "$")
    (my/kill-line-dwim))
)
;; and the keybinding

  #+END_SRC


* Browsing

** smart insertion of headings and subheadings
** smart-org-meta-return-dwim
 #+BEGIN_SRC emacs-lisp
(setq org-blank-before-new-entry
      '((heading . always)
       (plain-list-item . always)))

(defun call-rebinding-org-blank-behaviour (fn)
  (let ((org-blank-before-new-entry
         (copy-tree org-blank-before-new-entry)))
    (when (org-at-heading-p)
      (rplacd (assoc 'heading org-blank-before-new-entry) nil))
    (call-interactively fn)))

(defun smart-org-meta-return-dwim ()
  (interactive)

(if

    (and
     (looking-back "^")
     (looking-at-p "\\S-")
     )                               ; if
    (org-toggle-heading-same-level) ; then
 (call-rebinding-org-blank-behaviour 'org-meta-return)) ; else
)


#+END_SRC

*** smart-org-insert-heading-respect-content-dwim
#+BEGIN_SRC emacs-lisp
(defun smart-org-insert-heading-respect-content-dwim ()
(interactive)
  (call-rebinding-org-blank-behaviour 'org-insert-heading-respect-content)
)
#+END_SRC

*** smart-org-insert-todo-heading-dwim
#+BEGIN_SRC emacs-lisp
(defun smart-org-insert-todo-heading-dwim ()
  (interactive)
  (let ((listitem-or-checkbox (org-plain-text-list-p)))
    (call-rebinding-org-blank-behaviour 'org-insert-heading)
    (if listitem-or-checkbox
        (insert "[ ] ")
        (insert "TODO ")))
)

#+END_SRC

*** smart-org-insert-todo-heading-respect-content-dwim
#+BEGIN_SRC emacs-lisp
(defun smart-org-insert-todo-heading-respect-content-dwim ()
  (interactive)
  (call-rebinding-org-blank-behaviour 'org-insert-todo-heading-respect-content)
)
#+END_SRC

*** smart-org-insert-subheading
#+BEGIN_SRC emacs-lisp
(defun smart-org-insert-subheading ()
  (interactive)
(call-rebinding-org-blank-behaviour 'org-meta-return)
(org-demote-subtree)
)
#+END_SRC

*** smart-org-insert-todo-subheading
#+BEGIN_SRC emacs-lisp
(defun smart-org-insert-todo-subheading ()
  (interactive)
(call-rebinding-org-blank-behaviour 'org-insert-todo-subheading)
)
#+END_SRC

*** keybindings
#+BEGIN_SRC emacs-lisp
 #+END_SRC


*** length of previous line
#+BEGIN_SRC emacs-lisp

(defun length-of-previous-line ()
 (save-excursion
  (forward-line -1)
  (end-of-line)
  (current-column)))
#+END_SRC

* Kill words
** kill word correctly
#+BEGIN_SRC emacs-lisp
(defun kill-word-correctly ()
  "Kill word."
  (interactive)
  (smart-expand)
  (if (or (re-search-forward "\\=[ 	]*\n" nil t)
          (re-search-forward "\\=\\W*?[[:punct:]]+" nil t)) ; IF there's a sequence of punctuation marks at point
      (kill-region (match-beginning 0) (match-end 0)) ; THEN just kill the punctuation marks
    (kill-word 1))                                    ; ELSE kill word
  (my/fix-space)
;; don't leave two periods in a row
(when
(or
(looking-at "\\,\\, ")

(and
(looking-at "\\,")
(looking-back "\\,")
)
)
(delete-forward-char 1))
)

#+END_SRC

** kill word correctly and capitalize
#+BEGIN_SRC emacs-lisp
(defun kill-word-correctly-and-capitalize ()
  "Kill the word correctly and capitalize if at the beginning of a sentence and capitalist-mode is enabled."
  (interactive)
  ;; Move forward if at a space
  (when (looking-at " ")
    (forward-char 1))
  ;; Check if at the beginning of a sentence
  (let ((fix-capitalization (my/beginning-of-sentence-p)))
    ;; Kill the word correctly
    (call-interactively 'kill-word-correctly)
    ;; Capitalize if needed and capitalist-mode is enabled
    ;; (when (fix-capitalization)
    ;;   (save-excursion
        (capitalize-unless-org-heading)
;; ))
))


(defun kill-word-correctly-and-capitalize ()
  "Kill the word correctly. If at the beginning of a sentence, also capitalize."
  (interactive)
  (atomic-change-group
    ;; 1) Move forward if at a space
    (when (looking-at " ")
      (forward-char 1))

    ;; 2) Check if we're at the beginning of a sentence
    (let ((fix-capitalization (my/beginning-of-sentence-p)))
      ;; 3) Kill the word
      (call-interactively 'kill-word-correctly)
      ;; 4) Capitalize
      (when fix-capitalization
        (save-excursion
          (capitalize-unless-org-heading))))))
#+END_SRC



* Character movement
#+BEGIN_SRC emacs-lisp
(defun jay/left-char ()
  "Move point to the left or the beginning of the region.
 Like `backward-char', but moves point to the beginning of the region
provided the (transient) mark is active."
  (interactive)
  (let ((this-command 'left-char)) ;; maintain compatibility
    (let ((left (min (point)
                     ;; `mark' returning nil is ok; we'll only use this
                     ;; if `mark-active'
                     (or (mark t) 0))))
      (if (and transient-mark-mode mark-active)
          (progn
            (goto-char left)
            (setq deactivate-mark t))
        (call-interactively 'left-char)))))


(defun jay/right-char ()
  "Move point to the right or the end of the region.
 Like `right-char', but moves point to the end of the region
provided the (transient) mark is active."
  (interactive)
  (let ((this-command 'right-char)) ;; maintain compatibility
    (let ((right (max (point)
                      ;; `mark' returning nil is ok; we'll only use this
                      ;; if `mark-active'
                      (or (mark t) 0))))
      (if (and transient-mark-mode mark-active)
          (progn (goto-char right)
		 (setq deactivate-mark t))
	(call-interactively 'right-char)))))


#+END_SRC


* saveplace
;; Save point position between sessions

#+BEGIN_SRC emacs-lisp
#+END_SRC

The saveplace package is part of Emacs, and remembers the position of point - even between emacs sessions.

The last line sets the path to where saveplace stores your position data. Change it at your peril!

* cycle-hyphenation
#+BEGIN_SRC emacs-lisp
(defun cycle-hyphenation ()
  (interactive)
  (cond ((re-search-forward "\\=\\w*\\(-\\)\\w+" nil t)
         (save-excursion (replace-match " " t t nil 1)))
        ((re-search-forward "\\=\\w*\\( +\\)\\w+" nil t)
         (save-excursion (replace-match "-" t t nil 1)))))
#+END_SRC

* cycle-punctuation
#+BEGIN_SRC emacs-lisp
(defvar *punctuation-markers-to-cycle-between*  ".?!")

(defun cycle-punctuation ()
  (interactive)
  (save-excursion
    (forward-sentence)
    (when (re-search-backward (format "\\>\\([%s]\\)[[:space:]]*\\="
                                      *punctuation-markers-to-cycle-between*)
                              nil t)
      (let ((next (elt *punctuation-markers-to-cycle-between*
                       ;; circular string; should be abstracted
                       (mod (1+ (position (elt (match-string 1) 0)
                                          *punctuation-markers-to-cycle-between*))
                            (length *punctuation-markers-to-cycle-between*)))))
        (replace-match (format "%c" next) t t nil 1)))))

;; (define-key key-minor-mode-map (kbd "M-.") 'cycle-punctuation)
#+END_SRC

* clone subtree
#+BEGIN_SRC emacs-lisp
(defun org-clone-subtree ()
  "Clone the current subtree and modify the clone's heading.
If the heading ends with a number, increment it (e.g., 'draft 1' -> 'draft 2').
Otherwise, append ' (clone)' to the heading.
Adds an empty line before the cloned subtree."
  (interactive)
  (org-clone-subtree-with-time-shift 1)
  (save-excursion
    (org-goto-sibling)
    ;; Add empty line before the clone
    (beginning-of-line)
    (insert "\n")
    ;; Adapted from http://orgmode.org/worg/org-hacks.html#orgheadline10.
    (when (org-at-heading-p)
      (let ((hl-text (nth 4 (org-heading-components))))
        (when hl-text
          (beginning-of-line)
          (let* ((start (search-forward hl-text (point-at-eol)))
                 (end start)
                 (beg (- start (length hl-text)))
                 (new-text
                  (if (string-match "\\(.*[^0-9]\\)\\([0-9]+\\)\\s-*$" hl-text)
                      ;; Heading ends with a number - increment it
                      (let ((prefix (match-string 1 hl-text))
                            (num (string-to-number (match-string 2 hl-text))))
                        (format "%s%d" prefix (1+ num)))
                    ;; No trailing number - add "(clone)"
                    (format "%s (clone)" hl-text))))
            (delete-region beg end)
            (goto-char beg)
            (insert new-text)))))))
#+END_SRC

* fountain
  #+BEGIN_SRC emacs-lisp
(when (require 'orgalist nil 'noerror)
  (add-hook 'fountain-mode-hook #'(lambda () (orgalist-mode 1))))
;; (add-hook 'fountain-mode-hook 'turn-on-auto-capitalize-mode 'append)
(add-hook 'fountain-mode-hook (lambda () (imenu-list-minor-mode 1)))

(defcustom fountain-export-default-command
  'fountain-export-shell-script
  "\\<fountain-mode-map>Default function to call with \\[fountain-export-default]."
  :type '(radio (function-item fountain-export-shell-script)
                (function-item fountain-export-buffer-to-html))
  :group 'fountain-export)

(defcustom fountain-export-shell-script
  "afterwriting --config ~/.config/afterwriting/config.json --source %s --pdf --overwrite"
  "Shell command string to convert Fountain source to ouput.
\"%s\" will be substituted with `buffer-file-name'"
  :type 'string
  :group 'fountain-export)

(defun fountain-export-shell-script (&optional buffer)
  "Call shell script defined in `fountain-export-shell-script'."
  (interactive)
  (let* ((buffer (or buffer (current-buffer)))
         (file (shell-quote-argument (buffer-file-name buffer)))
         (command (format fountain-export-shell-script file)))
    (async-shell-command command "*Fountain Export Process*")))

(setq fountain-export-include-title-page nil)
(setq fountain-export-html-replace-alist
   (quote
    (("&" "&amp;")
     ("<" "&lt;")
     (">" "&gt;")
     ("\\\\ " "&nbsp;")
     ("^\\\\$" "<br>")
     ("\\\\_" "&#95;")
     ("\\\\\\*" "&#42;")
     ("\\\\`" "&#96;")
     ("\\\\'" "&apos;")
     ("``" "&ldquo;")
     ("''" "&rdquo;")
     ("`" "&lsquo;")
     ("'" "&rsquo;")
     ("\\*\\*\\*\\(.+?\\)\\*\\*\\*" "<span class=\"underline\">\\1</span>")
     ("\\*\\*\\(.+?\\)\\*\\*" "<span class=\"underline\">\\1</span>")
     ("\\*\\(.+?\\)\\*" "<span class=\"underline\">\\1</span>")
     ("^~ *\\(.+?\\)$\\*\\*" "<i>\\1</i>")
     ("_\\(.+?\\)_" "<span class=\"underline\">\\1</span>")
     ("

+" "<br><br>")
     ("
" "<br>"))))
  #+END_SRC

* Hook app
[[https://discourse.hookproductivity.com/t/integrating-emacs-and-hook-with-org-mode/932/10][Integrating Emacs and Hook, with org-mode - Discussion & Help - Hook Productivity Forum]]

#+begin_src emacs-lisp

(setq frame-title-format '((:eval buffer-file-name)))

(defun my/hook (hook)
 "Create an org-link target string using `hook://` url scheme."
 (shell-command (concat "open \"" hook "\"")))

 (org-add-link-type "hook" 'my/hook)
#+end_src

* keybindings for terminal
#+BEGIN_SRC emacs-lisp
#+END_SRC


* return-insert-blank-line-before
#+BEGIN_SRC emacs-lisp
(defun return-insert-blank-line-before ()
  (interactive)
  (beginning-of-line)
(newline)
  )
#+END_SRC


* disable color themes
#+BEGIN_SRC emacs-lisp
(defadvice load-theme (before theme-dont-propagate activate)
 (mapc #'disable-theme custom-enabled-themes))
#+END_SRC

* toggle item or hyphenation
#+BEGIN_SRC emacs-lisp
(defun toggle-item-or-hyphenation ()
(interactive "P")
(if

    (region-active-p)                               ; if
    (org-toggle-item) ; then
    (cycle-hyphenation); else
)
)
#+END_SRC

* my-forward-sentence
#+BEGIN_SRC emacs-lisp
(defun smart-forward-sentence ()
  (interactive)
  (org-forward-sentence)
  (my/fix-space)
  )
#+END_SRC



* replace-inner
#+BEGIN_SRC emacs-lisp
(defun replace-inner ()
  (interactive)
(change-inner)
  (pasteboard-paste-verbatim)
  )
#+END_SRC

doesn't work.


* bjm-swiper
#+BEGIN_EXAMPLE emacs-lisp
;;advise swiper to recenter on exit
(defun bjm-swiper-recenter (&rest args)
  "recenter display after swiper"
  (recenter)
  )
(advice-add 'swiper :after #'bjm-swiper-recenter)
#+END_EXAMPLE


* embolden-or-bold
#+BEGIN_SRC emacs-lisp

(defun embolden-or-bold (arg)
  "Wrap active region or the NEXT word in asterisks.
Strips out any existing asterisks from the text first."
  (interactive "p")
  (if (region-active-p)
      ;; If there's a highlighted region, wrap it
      (let ((s (replace-regexp-in-string
                "[*]" ""
                (delete-and-extract-region (region-beginning)
                                           (region-end)))))
        (insert "*")
        (insert s)
        (insert "*"))
    ;; Otherwise, embolden the NEXT word
    (embolden-next-word)))

(defun embolden-next-word ()
  "Move to the next word, remove any existing asterisks, and wrap in `*...*`."
  ;; 1. Move to the END of the next word
  (forward-word 1)
  (let ((word-end (point)))
    ;; 2. Move back to the START of that word
    (backward-word 1)
    (let ((word-start (point)))
      ;; 3. Grab the text of the word, strip asterisks, then wrap in `*...*`
      (let* ((text (buffer-substring-no-properties word-start word-end))
             (cleaned (replace-regexp-in-string "[*]" "" text)))
        (delete-region word-start word-end)   ;; remove old word
        (insert "*" cleaned "*")))))          ;; insert *word*



#+END_SRC

* color theme advice
#+BEGIN_SRC emacs-lisp
(defun my/apply-extra-faces (&rest _ignore)
  "Tweak a few faces after a new theme becomes active."
  (let ((class '((class color) (min-colors 89))))   ;; keep old spec working
    (custom-set-faces
     '(bold       ((t (:inherit font-lock-warning-face :weight bold))))
     '(org-quote  ((t (:inherit default))))
     ;; '(org-link ((t (:underline nil))))             ; ‚Üê enable if desired
     `(org-done   ((,class (:weight bold
                           :box (:line-width 1 :color "#BBBBBB")
                           :foreground "#BBBBBB" :background "green"))))))
  nil)                                              ;; keep advice chain happy

(advice-add #'load-theme :after #'my/apply-extra-faces)
#+END_SRC


* leader key, doesn't need a special mode
#+BEGIN_SRC emacs-lisp
;; Keybindings moved to keys.el

#+END_SRC


* fix image links
#+BEGIN_EXAMPLE emacs-lisp
(defun fix-image-links ()
(interactive)
(goto-char 1)
(while (search-forward-regexp "[[\(.*?\).jpg][\(.*?\).jpg]]" nil t)
  (replace-match "[[" (match-string 1) ".jpg]]"  t nil))

(while (search-forward-regexp "[[\(.*?\).png][\(.*?\).png]]" nil t)
  (replace-match "[[" (match-string 1) ".png]]"  t nil))
)
#+END_EXAMPLE


* replace missing PDF ligatures
different ‚Üí different

#+BEGIN_SRC emacs-lisp
(defun replace-missing-ligatures ()
"Replace goofy MS and other garbage characters with latin1 equivalents."
(interactive)
(save-excursion				; save the current point

  (replace-string "de cit" "deficit" nil (point-min) (point-max))
  (replace-string "di eren" "differen" nil (point-min) (point-max))
  (replace-string "e ective" "effective" nil (point-min) (point-max))
  (replace-string "de ne" "define" nil (point-min) (point-max))
  (replace-string "re ect" "reflect" nil (point-min) (point-max))
  (replace-string "o er" "offer" nil (point-min) (point-max))
  (replace-string "con den" "confiden" nil (point-min) (point-max))
  (replace-string "con ict" "conflict" nil (point-min) (point-max))
;(replace-string "nd" "find" nil (point-min) (point-max)); whole word only
;(replace-string "ve" "five" nil (point-min) (point-max)); this one should be whole word only
; (replace-string "ve" "they" nil (point-min) (point-max)); this one should be whole word only
; (replace-string "ve" "the" nil (point-min) (point-max)); this one should be whole word only
  (replace-string "scientifc" "scientific" nil (point-min) (point-max))

))
#+END_SRC

* web-mode
#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :defer t
  :hook ((web-mode . rainbow-mode))
  :custom (web-mode-markup-indent-offset 2))
#+END_SRC



* mw-thesaurus
#+BEGIN_SRC emacs-lisp
(use-package mw-thesaurus
  :defer t)
(load "/Users/jay/emacs/emacs-secret/secret-codes.el")
#+END_SRC




* Local Variables & The End
These have to be at the end.

# Local Variables:
# org-config-files-local-mode: t
# enable-local-eval: t
# eval: (org-config-files-local-mode 1)
# End:
