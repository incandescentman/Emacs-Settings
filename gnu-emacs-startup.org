* NOTE-TO-JAY file settings             :ARCHIVE:
#+OPTIONS: f:t
#+ TODO: TODO PLEASE-TEST TESTING PLEASE-DEBUG | DONE
#+TODO: | NOTE-TO-JAY NOTE-TO-RUDI NOTE-TO-RÚDI
#+TODO: PLEASE-CHECK-MY-INEPT-CODE PLEASE-HELP-ME-DEBUG-MY-INEPT-CODE TRY-THIS | DONE

#+TITLE: #+TITLE: Jay Dixit's GNU Emacs setup
#+TITLE: Jay Dixit's GNU Emacs setup
* environment settings
** Handle Emacs UTF-8 input

#+BEGIN_SRC emacs-lisp
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
(setenv "LANG" "en_US.UTF-8")
#+END_SRC

** Sticky windows
#+BEGIN_SRC emacs-lisp
(global-set-key [(control x) (?0)] 'delete-other-windows)
(global-set-key [(control x) (?9)] 'sticky-window-keep-window-visible)
;; (global-set-key  (kbd "s-0") 'delete-window)
(global-set-key  (kbd "s-1") 'delete-other-windows)
(global-set-key  (kbd "s-9") 'sticky-window-keep-window-visible)
(global-set-key  (kbd "s-2") 'split-window-vertically)
; (global-set-key  (kbd "s-3") 'split-window-horizontally)
(global-set-key  (kbd "s-3") 'split-window-left)
#+END_SRC

* abbreviations
Automatically load abbreviations table:
#+BEGIN_SRC emacs-lisp
(setq-default abbrev-mode t)
(read-abbrev-file "/Users/jay/emacs/aquamacs-jay/.abbrev_defs")
(setq abbrev-file-name "/Users/jay/emacs/aquamacs-jay/.abbrev_defs")
(setq save-abbrevs t)
(setq save-abbrevs 'silently)
(setq only-global-abbrevs t)
#+END_SRC

* reflash-indentation
#+BEGIN_SRC emacs-lisp
(defun reflash-indentation ()
  "Fix spacing on the screen."
  (interactive)
  (org-indent-mode 1)
  (recenter-top-bottom)
  (adjust-font-size-for-all-frames)
  )
#+END_SRC

* org predicates
  #+BEGIN_SRC emacs-lisp
(use-package org-element
:defer
  )

  (defun org-checkbox-p ()
  "Predicate: Checks whether the current line org-checkbox"
    (and
;; (org-or-orgalist-p)
      (string-match "^\s*\\([-+*]\\|[0-9]+[.\\)]\\)\s\\[.?\\]\s" (or (thing-at-point 'line) ""))))

  (defun org-plain-text-list-p ()
  "Predicate: Checks whether the current line org-plain-text-list"
    (and
;; (org-or-orgalist-p)
      (string-match "^\s*\\([-+]\\|\s[*]\\|[0-9]+[.\\)]\\)\s" (or (thing-at-point 'line) ""))))
  #+END_SRC

* org-mode hooks
  #+BEGIN_SRC emacs-lisp
(setq org-hierarchical-todo-statistics nil)
  #+END_SRC


* fullscreen settings

[[http://amitp.blogspot.ca/2008/05/emacs-full-screen-on-mac-os-x.html][(Source)]]

#+BEGIN_SRC emacs-lisp
(defvar maxframe-maximized-p nil "maxframe is in fullscreen mode")

(defun toggle-maxframe ()
  "Toggle maximized frame"
  (interactive)
  (setq maxframe-maximized-p (not maxframe-maximized-p))
  (cond (maxframe-maximized-p (maximize-frame))
        (t (restore-frame))))

(define-key global-map [(s-return)] 'toggle-maxframe)
;; make it easy to go fullscreen

(defun toggle-fullscreen ()
 "Toggle full screen"
 (interactive)
 (set-frame-parameter
  nil 'fullscreen
  (when (not (frame-parameter nil 'fullscreen)) 'fullboth))
 (adjust-font-size-for-all-frames))

;; and the keybinding
(unless (fboundp 'toggle-frame-fullscreen)
  (global-set-key (kbd "<f11>") 'toggle-fullscreen))
(unless (fboundp 'toggle-frame-fullscreen)
  (global-set-key (kbd "<f17>") 'toggle-fullscreen))

  (global-set-key (kbd "<f17>") 'toggle-fullscreen)

#+END_SRC


* tabbar
So Emacs text doesn't appear on the MacBook Pro notch.

#+begin_EXAMPLE emacs-lisp
(use-package tab-bar
:defer
 :config
 (tab-bar-mode -1))
 #+END_EXAMPLE


#+begin_SRC emacs-lisp
(defun my-toggle-tab-bar-mode ()
 "Toggle `tab-bar-mode' based on the current frame fullscreen state in order to hide the MacBook Pro notch when in fullscreen mode."
 (if (frame-parameter nil 'fullscreen)
  (tab-bar-mode 1)
 (tab-bar-mode -1)))

(add-hook 'window-configuration-change-hook #'my-toggle-tab-bar-mode)
#+END_SRC


* directory settings

There is probably a lot of redundancy here, I don't understand this stuff too
well.

#+BEGIN_SRC emacs-lisp

;; (use-package dired-details+)



;; (defadvice dired-readin
;;     (after dired-after-updating-hook first () activate)
;;   "Sort dired listings with directories first before adding marks."
;;   (mydired-sort)
;;   (let ((dired-details-internal-overlay-list  ())) (dired-details-hide)))

(defcustom dired-details-hidden-string ""
  "*This string will be shown in place of file details and symbolic links."
  :group 'dired-details
  :type 'string)

(defcustom dired-details-initially-hide t
  "*Hide dired details on entry to dired buffers."
  :group 'dired-details
  :type 'boolean)
#+END_SRC

* other functions

Manually remove the scrollbar if default setting fails when creating a new frame:

#+BEGIN_SRC emacs-lisp
(defun scrollbar-init ()
  (interactive)
  (scroll-bar-mode -1)
  )

(defun scrollbar-mode-turn-off-scrollbar ()
  (interactive)
  (scroll-bar-mode -1)
  )

(defun scrollbar-mode-turn-on-scrollbar ()
  (interactive)
  (scroll-bar-mode 1)
  )
#+END_SRC

Forgot what this does, I think it's in case Emacs crashes maybe to recover
autosaves?
#+BEGIN_SRC emacs-lisp
(defadvice recover-session (around disable-dired-omit-for-recover activate)
  (let ((dired-mode-hook dired-mode-hook))
    (remove-hook 'dired-mode-hook 'enable-dired-omit-mode)
    ad-do-it))
#+END_SRC

* isolate Emacs kill ring from the OSX system pasteboard (clipboard).

Very important, I use this all the time.  These are custom functions to separate
the OSX clipboard from Emacs' kill ring, effectively giving me two separate
clipboards to work from. The below are the traditional OSX keybindings for
cut/copy/paste, and they will now work with the OSX clipboard. The yank and pop functions still work, and use the Emacs kill ring instead.


** pasteboard setup
#+BEGIN_SRC emacs-lisp
(setq interprogram-cut-function nil)
(setq interprogram-paste-function nil)
#+END_SRC

** pasteboard-copy
#+BEGIN_SRC emacs-lisp
(defun pasteboard-copy ()
  "Copy region to OS X system pasteboard."
  (interactive)
  (let* ((txt (buffer-substring (region-beginning) (region-end))))
    (shell-command-to-string
     (format "echo -n %s | pbcopy" (shell-quote-argument txt)))))
#+END_SRC

** pasteboard-copy-and-convert-to-markdown-link
#+BEGIN_SRC emacs-lisp
(defun pasteboard-copy-and-convert-to-markdown-link ()
  "Copy region to OS X system pasteboard."
  (interactive)
  (let* ((txt (buffer-substring (region-beginning) (region-end)))
         (txt-updated-links
          (replace-regexp-in-string
           "\\[\\[\\([^]]*\\)\\]\\(\\[\\([^]]*\\)\\]\\)?\\]"
           (lambda (m)
             (concat "[" (or (match-string 3 m)
                             (match-string 1 m))
                     "](" (match-string 1 m) ")"))
           txt)))
;; (message "Copied: %s" txt-updated-links)
    (shell-command-to-string
     (format "echo -n %s | pbcopy" (shell-quote-argument txt-updated-links)))))
#+END_SRC

** pasteboard-paste

*** pasteboard-paste (with smart quotes by default)
#+BEGIN_SRC emacs-lisp
(defun pasteboard-paste-and-convert-markdown-links-to-org-mode ()
  "Paste from OS X system pasteboard via `pbpaste' to point."
  (interactive)
  (let ((start (point))
        (end (if mark-active
                 (mark)
               (point)))
        (ins-text
         (replace-regexp-in-string
          "\\[\\([^][]*\\)\\](\\([^)]*\\))"
          (lambda (m)
            (let ((m1 (match-string 1 m))
                  (m2 (match-string 2 m)))
              (if (string= m1 m2)
                  (concat "[[" m1 "]]")
                (concat "[[" m2 "][" m1 "]]"))))
          (shell-command-to-string "pbpaste | perl -p -e 's/\r$//' | tr '\r' '\n'"))))
    (delete-region start end)
    (insert ins-text)
    (my/fix-space)
    (save-excursion
      (goto-char start)
      (my/fix-space)))
                                        ; (reflash-indentation)
  )

(defun pasteboard-paste ()
  "Paste from OS X system pasteboard via `pbpaste' to point."
  (interactive)
  (let ((start (point))
        (end (if mark-active
                 (mark)
               (point)))
        (ins-text
         (shell-command-to-string "pbpaste | perl -p -e 's/\r$//' | tr '\r' '\n'")))
    (delete-region start end)
    (insert ins-text)
    (my/fix-space)
    (save-excursion
      (goto-char start)
      (my/fix-space)))
                                        ; (reflash-indentation)
  )
#+END_SRC

*** pasteboard-paste-without-smart-quotes (and without spaces)
#+BEGIN_SRC emacs-lisp
(defun pasteboard-paste-without-smart-quotes ()
  (interactive)
  (let ((beg (point)))
    (pasteboard-paste)
    (replace-smart-quotes beg (point))))


(defun pasteboard-paste-without-smart-quotes ()
 (interactive)
 (let ((beg (point)))
  (pasteboard-paste) ; Paste the content from the clipboard.
  (replace-smart-quotes beg (point)) ; Replace smart quotes in the pasted content.
  (remove-redundant-asterisks-in-org-headings))) ; Clean up org-mode headings in the pasted content.


#+END_SRC

*** pasteboard-paste-spaces-maybe
    #+BEGIN_SRC emacs-lisp
(defun pasteboard-paste-spaces-maybe ()
(interactive)
;; begin if
(if
(or
(looking-back "'")
(looking-back ":")
(looking-at "'")
(looking-back "(")
(looking-back "'")
(looking-at ")")
(looking-at "|")
(looking-back "|")
(looking-back "\\[")
(looking-at "\\]")
(looking-at "\\/")
(looking-at "\\\\")
(looking-back "\\\\")
(looking-back "/")
(looking-back "\"")
(looking-at "\"")
(looking-back "\"")
(looking-back "=")
(looking-at "<")
(looking-back "<")
(looking-at "<")
(looking-back ">")
(looking-at "{")
(looking-back "{")
(looking-at "}")
(looking-back "}")
)
;; end if

    (pasteboard-paste-no-spaces) ; then
  (pasteboard-paste-without-smart-quotes))   ; else
  )
    #+END_SRC

*** pasteboard-paste-no-spaces - original working version
#+BEGIN_SRC emacs-lisp
(defun pasteboard-paste-no-spaces ()
  "Paste from OS X system pasteboard via `pbpaste' to point."
  (interactive)
  (let ((start (point))
	(end (if mark-active
		 (mark)
	       (point))))
    (shell-command-on-region start end
			     "pbpaste | perl -p -e 's/\r$//' | tr '\r' '\n'"
			     nil t)
    (save-excursion
      )))
#+END_SRC

** pasteboard-cut

#+BEGIN_SRC emacs-lisp
(defun pasteboard-cut ()
  "Cut region and put on OS X system pasteboard."
  (interactive)
  (pasteboard-copy)
  (delete-region (region-beginning) (region-end))
  (my/fix-space)
  )

(defun pasteboard-cut-and-capitalize ()
  "Cut region and put on OS X system pasteboard."
  (interactive)
  (pasteboard-copy)
  (delete-region (region-beginning) (region-end))
  (my/fix-space)
  (save-excursion
    (when (my/beginning-of-sentence-p)
      (capitalize-unless-org-heading))))
#+END_SRC

** wrapped-search-forward
#+BEGIN_SRC emacs-lisp

(defvar-local failed-search nil)

(defun wrapped-search-forward (str)
  (interactive "sWrappedSearch:")
  (if (and
       failed-search
       (>= (car failed-search) (point))
       (string-equal (cdr failed-search) str))
      (let ((p (save-excursion
                 (goto-char 0)
                 (search-forward str nil t))))
        (if p
            (progn
              (goto-char p)
              (setq-local failed-search nil))
          (message "WrappedSearch: Not found.")))
    (let ((p (search-forward str nil t)))
      (unless p
        (setq-local failed-search (cons (point) str))
        (message "Search: Not found.")))))

#+END_SRC
** pasteboard-search-for-clipboard-contents
#+BEGIN_SRC emacs-lisp
(defun pasteboard-search-for-clipboard-contents ()
  (interactive)
  (let ((search-term
         (with-temp-buffer
           (pasteboard-paste-no-spaces)
           (buffer-string))))
    (wrapped-search-forward search-term)))

#+END_SRC

* kill ring to pasteboard functions
** push kill ring to OSX pasteboard
  #+BEGIN_SRC emacs-lisp
(setq x-select-enable-clipboard t)

(defun push-kill-ring-pasteboard-to-clipboard ()
  (interactive)
  (x-select-text (current-kill 0)))
  #+END_SRC

** gist-buffer-to-pasteboard
  #+BEGIN_SRC emacs-lisp
(defun gist-buffer-to-pasteboard ()
  (interactive)
  (gist-buffer)
  (push-kill-ring-pasteboard-to-clipboard)
  )
  #+END_SRC

* keybindings

** Create custom keybinding prefix

#+BEGIN_QUOTE
I have an unconventional approach to this that I recommend highly. I have redefined the C-l ('ell') key to be a prefix key, and I use that to prefix my favorite commands. This key is very easy to type and it is bound to a function ('recenter) that isn't used that much. Well, I don't use 'recenter much, but even if you did, it can be assigned to C-l C-l which is almost as easy to type, and a small price to pay for the possibilities opened up by the Ctrl-L-map. (Actually I prefer 'redraw-display to 'recenter, so I gave that the place of honor.)
#+END_QUOTE
Source: [[http://stackoverflow.com/questions/5682631/what-are-good-custom-keybindings-kn-emacs/5682737#5682737][ LenW's answer on keyboard - What are good custom keybindings in emacs? - Stack Overflow]]

Use ⌘-m as prefix for my own custom keybindings:
#+BEGIN_SRC emacs-lisp

;; (global-set-key (kbd "s-k") nil)
(global-unset-key (kbd "s-k"))

(define-key evil-normal-state-map (kbd "s-k") nil)
  (global-unset-key (kbd "s-k"))
  (defvar s-k-map (make-keymap)
    "Keymap for local bindings and functions, prefixed by (Command-M)")
  (define-key global-map (kbd "s-k") 's-k-prefix)
  (fset 's-k-prefix s-k-map)
#+END_SRC


* Custom Key Bindings

** NOTE-TO-JAY TODO Custom keybindings

Eventually replace these with this? https://github.com/noctuid/general.el



#+BEGIN_SRC emacs-lisp
;; create a custom minor mode to override other keybindings and use mine instead
(defvar key-minor-mode-map (make-sparse-keymap) "key-minor-mode keymap.")
(define-minor-mode key-minor-mode
  "A minor mode so that my key settings override annoying major modes."
  :init-value t
  :lighter " key"
  :keymap key-minor-mode-map)
(key-minor-mode 1)


(defun my-minibuffer-setup-hook ()
  (key-minor-mode 0))
(add-hook 'minibuffer-setup-hook 'my-minibuffer-setup-hook)



;; and the keybindings
;; mk - mykeybindings


(defun setup-org-mode-keys ()
 (define-key org-mode-map (kbd "<return>") 'smart-return))

;; Setup Org mode specific keys
(add-hook 'org-mode-hook 'setup-org-mode-keys)

;; learn this key binding!!!
(define-key key-minor-mode-map (kbd "M-s-d") 'counsel-find-file)

(define-key key-minor-mode-map (kbd "C-<tab>") 'org-cycle-force-archived)

(define-key key-minor-mode-map (kbd "s-k o l") 'olivetti-mode)

(define-key key-minor-mode-map (kbd "s-I") 'clone-indirect-buffer-new-window-and-focus)


(define-key key-minor-mode-map (kbd "s-k o t") 'org-timeline-export-to-html-and-open)


(define-key key-minor-mode-map (kbd "s-k e b") 'ediff-buffers)


;; (define-key key-minor-mode-map (kbd "C-S-<left>") 'org-outdent-item-tree)
;; (define-key key-minor-mode-map (kbd "C-S-<right>") 'org-indent-item-tree)


(define-key key-minor-mode-map (kbd "C-S-<left>") 'org-outdent-or-promote)
(define-key key-minor-mode-map (kbd "C-S-<right>") 'org-indent-or-demote)


(define-key key-minor-mode-map (kbd "s-k a f") 'org-attach)

(define-key key-minor-mode-map (kbd "M-/") 'completion-at-point)

(define-key key-minor-mode-map (kbd "M-1") 'winum-select-window-1)
(define-key key-minor-mode-map (kbd "M-2") 'winum-select-window-2)
(define-key key-minor-mode-map (kbd "M-3") 'winum-select-window-3)
(define-key key-minor-mode-map (kbd "C-M-3") 'number-region)


(define-key key-minor-mode-map [mouse-2] 'context-menu-open)


(bind-key "C-c <mouse-3>" 'right-click-context-menu)
(define-key key-minor-mode-map (kbd "M-j") 'aide-openai-complete-buffer-insert)

(define-key key-minor-mode-map (kbd "C-c C-x C-r") 'org-clock-report)

(define-key key-minor-mode-map (kbd "s-k r t") 'org-render-table-at-point)

(define-key key-minor-mode-map (kbd "s-k m c") 'multiple-cursors-reflash)

;; (define-key key-minor-mode-map (kbd "s-J") 'dired-jump)

(define-key key-minor-mode-map (kbd "s-k r l") 'remove-link)

(define-key key-minor-mode-map (kbd "s-k n s") 'yas/new-snippet)
;; (define-key key-minor-mode-map (kbd "s-k n") 'yas/new-snippet)

(define-key help-mode-map (kbd "C-s-]") 'help-go-back)
(define-key key-minor-mode-map (kbd "C-s-]") 'help-go-forward)



(define-key key-minor-mode-map (kbd "s-k c m") 'css-mode)
;; (define-key css-mode-map (kbd "s-k c s") 'css-mode)
(define-key key-minor-mode-map (kbd "s-k s h") 'sh-mode)
(define-key key-minor-mode-map (kbd "s-k s m") 'sh-mode)

(define-key key-minor-mode-map (kbd "s-K") 'org-cut-subtree)
(define-key key-minor-mode-map (kbd "s-k RET") 'kill-current-buffer)

;; (define-key key-minor-mode-map (kbd "s-k") 'avy-goto-char)
;; (define-key key-minor-mode-map (kbd "s-p") 'org-html-export-to-html-and-open)


;; (define-key key-minor-mode-map (kbd "M-y") 'helm-show-kill-ring)

(define-key key-minor-mode-map (kbd "M-h M-k") 'describe-key)

(define-key key-minor-mode-map (kbd "M-s-m") 'visit-messages-buffer)

(defun visit-messages-buffer ()
(interactive)
()
  (interactive)
  (view-echo-area-messages)
(other-window 1)
)



(defun visit-messages-buffer-full-screen ()
  (interactive)
  (with-current-buffer (messages-buffer)
  (goto-char (point-max))
  (switch-to-buffer (current-buffer)))
  )

(define-key key-minor-mode-map (kbd "<s-backspace>") 'kill-region)

(define-key key-minor-mode-map (kbd "C-\\") 'palimpsest-move-region-to-bottom)
;; TODO learn this key binding!!

(define-key key-minor-mode-map (kbd "s-k t c") 'org-table-create)

(define-key key-minor-mode-map (kbd "C-;") 'org-def)

(define-key flyspell-mode-map (kbd "C-;") 'org-def)

(define-key key-minor-mode-map (kbd "s-k u p") 'unfill-paragraph)

(define-key key-minor-mode-map (kbd "C-w") 'copy-region-as-kill-and-push-to-clipboard)

;; (define-key key-minor-mode-map (kbd "=") 'insert-equals-sign)



(define-key key-minor-mode-map (kbd "C-M-/") 'hippie-expand)

(define-key key-minor-mode-map (kbd "s-k w m") 'whitespace-mode)

(define-key key-minor-mode-map (kbd "s-k h l") 'spacemacs/toggle-highlight-current-line-globally-off)

(define-key key-minor-mode-map (kbd "s-k r b") 'revert-buffer)

(define-key key-minor-mode-map (kbd "s-k s b") 'scrollbar-mode-turn-off-scrollbar)

(define-key key-minor-mode-map (kbd "s-i") 'imenu)
(define-key key-minor-mode-map (kbd "s-k i l") 'imenu-list)
(define-key key-minor-mode-map (kbd "s-k i m") 'imenu-list)

(define-key key-minor-mode-map (kbd "s-k g t") 'google-translate-at-point)

(define-key key-minor-mode-map (kbd "M-?") 'insert-question-mark)


;; (define-key key-minor-mode-map (kbd "<s-S-down>") 'scratch)


(define-key key-minor-mode-map (kbd "s-k ag") 'affe-grep)

(define-key key-minor-mode-map (kbd "s-k t t") 'toggle-between-src-and-example-block)

;; working with an external monitor
(define-key key-minor-mode-map (kbd "s-n") 'make-frame)
;; (define-key key-minor-mode-map (kbd "s-~") 'other-frame)


(define-key key-minor-mode-map (kbd "s-`") 'other-window-or-frame)


(define-key key-minor-mode-map (kbd "C-x C-d") 'dired)

(define-key key-minor-mode-map (kbd "s-k c p") 'path-copy-path-to-kill-ring)


(define-key org-mode-map (kbd "s-k c s") 'org-clone-subtree)
(define-key key-minor-mode-map (kbd "s-k v") 'org-paste-subtree)
(define-key key-minor-mode-map (kbd "s-k x") 'org-cut-subtree)
(define-key key-minor-mode-map (kbd "s->") 'org-mark-subtree)
(define-key key-minor-mode-map (kbd "M-'") 'insert-one-double-quote)
(define-key key-minor-mode-map (kbd "M-s-.") 'mark-paragraph)

(define-key key-minor-mode-map (kbd "M-_") 'em-dash)

(define-key key-minor-mode-map (kbd "C-v") 'html2org-clipboard)


(define-key key-minor-mode-map (kbd "s-r") 'counsel-recentf)

(define-key key-minor-mode-map (kbd "M-.") 'insert-period)
(define-key key-minor-mode-map (kbd "M-,") 'insert-comma)


(define-key key-minor-mode-map (kbd "s-k g b") 'gist-buffer-to-pasteboard)

;; (define-key key-minor-mode-map (kbd "<M-s-up>") 'scroll-down-command)
;; (define-key key-minor-mode-map (kbd "<M-s-down>") 'scroll-up-command)


(define-key key-minor-mode-map (kbd "M-s b") 'book-search)
(define-key key-minor-mode-map (kbd "M-s c") 'current-buffers-search)


(define-key key-minor-mode-map (kbd "s-k o m") 'org-mode)
(define-key key-minor-mode-map (kbd "s-k f m") 'text-mode)
(define-key key-minor-mode-map (kbd "s-k e l") 'emacs-lisp-mode)


(define-key key-minor-mode-map (kbd "s-k w c") 'wc-mode)
(define-key key-minor-mode-map (kbd "s-k o c") 'org-wc-count-subtrees)
(define-key key-minor-mode-map (kbd "s-k o c") 'org-wc-display)

(global-set-key (kbd "C-c m") 'compose-mail)
;; (global-set-key (kbd "C-c m") 'yale-or-vivovii-compose)


(define-key key-minor-mode-map (kbd "s-k m b") 'menu-bar-mode)

(define-key key-minor-mode-map (kbd "s-k d c") 'org-table-delete-column)
(define-key key-minor-mode-map (kbd "s-k i c") 'org-table-insert-column)
(define-key key-minor-mode-map (kbd "s-k i r") 'org-table-insert-row)



;; don't know why this stopped working
(define-key key-minor-mode-map (kbd "C-c C-x <C-i>") 'org-clock-in)
(define-key key-minor-mode-map (kbd "C-c C-x <C-i>") 'org-clock-in)



(define-key key-minor-mode-map (kbd "s-k f z") 'counsel-fzf)

(define-key key-minor-mode-map (kbd "M-s-=") 'calc-eval-region)

(define-key key-minor-mode-map (kbd "s-k p m") 'poetry-mode)

;; (define-key key-minor-mode-map (kbd "s-p") 'zin/org-checkbox-next)

(define-key key-minor-mode-map (kbd "<f20>") 'pomodoro-start)
(define-key key-minor-mode-map (kbd "s-k p s") 'pomodoro-start)



(define-key key-minor-mode-map (kbd "<C-s-left>") 'work-on-book)



(define-key key-minor-mode-map (kbd "s-k t d") 'org-todo-list)
(define-key key-minor-mode-map (kbd "s-k o a") 'org-agenda)
(define-key key-minor-mode-map (kbd "s->") 'org-cycle-agenda-files)

(define-key key-minor-mode-map (kbd "s-k c i") 'jd-clock-in)



;; (define-key key-minor-mode-map (kbd "s-.") 'org-select-line)
;; (define-key key-minor-mode-map (kbd "C-.") 'searchlink)



(define-key key-minor-mode-map (kbd "M-0") 'copy-region-to-other-window)


(define-key key-minor-mode-map (kbd "s-b") 'narrow-or-widen-dwim)

(define-key key-minor-mode-map (kbd "C-x C-d") 'consult-dir)




;; (define-key key-minor-mode-map (kbd "C-x <return> RET") 'mc/mark-all-dwim)

;; (define-key key-minor-mode-map (kbd "s-H") 'hyperbole)

(define-key key-minor-mode-map (kbd "M-e") 'smart-forward-sentence)

(define-key key-minor-mode-map (kbd "M-q") 'prelude-switch-to-previous-buffer)



(define-key key-minor-mode-map (kbd "M-]") 'org-next-visible-heading)
(define-key key-minor-mode-map (kbd "M-[") 'org-previous-visible-heading)


(define-key key-minor-mode-map (kbd "C-M-]") 'org-next-subtree-and-narrow)
(define-key key-minor-mode-map (kbd "C-M-[") 'org-previous-subtree-and-narrow)

(define-key key-minor-mode-map (kbd "C-]") 'org-next-subtree-same-level-and-narrow)

(define-key key-minor-mode-map (kbd "ESC ESC") 'org-previous-subtree-same-level-and-narrow)


(define-key key-minor-mode-map (kbd "s-k w s") 'isearch-forward-word)

(define-key key-minor-mode-map (kbd "C-s") 'consult-line)

(define-key key-minor-mode-map (kbd "s-f") 'isearch-forward-ignore-case)


(define-key key-minor-mode-map (kbd "s-F") 'pasteboard-search-for-clipboard-contents)

(define-key key-minor-mode-map (kbd "M-\"") 'open-abbrevs)

(define-key key-minor-mode-map (kbd "s-|") 'path-copy-path-to-clipboard)
(define-key key-minor-mode-map (kbd "<s-return>") 'toggle-fullscreen)

(global-set-key (kbd "s-v") 'pasteboard-paste-no-spaces)
(define-key org-mode-map (kbd "s-v") 'pasteboard-paste-spaces-maybe)
(define-key text-mode-map (kbd "s-v") 'pasteboard-paste-without-smart-quotes)
(define-key emacs-lisp-mode-map (kbd "s-v") 'pasteboard-paste-no-spaces)
(define-key key-minor-mode-map (kbd "C-s-v") 'html2org-clipboard)
(define-key key-minor-mode-map (kbd "C-s-c") 'ox-clip-formatted-copy)
(define-key key-minor-mode-map (kbd "s-x") 'pasteboard-cut-and-capitalize)
(define-key key-minor-mode-map (kbd "s-c") 'pasteboard-copy)
(define-key key-minor-mode-map (kbd "s-V") 'pasteboard-paste-no-spaces)


(define-key emacs-lisp-mode-map (kbd "s-v") 'pasteboard-paste-no-spaces)

(define-key key-minor-mode-map (kbd "s-h") 'replace-string)

(global-unset-key (kbd "C-S-r"))
(define-key key-minor-mode-map (kbd "C-S-r") nil)
(define-key org-mode-map (kbd "C-S-r") nil)




(define-key key-minor-mode-map (kbd "C-s-o") 'dired-jump)

;; (define-key org-mode-map (kbd "s-O") 'uo-byword-file)




;; pop mark
(define-key key-minor-mode-map (kbd "C-x p")'pop-to-mark-command)

;; projectile
;; (define-key key-minor-mode-map (kbd "s-P") 'projectile-commander)

(define-key key-minor-mode-map (kbd "s-E") 'new-email-from-subtree-no-signature)

;; and make it work in the minibuffer too
(define-key minibuffer-local-map (kbd "s-v") 'pasteboard-paste-no-spaces)
(define-key minibuffer-local-map (kbd "s-x") 'pasteboard-cut)
(define-key minibuffer-local-map (kbd "s-c") 'copy-minibuffer-contents)
(define-key minibuffer-local-map (kbd "s-a") 'copy-minibuffer-contents)

(defun copy-minibuffer-contents (arg)
  (interactive "p")
  (beginning-of-visual-line)
  (end-of-buffer)
  (copy-region-as-kill (mark) (point))
  (push-kill-ring-pasteboard-to-clipboard)
  )




(define-key key-minor-mode-map (kbd "C-c C-v") 'refile-region)

(define-key key-minor-mode-map (kbd "s-0") 'move-region-to-other-window)
;; (define-key org-mode-map (kbd "s-o") 'move-region-to-other-window) ; very useful when working with a split frame

(define-key key-minor-mode-map (kbd "s-o") 'move-or-copy-region-to-other-window)
(define-key key-minor-mode-map (kbd "s-O") 'reveal-in-finder)


(define-key emacs-lisp-mode-map (kbd "C-c e") 'eval-buffer)
(define-key org-mode-map (kbd "C-c e") 'eval-subtree)

(define-key key-minor-mode-map (kbd "C-c r") 'eval-region)


(define-key key-minor-mode-map (kbd "C-9") 'goto-last-change-reverse) ; super useful when editing
(define-key key-minor-mode-map (kbd "C--") 'goto-last-change) ; super useful when editing


(define-key key-minor-mode-map (kbd "M-=") 'er/expand-region)
(define-key key-minor-mode-map (kbd "C-=") 'er/expand-region)


;; (define-key key-minor-mode-map (kbd "C-8") #'(lambda (arg) (interactive "p") (wrap-region-trigger arg "*"))) ; wow this was a stroke of genius

(define-key key-minor-mode-map (kbd "s-k r e") 'set-rectangular-region-anchor)

(define-key key-minor-mode-map (kbd "C-d") 'kill-word-correctly-and-capitalize)
;; (define-key key-minor-mode-map (kbd "m-d") 'kill-word-correctly-and-capitalize)
(define-key key-minor-mode-map (kbd "M-d") 'org-todo)

(define-key key-minor-mode-map (kbd "M-s-9") 'org-todo)

;; (define-key key-minor-mode-map (kbd "m-D") 'org-shiftleft)

(define-key key-minor-mode-map (kbd "C-l") 'reflash-indentation)
;; (define-key org-mode-map (kbd "C-l") 'reflash-indentation)

(define-key key-minor-mode-map (kbd "s-e") 'embark-act)


(define-key key-minor-mode-map (kbd "=") 'smex) ; call any function with easiest keystroke possible
;; (define-key key-minor-mode-map (kbd "=") 'counsel-M-x) ; call any function with easiest keystroke possible


(global-set-key (kbd "C-s") 'consult-line) ;; instead of swiper
;; Source: [[https://macowners.club/posts/from-ivy-to-vertico/][From Ivy & Counsel to Vertico & Consult | macOS & (open-source) Software]]

;; (define-key key-minor-mode-map (kbd "M-x") 'helm-M-x) ; call helm-M-x instead of regular M-x
;; (define-key key-minor-mode-map (kbd "\|") 'deft)

(define-key org-mode-map (kbd "M-K") 'kill-sentence-maybe-else-kill-line)
(define-key emacs-lisp-mode-map (kbd "M-K") 'kill-sexp)

(define-key key-minor-mode-map (kbd "C-M-8") 'org-toggle-heading) ; i.e. subheading


(define-key key-minor-mode-map (kbd "M-8") 'org-toggle-heading-same-level)
(define-key key-minor-mode-map (kbd "M-*") 'org-toggle-todo-heading)
;; (define-key key-minor-mode-map (kbd "C-M-*") 'org-toggle-todo-subheading)


(define-key key-minor-mode-map (kbd "M-t") 'titlecase-dwim)

(define-key key-minor-mode-map (kbd "M--") 'cycle-hyphenation-or-toggle-item)

;; (define-key key-minor-mode-map (kbd "S-s-<up>") 'later-list)

(define-key key-minor-mode-map (kbd "M-a") 'org-priority-up)

(define-key key-minor-mode-map (kbd "C-c C-x p p") 'pomodoro-start)

(define-key key-minor-mode-map (kbd "s-<") 'load-shared-functions)
(define-key key-minor-mode-map (kbd "s->") 'load-gnu-startup)
(define-key key-minor-mode-map (kbd "s-.") 'consult-outline)
(define-key key-minor-mode-map (kbd "s-'") 'choose-refile-method-and-refile)


;; (define-key key-minor-mode-map (kbd "C-c j") 'helm-org-headlines) ; also bound to keychord jj
;; helm-mini) ; shows recent files; also bound to ⌘-r
(define-key key-minor-mode-map (kbd "M-b M-d") 'book-dired) ; show directory of my book folder
(define-key key-minor-mode-map (kbd "M-b r") 'read-a-book) ; show directory of my PDF books
(define-key key-minor-mode-map (kbd "M-b j") 'read-jd) ; show PDF books I have annotated
(define-key key-minor-mode-map (kbd "M-b M-b") 'work-on-book) ;

(define-key key-minor-mode-map (kbd "M-b M-w") 'work-on-book) ;

(define-key key-minor-mode-map (kbd "M-b lc") 'book-load-current) ;

;; (define-key key-minor-mode-map (kbd "M-b ho") 'spacemacs/toggle-highlight-current-line-globally)


;; book bindings
(define-key key-minor-mode-map (kbd "M-b M-p") 'book-proposal-directory)
(define-key key-minor-mode-map (kbd "M-b M-m") 'book-mistakes-directory)


(define-key key-minor-mode-map (kbd "s-k o l") 'olivetti-mode)
(define-key key-minor-mode-map (kbd "] ol") 'olivetti-mode)
(define-key key-minor-mode-map (kbd "s-k o e") 'olivetti-expand)
(define-key key-minor-mode-map (kbd "s-+") 'copy-region-to-other-window)
(define-key key-minor-mode-map (kbd "s-_") 'olivetti-shrink)

(define-key org-mode-map (kbd "s-l") 'org-insert-link)

(define-key key-minor-mode-map (kbd "s-B") 'consult-buffer)

(define-key key-minor-mode-map (kbd "s-T") 'mw-thesaurus-lookup-dwim)
(define-key key-minor-mode-map (kbd "s-D") 'define-word-at-point)

;; For extracting content from my browser

(define-key key-minor-mode-map (kbd "s-W") 'open-weeklies)
;; (define-key key-minor-mode-map (kbd "s-V") 'html2org-clipboard) ; paste HTML content that I've copied from the web, automatically converting to proper org-mode syntax

(define-key key-minor-mode-map (kbd "C-s-\\") 'source-current-file)

;; and the keybinding
(define-key org-mode-map (kbd "C-k") 'my/kill-line-dwim)
(define-key key-minor-mode-map (kbd "C-k") 'my/kill-line-dwim)

;; use OSX standard keybindings ⌘-up and ⌘-down to go to top or bottom of buffer
(define-key key-minor-mode-map [s-up] 'beginning-of-buffer)
(define-key key-minor-mode-map [s-down] 'end-of-buffer)

(define-key key-minor-mode-map (kbd "S-s-SPC") 'set-mark-command)

;; mark commands
(define-key key-minor-mode-map (kbd "C-M-SPC") 'set-mark-command)
(define-key key-minor-mode-map (kbd "C-M-x") 'exchange-point-and-mark)


;; (define-key key-minor-mode-map (kbd "C-s-SPC") 'helm-all-mark-rings)

; (define-key key-minor-mode-map (kbd "s-+") 'set-mark-command)

;; (define-key key-minor-mode-map (kbd "s-_") 'avy-pop-mark)

;; use OSX standard keybinding for "Redo"
(define-key key-minor-mode-map (kbd "s-z") 'undo-fu-only-undo)
(define-key key-minor-mode-map (kbd "s-y") 'undo-fu-only-redo-fail-silently)
(define-key key-minor-mode-map (kbd "s-y") 'undo-fu-only-redo-fail-with-heart)

;; use OSX standard keybinding to increase or decrease font size
;; (define-key key-minor-mode-map (kbd "s-=") 'text-scale-increase)
;; (define-key key-minor-mode-map (kbd "s--") 'text-scale-decrease)

(define-key key-minor-mode-map (kbd "s-=") 'embiggen-text)
(define-key key-minor-mode-map (kbd "s--") 'ensmallen-text)


;; rebind global help command so that I can use C-h for backspace
(define-key key-minor-mode-map (kbd "M-h") 'help-command)

;; very useful when encountering names and other unfamiliar words
(define-key key-minor-mode-map (kbd "M-+") 'add-word-to-personal-dictionary)

(define-key key-minor-mode-map (kbd "s-k s w") 'crux-swap-windows)

(define-key key-minor-mode-map (kbd "s-k l a") 'jay-load-latex)
(define-key key-minor-mode-map (kbd "s-k l t") 'jay-load-latex)
(define-key key-minor-mode-map (kbd "s-k k a") 'load-koma-letter)
(define-key key-minor-mode-map (kbd "s-k k o") 'load-koma-letter)

(define-key key-minor-mode-map (kbd "M-s-v") 'html2org-clipboard)


;; navigate between buffers, including uninteresting ones that are hidden by default
(define-key key-minor-mode-map (kbd "M-s-<right>") 'switch-to-next-buffer)
(define-key key-minor-mode-map (kbd "M-s-<left>") 'previous-buffer)

;; deleting things
;; (define-key key-minor-mode-map (kbd "<backspace>") 'my/delete-backward)
(define-key key-minor-mode-map (kbd "<backspace>") 'my/delete-backward-and-capitalize)

;; a keybinding for "delete" in addition to "backspace"
(define-key key-minor-mode-map (kbd "C-<backspace>") 'delete-char)
(define-key key-minor-mode-map (kbd "M-<backspace>") 'backward-kill-word-correctly-and-capitalize)

;; pomodoro
(define-key key-minor-mode-map (kbd "C-c C-x pi") 'pomodoro-start)
(define-key key-minor-mode-map (kbd "C-c C-x po") 'pomodoro-stop)

;; find files using helm
;; (define-key key-minor-mode-map (kbd "C-x C-f") 'helm-find-files)

;; search using helm-swoop
;(global-set-key (kbd "M-I") 'helm-swoop-back-to-last-point)
;(global-set-key (kbd "C-c M-i") 'helm-multi-swoop)
;(global-set-key (kbd "C-x M-i") 'helm-multi-swoop-all)
;(global-set-key (kbd "M-i") 'helm-multi-swoop-all)

;; edit Emacs preferences using standard OSX keybinding for preferences
(define-key key-minor-mode-map (kbd "s-,") 'customize-group)


(define-key key-minor-mode-map (kbd "s-g") 'isearch-repeat-forward)
(define-key key-minor-mode-map (kbd "C-s-g ") 'consult-ripgrep-current-directory)
(define-key key-minor-mode-map (kbd "s-G") 'counsel-projectile-ag)

(define-key org-mode-map (kbd "C-c C-s") 'org-schedule)
(define-key key-minor-mode-map (kbd "C-c C-s") 'org-schedule)
(define-key key-minor-mode-map (kbd "s-k o s") 'org-schedule)
(define-key key-minor-mode-map (kbd "s-k o d") 'org-deadline)

(define-key key-minor-mode-map (kbd "s-k t s") 'org-toggle-time-stamp-overlays)

(define-key key-minor-mode-map (kbd "M-x") 'execute-extended-command) ; call helm-M-x instead of regular M-x

;; ag, using current folder as default
;; (define-key key-minor-mode-map (kbd "C-u s-g") 'helm-ag)
;; does that keyvinding work?

;; some custom functions

(define-key key-minor-mode-map (kbd "C-c v i") 'org-insert-src-block)


(define-key key-minor-mode-map (kbd "s-h") 'replace-string)


(define-key key-minor-mode-map (kbd "s-m") 'mc/mark-all-like-this)
(define-key key-minor-mode-map (kbd "s-M") 'tr-toggle-transclusion)


(define-key key-minor-mode-map (kbd "s-\\") 'visit-most-recent-file)

(define-key key-minor-mode-map (kbd "s-F") 'pasteboard-search-for-clipboard-contents)
(define-key key-minor-mode-map (kbd "s-R") 'fasd-find-file)
(define-key key-minor-mode-map (kbd "s-t") 'new-buffer)

(define-key key-minor-mode-map (kbd "s-g") 'isearch-repeat-forward)
(define-key key-minor-mode-map (kbd "s-k e e") 'fasd-find-file)

(define-key key-minor-mode-map (kbd "s-d") 'org-todo)
(define-key key-minor-mode-map (kbd "s-L") 'org-mac-link-chrome-insert-frontmost-url)
(define-key key-minor-mode-map (kbd "s-S") 'org-mac-link-skim-insert)
(define-key key-minor-mode-map (kbd "s-a") 'mark-whole-buffer) ; select all
(define-key key-minor-mode-map (kbd "s-w") 'delete-window) ; close
(define-key key-minor-mode-map (kbd "s-s") 'jay/save-some-buffers ) ; save all

(define-key key-minor-mode-map (kbd "C-s-r") 'consult-find)
#+END_SRC

** available key bindings
#+begin_src emacs-lisp
;; (define-key key-minor-mode-map (kbd "s-A") 'available)
;; Define the available key bindings
;; (define-key key-minor-mode-map (kbd "s-H") 'available) ;; ⌘-H
;; (define-key key-minor-mode-map (kbd "s-n") 'available) ;; ⌘-n
;; (define-key key-minor-mode-map (kbd "s-N") 'available) ;; ⌘-N
;; (define-key key-minor-mode-map (kbd "s-P") 'available) ;; ⌘-P
;; (define-key key-minor-mode-map (kbd "s-U") 'available) ;; ⌘-U
;; (define-key key-minor-mode-map (kbd "s-X") 'available) ;; ⌘-X
;; (define-key key-minor-mode-map (kbd "s-Y") 'available) ;; ⌘-Y
;; (define-key key-minor-mode-map (kbd "s-.") 'available) ;; s-.
;; (define-key key-minor-mode-map (kbd "s-:") 'available) ;; s-:
;; (define-key key-minor-mode-map (kbd "C-\\") 'available) ;; C-\

;; available
;; (define-key key-minor-mode-map (kbd "C-\") 'available)
;;(define-key key-minor-mode-map (kbd "s-:") 'consult-outline)


#+end_src

** OSX ⌘ key bindings
Recognize the ⌘ key in both GNU Emacs and Aquamacs as hyper key:
#+BEGIN_SRC emacs-lisp
(defvar gnuemacs-flag (string-match "GNU" (emacs-version)))
(defvar aquamacs-flag (string-match "Aquamacs" (emacs-version)))

(defun define-super-key (key fun)
 (cond
 (gnuemacs-flag
 (define-key key-minor-mode-map (kbd (concat "s-" key)) fun))))
#+END_SRC

*** mksuper - shared Aquamacs / GNU Emacs keybindings:

Deprecated in favor of (define-key key-minor-mode-map (kbd "s... in:
[[/Users/jay/emacs/emacs-settings/gnu-emacs-startup.org]]

#+BEGIN_EXAMPLE emacs-lisp
(define-super-key "h" 'replace-string)


(define-super-key "m" 'mc/mark-all-like-this)


(define-super-key "\\" 'visit-most-recent-file)

(define-super-key "F" 'pasteboard-search-for-clipboard-contents)

(define-super-key "R" 'projectile-find-file)
(define-super-key "t" 'new-buffer)
(define-super-key "T" 'org-new-scratch-buffer)
(define-super-key "g" 'isearch-repeat-forward)
(define-super-key "d" 'org-todo)
(define-super-key "L" 'org-mac-link-chrome-insert-frontmost-url)
(define-super-key "S" 'org-mac-link-skim-insert-page)
(define-super-key "a" 'mark-whole-buffer) ; select all
(define-super-key "w" 'delete-window) ; close
(define-super-key "s" 'jay/save-some-buffers ) ; save all
#+END_EXAMPLE

Key bindings I don't use much and should remember to learn:
#+BEGIN_SRC emacs-lisp
(define-super-key "5" 'point-stack-push)
(define-super-key "6" 'point-stack-pop)
(define-super-key "7" 'point-stack-forward-stack-pop)
(define-super-key "8" 'search-open-buffers)
(define-super-key "F" 'pasteboard-search-for-clipboard-contents)
(define-super-key "(" 'org-velocity)
(define-super-key "{" 'path-copy-path-to-clipboard)
(define-super-key "}" 'path-copy-path-to-clipboard)
;; why not use N and P here? TODO


#+END_SRC

mkprefix: Key bindings for my own custom functions, using ⌘-m as a prefix:
#+BEGIN_SRC emacs-lisp

(define-super-key "k rr" 'replace-regexp)


(define-super-key "k cf" 'customize-face)



(define-super-key "k dd" 'delete-duplicate-lines-keep-blanks)

(define-super-key "k cw" 'count-words)


(define-super-key "k bl" 'blue-light)

;; ;; Accountability

(defun keybinding-read-and-insert (key)
 (interactive "kKey: ")
(insert "(define-key key-minor-mode-map ")
  (insert (format "(kbd \"%s\")" (key-description key)))
  (insert " '")
(save-excursion (insert ")")
    ))

(define-super-key "k kb" 'keybinding-read-and-insert)
(define-super-key "k mk" 'keybinding-read-and-insert)


#+END_SRC


* sentences

Make ~kill-sentence~ work in a more intuitive way:
#+BEGIN_SRC emacs-lisp
(defun kill-sentence-to-period ()
  "Leave the period in there."
  (interactive)
  (kill-sentence)
  (push-mark)
  (insert ".")
  (backward-char)
)
#+END_SRC

[[http://emacs.stackexchange.com/questions/12266/how-change-behavior-of-kill-sentence-based-on-position-in-sentence/12321?iemail=1&noredirect=1#12321][Source]]

#+BEGIN_SRC emacs-lisp
(defun my/forward-to-sentence-end ()
  "Move point to just before the end of the current sentence."
  (forward-sentence)
  (backward-char)
  (unless (looking-back "[[:alnum:]]")
    (backward-char)))

(defun my/beginning-of-sentence-p ()
  "Return  t if point is at the beginning of a sentence."
  (let ((start (point))
        (beg (save-excursion (forward-sentence) (forward-sentence -1))))
    (eq start beg)))

(defun my/kill-sentence-dwim ()
  "Kill the current sentence up to and possibly including the punctuation.
When point is at the beginning of a sentence, kill the entire
sentence. Otherwise kill forward but preserve any punctuation at the sentence end."
  (interactive)
(smart-expand)
  (if (my/beginning-of-sentence-p)
      (progn
        (kill-sentence)
        (just-one-space)
        (when (looking-back "^[[:space:]]+") (delete-horizontal-space)))
      (kill-region (point) (progn (my/forward-to-sentence-end) (point)))
      (just-one-space 0))

;; don't leave two periods in a row
(when
(or
(looking-at "\\.\\. ")
(and
(looking-at "\\.")
(looking-back "\\.")
)
)
(delete-forward-char 1))

(when
    (and
     (looking-at ".")
     (looking-back ",")
     )
  (delete-backward-char 1)
  (forward-char 1)
  )

)
#+END_SRC

* my/kill-line-dwim

#+BEGIN_SRC emacs-lisp


(defun my/kill-line-dwim ()
  "Kill the current line."
  (interactive)
;; don't leave stray stars behind when killing a line
(when
(or
(looking-back "\\[")
(looking-back "\* ")
(looking-back "\* TODO ")
(looking-back "^\*+")
(looking-back "- ")
(looking-back "# ")
)
(beginning-of-line)
)
;;  (expand-abbrev)
  (org-kill-line)
;;  (save-excursion
;;    (when (my/beginning-of-sentence-on)
;;      (capitalize-unless-org-heading)))
)
#+END_SRC

* kill-sentence-maybe-else-kill-line


  #+BEGIN_SRC emacs-lisp
(defun kill-sentence-maybe-else-kill-line ()
  (interactive)
(when
    (not (looking-at "$"))
  (my/kill-sentence-dwim))
  (when
      (looking-at "$")
    (my/kill-line-dwim))
)
;; and the keybinding
(global-set-key (kbd "M-k") 'kill-clause)

  #+END_SRC


* Browsing

#+BEGIN_SRC emacs-lisp
(setq browse-url-browser-function 'browse-url-default-macosx-browser)
#+END_SRC

* spacecraft-mode - superior handling of whitespace for writing and editing prose


** smart-space
#+BEGIN_SRC emacs-lisp
(defun smart-period-or-smart-space ()
"double space adds a period!"
(interactive)
  (if
(looking-back "[A-Za-z0-9] ")
(smart-period)
(smart-space)
))

(defun smart-space ()
  "Insert space and then clean up whitespace."
  (interactive)
(cond (mark-active
 (progn (delete-region (mark) (point)))))

;; (if (org-at-heading-p)
 ;;    (insert-normal-space-in-org-heading)

  (unless
      (or
(let ((case-fold-search nil)
(looking-back "\\bi\.e[[:punct:][:punct:]]*[ ]*") ; don't add extra spaces to ie.
)
(looking-back "\\bvs.[ ]*") ; don't add extra spaces to vs.
(looking-back "\\be\.\g[[:punct:]]*[ ]*") ; don't add extra spaces to eg.

(looking-back "^[[:punct:]]*[ ]*") ; don't expand previous lines - brilliant!

(looking-back ">") ; don't expand days of the week inside timestamps

(looking-back "][\n\t ]*") ; don't expand past closing square brackets ]
       ))
  (smart-expand))

(insert "\ ")
(just-one-space)
)




;; this is probably convuluted logic to invert the behavior of the SPC key when in org-heading
(defun insert-smart-space-in-org-heading ()
 "Insert space and then clean up whitespace."
 (interactive)
(unless
   (or
(looking-back "\\bvs.[ ]*") ; don't add extra spaces to vs.
(looking-back "\\bi\.e[[:punct:][:punct:]]*[ ]*") ; don't add extra spaces to ie.
(looking-back "\\be\.\g[[:punct:][:punct:]]*[ ]*") ; don't add extra spaces to eg.

(looking-back "^[[:punct:][:punct:]]*[ ]*") ; don't expand previous lines---brilliant!

(looking-back ">") ; don't expand days of the week inside timestamps

(looking-back "][\n\t ]*") ; don't expand past closing square brackets ]
    )
 (smart-expand))
(insert "\ ")
 (just-one-space))



(define-key org-mode-map (kbd "<SPC>") 'smart-space)
;; (define-key orgalist-mode-map (kbd "<SPC>") 'smart-period-or-smart-space)
(global-set-key (kbd "M-SPC") 'insert-space)
(define-key org-mode-map (kbd "<M-SPC>") 'insert-space)
;; (define-key orgalist-mode-map (kbd "<M-SPC>") 'insert-space)
#+END_SRC




** my/fix-space
#+BEGIN_SRC emacs-lisp
(defun my/fix-space ()
  "Delete all spaces and tabs around point, leaving one space except at the beginning of a line and before a punctuation mark."
  (interactive)
  (just-one-space)
  (when (and (or
              (looking-back "^[[:space:]]+")
              (looking-back "-[[:space:]]+")
              (looking-at "[.,:;!?»)-]")
              (looking-back"( ")
              (looking-at " )")
              )
             (not (looking-back "^-[[:space:]]+"))
             (not (looking-back " - "))

)
    (delete-horizontal-space)))
#+END_SRC

. This.
** insert-space
#+BEGIN_SRC emacs-lisp


(defun insert-space ()
  (interactive)
(if (org-at-heading-p)
(insert-smart-space-in-org-heading)
(cond (mark-active
   (progn (delete-region (mark) (point)))))
  (insert " ")
))
(defun insert-normal-space-in-org-heading ()
 (interactive)
(cond (mark-active
 (progn (delete-region (mark) (point)))))
 (insert " ")
)
;; this is probably convuluted logic to invert the behavior of the SPC key when in org-heading


(defun insert-period ()
"Inserts a fuckin' period!"
 (interactive)
(cond (mark-active
   (progn (delete-region (mark) (point)))))

 (insert ".")
)


(defun insert-comma ()
 (interactive)
(cond (mark-active
   (progn (delete-region (mark) (point)))))
 (insert ",")
)

(defun insert-exclamation-point ()
 (interactive)
(cond (mark-active
  (progn (delete-region (mark) (point)))))
 (insert "!")
)


(defun insert-colon ()
"Insert a goodamn colon!"
 (interactive)
(cond (mark-active
  (progn (delete-region (mark) (point)))))
 (insert ":")
)

(defun insert-question-mark ()
"Insert a freaking question mark!!"
 (interactive)
(cond (mark-active
 (progn (delete-region (mark) (point)))))
 (insert "?")
)


#+END_SRC

** smart insertion of headings and subheadings
*** smart-org-meta-return-dwim
 #+BEGIN_SRC emacs-lisp
(setq org-blank-before-new-entry
      '((heading . always)
       (plain-list-item . always)))

(defun call-rebinding-org-blank-behaviour (fn)
  (let ((org-blank-before-new-entry
         (copy-tree org-blank-before-new-entry)))
    (when (org-at-heading-p)
      (rplacd (assoc 'heading org-blank-before-new-entry) nil))
    (call-interactively fn)))

(defun smart-org-meta-return-dwim ()
  (interactive)

(if

    (and
     (looking-back "^")
     (looking-at ".+")
     )                               ; if
    (org-toggle-heading-same-level) ; then
 (call-rebinding-org-blank-behaviour 'org-meta-return)) ; else
)


#+END_SRC

*** smart-org-insert-heading-respect-content-dwim
#+BEGIN_SRC emacs-lisp
(defun smart-org-insert-heading-respect-content-dwim ()
(interactive)
  (call-rebinding-org-blank-behaviour 'org-insert-heading-respect-content)
)
#+END_SRC

*** smart-org-insert-todo-heading-dwim
#+BEGIN_SRC emacs-lisp
(defun smart-org-insert-todo-heading-dwim ()
  (interactive)
  (let ((listitem-or-checkbox (org-plain-text-list-p)))
    (call-rebinding-org-blank-behaviour 'org-insert-heading)
    (if listitem-or-checkbox
        (insert "[ ] ")
        (insert "TODO ")))
)

#+END_SRC

*** smart-org-insert-todo-heading-respect-content-dwim
#+BEGIN_SRC emacs-lisp
(defun smart-org-insert-todo-heading-respect-content-dwim ()
  (interactive)
  (call-rebinding-org-blank-behaviour 'org-insert-todo-heading-respect-content)
)
#+END_SRC

*** smart-org-insert-subheading
#+BEGIN_SRC emacs-lisp
(defun smart-org-insert-subheading ()
  (interactive)
(call-rebinding-org-blank-behaviour 'org-meta-return)
(org-demote-subtree)
)
#+END_SRC

*** smart-org-insert-todo-subheading
#+BEGIN_SRC emacs-lisp
(defun smart-org-insert-todo-subheading ()
  (interactive)
(call-rebinding-org-blank-behaviour 'org-insert-todo-subheading)
)
#+END_SRC

*** keybindings
#+BEGIN_SRC emacs-lisp
(define-key org-mode-map (kbd "M-<return>") 'smart-org-meta-return-dwim)
(define-key org-mode-map (kbd "M-S-<return>") 'smart-org-insert-todo-heading-dwim)
(define-key org-mode-map (kbd "C-<return>") 'return-insert-blank-line-before)
(define-key org-mode-map (kbd "C-S-<return>") 'smart-org-insert-todo-heading-respect-content-dwim)
(define-key org-mode-map (kbd "C-M-<return>") 'smart-org-insert-subheading)
(define-key org-mode-map (kbd "<C-S-M-return>") 'smart-org-insert-todo-subheading)
(define-key org-mode-map (kbd "<C-s-return>") 'smart-org-insert-todo-subheading)
(define-key key-minor-mode-map (kbd "<s-S-return>") 'smart-org-insert-todo-heading-dwim)
(define-key key-minor-mode-map (kbd "<s-return>") 'toggle-fullscreen)
 #+END_SRC


*** length of previous line
#+BEGIN_SRC emacs-lisp

(defun length-of-previous-line ()
 (save-excursion
  (forward-line -1)
  (end-of-line)
  (current-column)))
#+END_SRC


** smart return
https://chatgpt.com/share/e/a73dbb9f-9ad0-403c-bb61-621be0a3c0f2


** kill word correctly
#+BEGIN_SRC emacs-lisp
(defun kill-word-correctly ()
  "Kill word."
  (interactive)
  (smart-expand)
  (if (or (re-search-forward "\\=[ 	]*\n" nil t)
          (re-search-forward "\\=\\W*?[[:punct:]]+" nil t)) ; IF there's a sequence of punctuation marks at point
      (kill-region (match-beginning 0) (match-end 0)) ; THEN just kill the punctuation marks
    (kill-word 1))                                    ; ELSE kill word
  (my/fix-space)
;; don't leave two periods in a row
(when
(or
(looking-at "\\,\\, ")

(and
(looking-at "\\,")
(looking-back "\\,")
)
)
(delete-forward-char 1))
)

#+END_SRC

** kill word correctly and capitalize

#+BEGIN_SRC emacs-lisp
(defun kill-word-correctly-and-capitalize ()
  "Kill the word correctly and capitalize if at the beginning of a sentence and capitalist-mode is enabled."
  (interactive)
  ;; Move forward if at a space
  (when (looking-at " ")
    (forward-char 1))
  ;; Check if at the beginning of a sentence
  (let ((fix-capitalization (my/beginning-of-sentence-p)))
    ;; Kill the word correctly
    (call-interactively 'kill-word-correctly)
    ;; Capitalize if needed and capitalist-mode is enabled
    (when (and fix-capitalization capitalist-mode)
      (save-excursion
        (capitalize-unless-org-heading)))))
#+END_SRC


* character movement
#+BEGIN_SRC emacs-lisp
(defun jay/left-char ()
  "Move point to the left or the beginning of the region.
 Like `backward-char', but moves point to the beginning of the region
provided the (transient) mark is active."
  (interactive)
  (let ((this-command 'left-char)) ;; maintain compatibility
    (let ((left (min (point)
                     ;; `mark' returning nil is ok; we'll only use this
                     ;; if `mark-active'
                     (or (mark t) 0))))
      (if (and transient-mark-mode mark-active)
          (progn
            (goto-char left)
            (setq deactivate-mark t))
        (call-interactively 'left-char)))))


(defun jay/right-char ()
  "Move point to the right or the end of the region.
 Like `right-char', but moves point to the end of the region
provided the (transient) mark is active."
  (interactive)
  (let ((this-command 'right-char)) ;; maintain compatibility
    (let ((right (max (point)
                      ;; `mark' returning nil is ok; we'll only use this
                      ;; if `mark-active'
                      (or (mark t) 0))))
      (if (and transient-mark-mode mark-active)
          (progn (goto-char right)
		 (setq deactivate-mark t))
	(call-interactively 'right-char)))))

(define-key org-mode-map (kbd "<left>") 'jay/left-char)
(define-key org-mode-map (kbd "<right>") 'jay/right-char)

#+END_SRC

* saveplace
;; Save point position between sessions

#+BEGIN_SRC emacs-lisp
;; Save point position between sessions
(use-package saveplace
:defer
 :init (save-place-mode))
#+END_SRC

The saveplace package is part of Emacs, and remembers the position of point - even between emacs sessions.

The last line sets the path to where saveplace stores your position data. Change it at your peril!

* embolden next word

   #+BEGIN_SRC emacs-lisp
(define-minor-mode embolden-next-word
    "Make the next word you type bold."
  nil
  :lighter " EMBOLDEN"
  :keymap (let ((map (make-sparse-keymap)))
            (define-key map (kbd "SPC") (lambda ()
                      (interactive)
                      (expand-abbrev)
                      (save-excursion
                        (goto-char (get-register 'p))
                        (insert "*"))
                      (insert "* ")
                      (embolden-next-word -1)))
        (define-key map (kbd ".") (lambda ()
                    (interactive)
                    (expand-abbrev)
                    (save-excursion
                      (goto-char (get-register 'p))
                      (insert "*"))
                    (insert "*. ")
                    (embolden-next-word -1)))
            map)
  (if embolden-next-word
      (set-register 'p (point))
    (set-register 'p nil)))

(global-set-key "\C-o" 'embolden-or-bold)
(define-key key-minor-mode-map (kbd "C-o") 'embolden-or-bold)
   #+END_SRC

* cycle-hyphenation

#+BEGIN_SRC emacs-lisp
(defun cycle-hyphenation ()
  (interactive)
  (cond ((re-search-forward "\\=\\w*\\(-\\)\\w+" nil t)
         (save-excursion (replace-match " " t t nil 1)))
        ((re-search-forward "\\=\\w*\\( +\\)\\w+" nil t)
         (save-excursion (replace-match "-" t t nil 1)))))
#+END_SRC

* cycle-punctuation

#+BEGIN_SRC emacs-lisp
(defvar *punctuation-markers-to-cycle-between*  ".?!")

(defun cycle-punctuation ()
  (interactive)
  (save-excursion
    (forward-sentence)
    (when (re-search-backward (format "\\>\\([%s]\\)[[:space:]]*\\="
                                      *punctuation-markers-to-cycle-between*)
                              nil t)
      (let ((next (elt *punctuation-markers-to-cycle-between*
                       ;; circular string; should be abstracted
                       (mod (1+ (position (elt (match-string 1) 0)
                                          *punctuation-markers-to-cycle-between*))
                            (length *punctuation-markers-to-cycle-between*)))))
        (replace-match (format "%c" next) t t nil 1)))))

;; (define-key key-minor-mode-map (kbd "M-.") 'cycle-punctuation)
#+END_SRC

* clone subtree
#+BEGIN_SRC emacs-lisp
(defun org-clone-subtree ()
  (interactive)
  (org-clone-subtree-with-time-shift 1)
  (save-excursion
    (org-goto-sibling)
    ;; This part was lifted partly and adapted from
    ;; http://orgmode.org/worg/org-hacks.html#orgheadline10.
    ;; There should be a better way to change the contents of an org heading
    ;; though...
    (when (org-at-heading-p)
      (let ((hl-text (nth 4 (org-heading-components)))
            (buffer-undo-list))
        (when hl-text
          (beginning-of-line)
          (search-forward hl-text (point-at-eol))
          (replace-match (format "%s" hl-text) nil t)
;; (org-align-tags-here org-tags-column)
)))))
#+END_SRC

* smart punctuation

** kill-clause
~Kill-clause~ kills (cuts) a clause in the text and makes various fixes to punctuation and spacing.

1. ~(smart-expand)~: call expand-abbrev on any unexpanded words.
3. Check if the cursor is at a comma, semicolon, or colon and moves one character to the right if so.
4. The function determines whether to kill the entire line or just a portion of it, based on specific conditions.
5. The function makes several fixes to punctuation and spacing, such as:
  - Removing extra spaces before punctuation marks
  - Deleting incorrect combinations of punctuation marks and spaces
  - Capitalizing the first letter of a sentence unless it's an Org mode heading
6. The function ensures the cursor is left at an appropriate position, either before or after punctuation, depending on the context.

#+BEGIN_SRC emacs-lisp

    (defun kill-clause ()
      (interactive)
      (smart-expand)
(when (or (looking-at ",")
          (looking-at ";")
          (looking-at ":"))
  (org-delete-char 1))
(when (or (looking-back ",")
     (looking-back ";")
     (looking-back ":"))
 (org-delete-backward-char 1))


(when (looking-back " ")
  (left-char 1))

      (if
	  (let ((sm (string-match "*+\s" (thing-at-point 'line)))) (and sm (= sm 0)))
	  (kill-line)

	(let ((old-point (point))
	      (kill-punct (my/beginning-of-sentence-p)))
	  ;; Stop at a period followed by a space, or the end of the line
	  (when (re-search-forward "--\\|[][,;:?!…\"”()}\\.]+\\|$" nil t)
	    (kill-region old-point
			 (if kill-punct
			     (match-end 0)
			   (match-beginning 0)))))
	(my/fix-space)
	(save-excursion
	  (when (my/beginning-of-sentence-p)
	    (capitalize-unless-org-heading)))

(cond
 ((looking-back "\\, \\, ")
 (new-org-delete-backward-char 2)
 (my/fix-space)
 t)

((looking-back "!\\. ")
 (new-org-delete-backward-char 2)
 (my/fix-space)
 t)

 ((looking-back ":: ")
 (new-org-delete-backward-char 2)
 (my/fix-space)
 t))

(when
    (looking-back "[[:punct:]]")
  (progn
(forward-char 1)
(my/fix-space)
(backward-char 1)))
    ;; fix a bug that leaves this: " ?"
    (when (looking-back " \\?")
        (left-char 1)
    (new-org-delete-backward-char 1)
    (right-char 1))


    ;; fix a bug that leaves this: " , "
    (when (looking-back " , ")
    (left-char 2)
    (my/fix-space)
    (right-char 2))

    ;; fix a bug that leaves this: ":, "
    (when (looking-back ":, ")
    (left-char 1)
    (delete-backward-char 1)
    (right-char 1))

    ;; fix a bug that leaves this: ",."
    (when (looking-back "\\,\\. ")
    (left-char 2)
    (delete-backward-char 1)
    (right-char 2)
    )


    ;; fix a bug that leaves this: ", . "
    (when (looking-back "\\, \\. ")
    (left-char 2)
    (delete-backward-char 2)
    (right-char 2)
    )


    ;; fix a bug that leaves this: " ; "
    (when
	(looking-back " [[:punct:]] ")
    (left-char 2)
    (delete-backward-char 1)
    (right-char 2)
    )




    (when
    (and
    (looking-back "----")
    (looking-at "-"))

    (delete-backward-char 4)
    (delete-char 1)
    (insert-space))

    ;; leave the cursor before the comma or period, not after it
    (when
    (looking-back "[[:punct:]] ")
    (left-char 2))
    (when
    (looking-back "[[:punct:]]")
    (left-char 1))



    ;; fix a bug that leaves this: ".,"
 (when
	(looking-at "\\.\\,")
 (delete-forward-char 1)
 )
;; works!!



  ;; fix a bug that leaves this: ":."
 (when
	(looking-at ":\\.")
 (delete-forward-char 1)
 )
;; works!!


;; a more general solution, haven't tested it yet:
;; (when
;;   (looking-at "[[:punct:]]\\.")
;; (delete-forward-char 1) )





    ;; when on a punctuation mark with a space before it, delete the space
    (when
	(and
    (looking-at "[[:punct:]]")
    (looking-back " ")
)
  (delete-backward-char 1))
    )

  (when
    (or
     (looking-at ":\\,")
     (looking-at ";\\,")
     (looking-at "\\,\\,")
     (looking-at "\\.\\.")
     (looking-at "\\,;")
     (looking-at "\\,:")
     (looking-at "\\?\\?")
)
(right-char 1)
      (delete-char 1)
      (left-char 1)
)
  ;; Add this near the end of the function, before the final right parenthesis
(when (looking-at ",")
  (when (looking-back ", ")
    (delete-backward-char 2)
    (insert ", "))))




#+END_SRC





** smart-punctuation exceptions

   #+BEGIN_SRC emacs-lisp
(defvar *smart-punctuation-marks*
  ".,;:!?-")

(setq *smart-punctuation-exceptions*
  (list "?!" ".." "..." "............................................." "---" ";;" "!!" "!!!" "??" "???" "! :" ". :" ") ; "))

   #+END_SRC


** smart-punctuation (auxiliary)

#+BEGIN_SRC emacs-lisp
  (defun smart-punctuation (new-punct &optional not-so-smart)
    (smart-expand)
    (save-restriction
      (when (and (eql major-mode 'org-mode)
                 (org-at-heading-p))
        (save-excursion
          (org-beginning-of-line)
          (let ((heading-text (fifth (org-heading-components))))
            (when heading-text
              (search-forward heading-text)
              (narrow-to-region (match-beginning 0) (match-end 0))))))
      (cl-flet ((go-back (regexp)
                  (re-search-backward regexp nil t)
                  (ignore-errors      ; might signal `end-of-buffer'
                    (forward-char (length (match-string 0))))))
        (if not-so-smart
            (let ((old-point (point)))
              (go-back "[^ \t]")
              (insert new-punct)
              (goto-char old-point)
              (forward-char (length new-punct)))
          (let ((old-point (point)))
            (go-back (format "[^ \t%s]\\|\\`" *smart-punctuation-marks*))
            (let ((was-after-space (and (< (point) old-point)
                                        (find ?  (buffer-substring (point) old-point)))))
              (re-search-forward (format "\\([ \t]*\\)\\([%s]*\\)"
                                         ,*smart-punctuation-marks*)
                                 nil t)
              (let* ((old-punct (match-string 2))
                     (was-after-punct (>= old-point (point))))
                (replace-match "" nil t nil 1)
                (replace-match (or (when (and was-after-punct
                                              (not (string= old-punct "")))
                                     (let ((potential-new-punct (concat old-punct new-punct)))
                                       (find-if (lambda (exception)
                                                  (search potential-new-punct exception))
                                                ,*smart-punctuation-exceptions*)))
                                   new-punct)
                               nil t nil 2)
                (if was-after-space
                    (my/fix-space)
                  (when (looking-at "[ \t]*\\<")
                    (save-excursion (my/fix-space))))))))))
    (when (and (eql major-mode 'org-mode)
               (org-at-heading-p))
))
#+END_SRC

** smart-period
#+BEGIN_SRC emacs-lisp
(defun smart-period ()
  (interactive)
(cond (mark-active
 (progn (delete-region (mark) (point)))))
(unless
      (or
(looking-back "\\bvs.[ ]*") ; Don't add extra periods to vs.
(looking-back "\\bi\.e[[:punct:]]*[ ]*") ; don't add extra periods to ie.
(looking-back "\\be\.\g[[:punct:]]*[ ]*") ; don't add extra periods to eg.

       )
  (smart-punctuation "."))
  (save-excursion
    (unless
        (or
         (looking-at "[ ]*$")
         (looking-at "\][[:punct:]]*[ ]*$")
         (looking-at "[[:punct:]]*[ ]*$")
         (looking-at "\"[[:punct:]]*[ ]*$")
         (looking-at "\)[ ]*$")
         (looking-at "\)")
         ) ; or
    (capitalize-unless-org-heading)
      ) ; unless
) ; save excursion

;; if two periods or two commas in a row, delete the second one
(when
(or
(and
(looking-at "\\.")
(looking-back "\\.")
)
(and
(looking-at ",")
(looking-back ",")
))
(delete-char 1)
)

  )


(define-key org-mode-map (kbd ".") 'smart-period)

#+END_SRC

** smart-comma
#+BEGIN_SRC emacs-lisp
(defun smart-comma ()
  (interactive)
(cond (mark-active
 (progn (delete-region (mark) (point)))))

  (smart-punctuation ",")
(unless
(or

(looking-at "\]*[[:punct:]]*[ ]*$")
(looking-at "[[:punct:]]*[ ]*$")
(looking-at "[ ]*I\\b")          ; never downcase the word "I"
(looking-at "[ ]*I\'")          ; never downcase the word "I'
(looking-at "[[:punct:]]*[ ]*\"")          ; beginning of a quote
)

(save-excursion (downcase-word 1)))
(when

;; if two periods or two commas in a row, delete the second one
(or
(and
(looking-at "\\.")
(looking-back "\\.")
)
(and
(looking-at ",")
(looking-back ",")
))
(delete-char 1)
)

)


(define-key org-mode-map (kbd ",") 'comma-or-smart-comma)
;; (define-key orgalist-mode-map (kbd ",") 'comma-or-smart-comma)
#+END_SRC

** smart-question-mark
#+BEGIN_SRC emacs-lisp
(defun smart-question-mark ()
  (interactive)
  (cond (mark-active
         (progn (delete-region (mark) (point)))))

  (smart-punctuation "?")
  (save-excursion
    (unless
        (or
         (looking-at "[ ]*$")
         (looking-at "\][[:punct:]]*[ ]*$")
         (looking-at "[[:punct:]]*[ ]*$")
         (looking-at "\"[[:punct:]]*[ ]*$")
         (looking-at "\)[ ]*$")
         (looking-at "\)")
         ) ; or
    (capitalize-unless-org-heading)
      ) ; unless
    ) ; save excursion
  ) ; defun

;; works!!

(define-key org-mode-map (kbd "?") 'smart-question-mark)
;; (define-key orgalist-mode-map (kbd "?") 'smart-question-mark)
#+END_SRC

** smart-exclamation-point
#+BEGIN_SRC emacs-lisp
(defun smart-exclamation-point ()
  (interactive)
(cond (mark-active
 (progn (delete-region (mark) (point)))))

  (smart-punctuation "!")
(save-excursion
(unless (looking-at "[ ]*$")
(capitalize-unless-org-heading))
))

(define-key org-mode-map (kbd "!") 'smart-exclamation-point)
;; (define-key orgalist-mode-map (kbd "!") 'smart-exclamation-point)
#+END_SRC

** smart-hyphen
(defun smart-hyphen ()
  (interactive)
  (smart-punctuation "-"))

(define-key org-mode-map (kbd "-") 'smart-hyphen)
;; (define-key orgalist-mode-map (kbd "-") 'smart-hyphen)
#+END_SRC

** smart-semicolon

#+BEGIN_SRC emacs-lisp
(defun smart-semicolon ()
  (interactive)
(cond (mark-active
 (progn (delete-region (mark) (point)))))
  (smart-punctuation ";")
(unless
(or
(looking-at "[[:punct:]]*[ ]*$")
(looking-at "[ ]*I\\b")     ; never downcase the word "I"
(looking-at "[ ]*I\'")     ; never downcase the word "I'
(looking-at "[[:punct:]]*[ ]*\"")     ; beginning of a quote
)

(save-excursion (downcase-word 1))))

(define-key org-mode-map (kbd ";") 'smart-semicolon)
;; (define-key orgalist-mode-map (kbd ";") 'smart-semicolon)
#+END_SRC

** smart-colon

#+BEGIN_SRC emacs-lisp
(defun smart-colon ()
  (interactive)
(cond (mark-active
  (progn (delete-region (mark) (point)))))
  (smart-punctuation ":")
(unless
(or
(looking-at "[[:punct:]]*[ ]*$")
(looking-at "[ ]*I\\b")     ; never downcase the word "I"
(looking-at "[ ]*I\'")     ; never downcase the word "I'
(looking-at "[[:punct:]]*[ ]*\"")     ; beginning of a quote
)

;; (save-excursion (downcase-word 1))
))


(define-key org-mode-map (kbd ":") 'colon-or-smart-colon)



(define-key org-mode-map (kbd ",") 'comma-or-smart-comma)
;; (define-key orgalist-mode-map (kbd ":") 'smart-colon)
#+END_SRC

** comma-or-smart-comma
#+BEGIN_SRC emacs-lisp
(defun comma-or-smart-comma ()
(interactive)
(if
(or
(bolp)
(org-at-heading-p)
(looking-at " \"")
)
(insert ",")
(smart-comma))
)
#+END_SRC


** colon-or-smart-colon
#+BEGIN_SRC emacs-lisp
(defun line-starts-with-hash-p ()
 (save-excursion
  (beginning-of-line)
  (looking-at-p "#")))

(defun colon-or-smart-colon ()
 (interactive)
 (if (or (bolp)
     (org-at-heading-p)
     (line-starts-with-hash-p))
   (insert ":")
  (smart-colon)))
#+END_SRC

* TODO [#A] check my changes to backward-kill-word-correctly?
Rúdi: desired behavior is that when invoking backward-kill-word-correctly to delete words backwards, Emacs should leave a space after the word to the left of the point UNLESS point is at the beginning of the line or after "---"

I tried to implement this myself, below. My hack seems to work, but it seems slow... Is it possible to make it faster or no? maybe just than a look at the below and see if you think I implemented it in the best way.

#+BEGIN_SRC emacs-lisp
(defun backward-kill-word-correctly ()
  "Kill word."
  (interactive)
  (if (re-search-backward "\\>\\W*[[:punct:]]+\\W*\\=" nil t)
      (kill-region (match-end 0) (match-beginning 0))
    (backward-kill-word 1))
  (my/fix-space)

;; I added this ↓↓↓ #######################
(when (and
(not (looking-back "---")) ; I added this
(not (looking-back "^"))) ; I added this
;; I added this ↑↑↑ #######################

(smart-space)
)
(my/fix-space
))
#+END_SRC

** NOTE-TO-JAY Question

   Since ~backward-kill-word-correctly~ already calls ~my/fix-space~, isn't a call to ~smart-space~ redundant? What was the use case you were thinking of when you originally added it? Note that if you remove the whole ~(when ...)~ block, it apparently works as you intend it to work...

** NOTE-TO-SERJ Answer
Good question. The answer is that there should never be a space after "---"

Example:
: Alice was tired---tired as hell. ^

Say the point is the carat, and I invoke backward-kill-word-correctly 4 times.

Output if I remove the whole ~(when ...)~ block:
: Alice was tired--- ^
Note the space after "---"

Desired output:
: Alice was tired---^
No space. Does that make sense? Thanks!

* DONE [#B] my-delete-backward                                         :rudi:
#+BEGIN_SRC emacs-lisp
(defun my/delete-backward ()
  "When there is an active region, delete it and then fix up the whitespace"
  (interactive)
  (if (use-region-p)
      (delete-region (region-beginning) (region-end))
    (delete-backward-char 1))
  (save-excursion
    (when (or (looking-at "[[:space:]]")
              (looking-back "[[:space:]]"))
(unless (looking-back "\\w ")
      (my/fix-space)))))
#+END_SRC

** my-delete-backward-and-capitalize

#+BEGIN_SRC emacs-lisp
(defcustom capitalize-after-deleting-single-char nil
  "Determines whether capitalization should occur after deleting a single character.")

(defun my/delete-backward-and-capitalize ()
  "When there is an active region, delete it and then fix up the whitespace"
  (interactive)
(when (looking-back "^[*]+ ")
(kill-line 0)
(insert " ") ; this line is super hacky I put it here because when I tried to use "unless", the rest of the function, and then this at the end, it didn't work; however, this does produce the behavior I desire
)

  (let ((capitalize capitalize-after-deleting-single-char))
    (if (use-region-p)
        (progn
          (delete-region (region-beginning) (region-end))
          (setf capitalize t))
      (new-org-delete-backward-char 1))
    (save-excursion
      (when (or (looking-at "[[:space:]]")
    (looking-back "[[:space:]]"))
;; unless there's already exactly one space between words, since I need to be able to delete backward past spaces
(unless (and
(looking-back "\\w ")
(looking-at "\\w")
)
  (my/fix-space))))
    (when (and capitalize (my/beginning-of-sentence-p))
      (save-excursion
        (capitalize-unless-org-heading))))
(when

(or
(and
(looking-at "\\.")
(looking-back "\\.")
)
(and
(looking-at ",")
(looking-back ",")
))
(delete-char 1)
)
)
#+END_SRC

* backward-kill-word-correctly-and-capitalize
#+BEGIN_SRC emacs-lisp
(defun backward-kill-word-correctly-and-capitalize ()
  "Backward kill word correctly. Then check to see if the point is at the beginning of the sentence. If yes, then kill-word-correctly and endless/capitalize to capitalize the first letter of the word that becomes the first word in the sentence. Otherwise simply kill-word-correctly."
  (interactive)
(call-interactively 'backward-kill-word-correctly)
  (let ((fix-capitalization (my/beginning-of-sentence-p)))
    (when fix-capitalization
      (save-excursion (capitalize-unless-org-heading)))))
#+END_SRC

* defadvice capitalize-word
#+BEGIN_SRC emacs-lisp
(defadvice capitalize-word (after capitalize-word-advice activate)
  "After capitalizing the new first word in a sentence, downcase the next word which is no longer starting the sentence."

  (unless

      (or
       (looking-at "[ ]*\"")          ; if looking at a quote? Might not work

       (looking-at "[[:punct:]]*[ ]*I\\b")          ; never downcase the word "I"
       (looking-at "[[:punct:]]*[ ]*I'")          ; never downcase words like I'm, I'd
       (looking-at "[[:punct:]]*[ ]*\"*I'")    ; never downcase words like I'm, I'd

(looking-at "[ ]*I\'")   ; never downcase the word "I'

       (looking-at "[[:punct:]]*[ ]*\"I\\b")          ; never downcase the word "I"
       (looking-at "[[:punct:]]*[ ]*OK\\b")          ; never downcase the word "OK"

       ;; (looking-at "\\") ; how do you search for a literal backslash?
       (looking-at (sentence-end))

       (looking-at "[[:punct:]]*[ ]*$") ; don't downcase past line break

       (looking-at "[[:punct:]]*[ ]*\"$") ; don't downcase past quotation then line break
       (looking-at "[[:punct:]]*[ ]*)$") ; don't downcase past a right paren then line break
       (looking-at "[[:punct:]]*[ ]*\")$") ; don't downcase past a quotation then a right paren then a line break

       (looking-at "[[:punct:]]*[ ]*http") ; never capitalize http

(looking-at "\"[[:punct:]]*[ ]*$") ; a quotation mark followed by "zero or more whitespace then end of line?"

(looking-at "\)[ ]*$") ; a right paren followed by "zero or more" whitespace, then end of line

(looking-at ")[ ]*$") ; a right paren followed by "zero or more" whitespace, then end of line
(looking-at ")$") ; a right paren followed by "zero or more" whitespace, then end of line

(looking-at "[ ]*-*[ ]*$") ; dashes at the end of a line


       (looking-at (user-full-name))

       )

    (save-excursion
      (downcase-word 1))))
#+END_SRC

I tried to add exceptions for "line-end" and also for user-full name.

* capitalize-unless-org-heading
  #+BEGIN_SRC emacs-lisp
(defun capitalize-unless-org-heading ()
  (interactive)
(when capitalist-mode
  (unless
      (or
       (looking-at "[[:punct:]]*[\n\t ]*\\*")
       (let ((case-fold-search nil))
         (looking-at "[ ]*[\n\t ]*[[:punct:]]*[\n\t ]*[A-Z]")
         (looking-at "[A-Z].*"))
       (looking-at "[\n\t ]*[[:punct:]]*[\n\t ]*#\\+")
       (looking-at "[\n\t ]*[[:punct:]]*[\n\t ]*\(")
       (looking-at "[\n\t ]*[[:punct:]]*[\n\t ]*<")
       (looking-at "[\n\t ]*[[:punct:]]*[\n\t ]*file:")
       (looking-at "[\n\t ]*\\[fn")
       (looking-at "[\n\t ]*)$")
       (looking-at "[\n\t ]*\"$")
       (looking-at "\"[\n\t ]*$")
       (looking-at "[[:punct:]]*[ ]*http")
       (looking-at "[[:punct:]]*[ ]*\")$"); don't capitalize past
       (looking-at "[ ]*I\'")
       (looking-at
        (concat
         "\\("
         (reduce (lambda (a b) (concat a "\\|" b))
                 auto-capitalize-words)
         "\\)")))
    (capitalize-word 1))))
  #+END_SRC

* downcase-save-excursion

  #+BEGIN_SRC emacs-lisp
(defun downcase-save-excursion ()
  (interactive)
(unless
(or
(looking-at "[[:punct:]]*[ ]*$")
(looking-at "[ ]*I\\b") ; never downcase the word "I"
(looking-at "[[:punct:]]*[ ]*[[:punct:]]*I'")  ; never downcase I'm I've etc.
(looking-at "[[:punct:]]*[ ]*$") ; zero or more whitespaces followed by zero or more punctuation followed by zero or more whitespaces followed by a line break
(looking-at "\"[[:punct:]]*[ ]*$") ; a quotation mark followed by "zero or more whitespace then end of line?"
(looking-at "\)[ ]*$") ; a quotation mark followed by "zero or more whitespace then end of line?"
(looking-at (sentence-end)) ; quotation mark followed by "zero or more whitespace then end of line?"
       (looking-at (user-full-name))


)
  (save-excursion
      (downcase-word 1))
  ))
  #+END_SRC


* smart-expand
Don't expand past certain delimiters, e.g. line break, ), and "


#+BEGIN_SRC emacs-lisp

(defun smart-expand ()
  (interactive)

  (unless

    (or
       (looking-back "\)\n*")
(looking-back "[[:punct:]]*\)[ ]*[[:punct:]]*[\n\t ]*[[:punct:]]*>*")
(looking-back ":t[ ]*")
(looking-back "][\n\t ]*[[:punct:]]*[\n\t ]*") ; don't expand past closing square brackets ]

(looking-back ">[\n\t ]*[[:punct:]]*[\n\t ]*") ; don't expand past closing email addresses]


;; (looking-back "\\\w") ; for some reason this matches all words, not just ones that start with a backslash
)
    (expand-abbrev)
)
)

#+END_SRC



* fountain
  #+BEGIN_SRC emacs-lisp
;; (load-file "/Users/jay/emacs/emacs-settings/fountain-mode.el")
;; (use-package fountain-mode)

;; (add-hook 'fountain-mode-hook 'turn-on-olivetti-mode)
(add-hook 'fountain-mode-hook #'(lambda () (orgalist-mode 1)))
;; (add-hook 'fountain-mode-hook 'turn-on-auto-capitalize-mode 'append)

(add-hook 'fountain-mode-hook (lambda () (imenu-list-minor-mode 1)))

(defcustom fountain-export-default-command
  'fountain-export-shell-script
  "\\<fountain-mode-map>Default function to call with \\[fountain-export-default]."
  :type '(radio (function-item fountain-export-shell-script)
                (function-item fountain-export-buffer-to-html))
  :group 'fountain-export)

(defcustom fountain-export-shell-script
  "afterwriting --config ~/.config/afterwriting/config.json --source %s --pdf --overwrite"
  "Shell command string to convert Fountain source to ouput.
\"%s\" will be substituted with `buffer-file-name'"
  :type 'string
  :group 'fountain-export)

(defun fountain-export-shell-script (&optional buffer)
  "Call shell script defined in `fountain-export-shell-script'."
  (interactive)
  (let* ((buffer (or buffer (current-buffer)))
         (file (shell-quote-argument (buffer-file-name buffer)))
         (command (format fountain-export-shell-script file)))
    (async-shell-command command "*Fountain Export Process*")))

(setq fountain-export-include-title-page nil)
(setq fountain-export-html-replace-alist
   (quote
    (("&" "&amp;")
     ("<" "&lt;")
     (">" "&gt;")
     ("\\\\ " "&nbsp;")
     ("^\\\\$" "<br>")
     ("\\\\_" "&#95;")
     ("\\\\\\*" "&#42;")
     ("\\\\`" "&#96;")
     ("\\\\'" "&apos;")
     ("``" "&ldquo;")
     ("''" "&rdquo;")
     ("`" "&lsquo;")
     ("'" "&rsquo;")
     ("\\*\\*\\*\\(.+?\\)\\*\\*\\*" "<span class=\"underline\">\\1</span>")
     ("\\*\\*\\(.+?\\)\\*\\*" "<span class=\"underline\">\\1</span>")
     ("\\*\\(.+?\\)\\*" "<span class=\"underline\">\\1</span>")
     ("^~ *\\(.+?\\)$\\*\\*" "<i>\\1</i>")
     ("_\\(.+?\\)_" "<span class=\"underline\">\\1</span>")
     ("

+" "<br><br>")
     ("
" "<br>"))))
  #+END_SRC

* Hook app
[[https://discourse.hookproductivity.com/t/integrating-emacs-and-hook-with-org-mode/932/10][Integrating Emacs and Hook, with org-mode - Discussion & Help - Hook Productivity Forum]]

#+begin_src emacs-lisp

(setq frame-title-format '((:eval buffer-file-name)))

(defun my/hook (hook)
 "Create an org-link target string using `hook://` url scheme."
 (shell-command (concat "open \"" hook "\"")))

 (org-add-link-type "hook" 'my/hook)
#+end_src

* keybindings for terminal
#+BEGIN_SRC emacs-lisp
(define-key key-minor-mode-map (kbd "M-(") 'backward-word)
(define-key key-minor-mode-map (kbd "M-)") 'forward-word)
#+END_SRC


* capitalize sentence
#+BEGIN_SRC emacs-lisp
(defun capitalize-sentence ()
  (interactive)
(unless (my/beginning-of-sentence-p)
(org-backward-sentence))
  (endless/capitalize)
(org-forward-sentence 1)
(jay/right-char)
)
(define-key key-minor-mode-map (kbd "M-C") 'capitalize-word)

#+END_SRC

* downcase sentence
#+BEGIN_SRC emacs-lisp
(defun downcase-sentence ()
  (interactive)
(unless (my/beginning-of-sentence-p)
(org-backward-sentence))
  (downcase-word 1)
(org-forward-sentence 1)
(jay/right-char)
)

(define-key key-minor-mode-map (kbd "M-L") 'downcase-sentence)

#+END_SRC

* return-insert-blank-line-before

#+BEGIN_SRC emacs-lisp
(defun return-insert-blank-line-before ()
  (interactive)
  (beginning-of-line)
(newline)
  )
#+END_SRC


* disable color themes
#+BEGIN_SRC emacs-lisp
(defadvice load-theme (before theme-dont-propagate activate)
 (mapc #'disable-theme custom-enabled-themes))
#+END_SRC

* toggle item or hyphenation
#+BEGIN_SRC emacs-lisp
(defun toggle-item-or-hyphenation ()
(interactive "P")
(if

    (region-active-p)                               ; if
    (org-toggle-item) ; then
    (cycle-hyphenation); else
)
)
#+END_SRC

* my-forward-sentence
#+BEGIN_SRC emacs-lisp
(defun smart-forward-sentence ()
  (interactive)
  (org-forward-sentence)
  (my/fix-space)
  )
#+END_SRC



* replace-inner
#+BEGIN_SRC emacs-lisp
(defun replace-inner ()
  (interactive)
(change-inner)
  (pasteboard-paste-no-spaces)
  )
#+END_SRC

doesn't work.


* bjm-swiper

#+BEGIN_EXAMPLE emacs-lisp
;;advise swiper to recenter on exit
(defun bjm-swiper-recenter (&rest args)
  "recenter display after swiper"
  (recenter)
  )
(advice-add 'swiper :after #'bjm-swiper-recenter)
#+END_EXAMPLE


* embolden-or-bold


#+BEGIN_SRC emacs-lisp

(defun embolden-or-bold (arg)
  (interactive "p")
  (if (region-active-p)
      ;;      (wrap-region-trigger arg "*")
      (let ((s (replace-regexp-in-string
                "[*]" "" (delete-and-extract-region (region-beginning) (region-end)))))
        (insert "*")
        (insert s)
        (insert "*"))
    (embolden-next-word)))

#+END_SRC

* color theme advice
#+BEGIN_SRC emacs-lisp
  (defadvice load-theme (after load-theme-advice activate)
  (custom-set-faces
  '(bold ((t (:inherit font-lock-warning-face :weight bold))))
  '(org-quote ((t (:inherit default))))
  ;; '(org-link ((t (:underline nil))))
  '(org-done ((,class (:weight bold :box (:line-width 1 :color "#BBBBBB") :foreground "#BBBBBB" :background "green"))))



  (org-mode)
    ))
#+END_SRC


* leader key, doesn't need a special mode

#+BEGIN_SRC emacs-lisp
(define-key key-minor-mode-map (kbd "] i t") 'org-inlinetask-insert-task)



(global-unset-key (kbd "] cr"))
(define-key key-minor-mode-map (kbd "] cr") 'load-roam-config)
(define-key key-minor-mode-map (kbd "] cs") 'load-search-config)
(define-key key-minor-mode-map (kbd "] ci") 'load-spacemacs-config)
(define-key key-minor-mode-map (kbd "] ]") 'insert-right-bracket)

#+END_SRC


* fix image links
#+BEGIN_EXAMPLE emacs-lisp
(defun fix-image-links ()
(interactive)
(goto-char 1)
(while (search-forward-regexp "[[\(.*?\).jpg][\(.*?\).jpg]]" nil t)
  (replace-match "[[" (match-string 1) ".jpg]]"  t nil))

(while (search-forward-regexp "[[\(.*?\).png][\(.*?\).png]]" nil t)
  (replace-match "[[" (match-string 1) ".png]]"  t nil))
)
#+END_EXAMPLE


* replace missing PDF ligatures

different → different

#+BEGIN_SRC emacs-lisp
(defun replace-missing-ligatures ()
"Replace goofy MS and other garbage characters with latin1 equivalents."
(interactive)
(save-excursion				; save the current point

  (replace-string "de cit" "deficit" nil (point-min) (point-max))
  (replace-string "di eren" "differen" nil (point-min) (point-max))
  (replace-string "e ective" "effective" nil (point-min) (point-max))
  (replace-string "de ne" "define" nil (point-min) (point-max))
  (replace-string "re ect" "reflect" nil (point-min) (point-max))
  (replace-string "o er" "offer" nil (point-min) (point-max))
  (replace-string "con den" "confiden" nil (point-min) (point-max))
  (replace-string "con ict" "conflict" nil (point-min) (point-max))
;(replace-string "nd" "find" nil (point-min) (point-max)); whole word only
;(replace-string "ve" "five" nil (point-min) (point-max)); this one should be whole word only
; (replace-string "ve" "they" nil (point-min) (point-max)); this one should be whole word only
; (replace-string "ve" "the" nil (point-min) (point-max)); this one should be whole word only
  (replace-string "scientifc" "scientific" nil (point-min) (point-max))

))
#+END_SRC

* web-mode
#+BEGIN_SRC emacs-lisp
    (use-package web-mode
      :defer
      :init
      (add-hook 'web-mode-hook (lambda () (abbrev-mode -1)))
       (rainbow-mode)
       (rspec-mode)
       (setq web-mode-markup-indent-offset 2)
      :bind (:map web-mode-map
      ("s-O" . prelude-open-with)))
#+END_SRC

* flyspell fix
#+BEGIN_SRC emacs-lisp
(setq flyspell-abbrev-p t)
(setq flyspell-use-global-abbrev-table-p t)
(setq global-flyspell-mode t)
#+END_SRC




* mw-thesaurus
#+BEGIN_SRC emacs-lisp
(use-package mw-thesaurus
  :defer)
(load "/Users/jay/emacs/emacs-secret/secret-codes.el")
(define-key key-minor-mode-map (kbd "M-s-t") 'mw-thesaurus-lookup-at-point)
#+END_SRC


