#+TITLE: ox-astro Change Log
#+AUTHOR: Jay Dixit & Claude
#+DATE: 2025-07-31

* Raw Image Path Processing Feature

** Problem Statement

The original ox-astro exporter had limited image handling capabilities. It could handle cover images and linked images (=[file:path]=) but could not process raw image paths that appear directly in the text, such as:

#+begin_example
*** ✅ Volume Goals
foo

/Users/jay/Downloads/Volume.png
#+end_example

When users included raw absolute image paths in their Org documents, they would either be ignored or exported as plain text, missing the opportunity for proper Astro optimization.

** Requirements

We needed to implement a feature that would:

1. **Detect** raw image paths anywhere in the document (not just in paragraphs)
2. **Copy** images to the Astro assets folder (=src/assets/images/posts/=)  
3. **Generate** proper ES6 import statements
4. **Convert** raw paths to Astro =<Image>= components for optimization
5. **Auto-save** selected posts folder to Org file for future exports

** Technical Challenges Encountered

*** Challenge 1: Data Persistence Across Export Phases

*Problem:* Org's export system has multiple phases (parse-tree filter → transcoding → body filter → final filter). Data stored in the =info= plist during the parse-tree phase was not persisting to later phases.

*Symptoms:*
- Debug showed: "Storing 1 image imports" during parse-tree phase
- But later phases showed: "image-imports: nil"

*Root Cause:* The =info= plist may be copied or reset between export phases, losing custom data.

*Solution:* Implemented a dual-storage approach:
#+begin_src emacs-lisp
;; Global variable to persist data across export phases
(defvar org-astro--current-body-images-imports nil)

;; Store in both places
(setq org-astro--current-body-images-imports final-data)
(plist-put info :astro-body-images-imports final-data)

;; Retrieve with fallback
(or (plist-get info :astro-body-images-imports)
    org-astro--current-body-images-imports)
#+end_src

*Lesson:* When working with Org export filters, always plan for data persistence issues. Global variables can serve as reliable fallbacks.

*** Challenge 2: Markdown Pre-processing Interference

*Problem:* Raw image paths were being converted to markdown image syntax (=![img](/path/to/image.png)=) by the underlying markdown backend before our custom transcoders could process them.

*Detection Method:* Added debug messages to trace the export pipeline:
#+begin_src emacs-lisp
(message "DEBUG: Found raw image path: %s" text)
(message "DEBUG: Processing markdown image: %s" match)
#+end_src

*Solution:* Implemented processing at multiple levels:
1. **Parse-tree filter**: Collect raw image paths from plain-text elements
2. **Plain-text transcoder**: Handle raw paths that weren't pre-processed  
3. **Final output filter**: Convert any remaining markdown image syntax

*Lesson:* In derived export backends, expect interference from parent backends. Plan for multiple intervention points in the export pipeline.

*** Challenge 3: Regex Pattern Precision

*Problem:* Initial regex patterns were too broad, matching unintended text or failing to match absolute paths.

*Evolution:*
- Started with: =\\.\\(png\\|jpe\\?g\\)$= (matched any path ending in extensions)
- Refined to: =^/.*\\.\\(png\\|jpe?g\\)$= (only absolute paths)

*Lesson:* Start with specific regex patterns for well-defined use cases. Absolute paths are more predictable than relative ones.

** Implementation Architecture

*** 1. Image Collection (Parse-Tree Filter)

#+begin_src emacs-lisp
(defun org-astro-prepare-images-filter (tree _backend info)
  ;; Map over all plain-text elements to find raw image paths
  (org-element-map tree 'plain-text
    (lambda (text-element)
      ;; Process each line in the text element
      (dolist (line (split-string raw-text "\n"))
        (when (and (string-match-p "^/.*\\.\\(png\\|jpe?g\\)$" text)
                   (file-exists-p text))
          ;; Copy image and store import data
          ))))
#+end_src

*** 2. Import Generation (Body Filter)

#+begin_src emacs-lisp
(defun org-astro-body-filter (body _backend info)
  ;; Generate three types of imports:
  ;; 1. Astro Image component: import { Image } from 'astro:assets';
  ;; 2. Cover image: import hero from '~/assets/images/posts/cover.png';  
  ;; 3. Body images: import volume from '~/assets/images/posts/Volume.png';
  )
#+end_src

*** 3. Content Conversion (Final Output Filter)

#+begin_src emacs-lisp
(defun org-astro-final-output-filter (output _backend info)
  ;; Convert: ![img](/Users/jay/Downloads/Volume.png)
  ;; To: <Image src={volume} alt="img" />
  )
#+end_src

** Key Design Decisions

*** File Naming Strategy
- **Input**: =/Users/jay/Downloads/Volume.png=
- **Variable**: =Volume= (camelCase, no extension)
- **Destination**: =src/assets/images/posts/Volume.png=
- **Import path**: =~/assets/images/posts/Volume.png= (Astro alias)

*** Component Choice
- **Decision**: Use =<Image>= component instead of =<img>= tags
- **Rationale**: Astro's =<Image>= provides automatic optimization, lazy loading, and responsive images
- **Requirement**: Auto-import =import { Image } from 'astro:assets';=

*** Storage Location Strategy
- **Posts**: =src/assets/images/posts/=
- **Authors**: =src/assets/images/authors/=  
- **Rationale**: Organize by content type for better asset management

** User Experience Improvements

*** Auto-Save Posts Folder
#+begin_src emacs-lisp
;; When user selects a posts folder, automatically save it to the Org file
(insert (format "#+POSTS_FOLDER: %s" selection))
(save-buffer)
#+end_src

*** Duplicate Front Matter Prevention
#+begin_src emacs-lisp
;; Track seen keys to prevent duplicate YAML entries
(let ((seen-keys '()))
  (when (not (memq key seen-keys))
    (push key seen-keys)
    ;; Add to YAML
    ))
#+end_src

** Testing & Debugging Strategy

*** Debug Message Pattern
#+begin_src emacs-lisp
;; Parse-tree phase
(message "DEBUG: Found raw image path: %s" text)
(message "DEBUG: Storing %d image imports: %s" (length data) data)

;; Body filter phase  
(message "DEBUG: Generating imports for: %s" body-images-imports)

;; Final filter phase
(message "DEBUG: Final filter - image-imports: %s" image-imports)
(message "DEBUG: Processing markdown image: %s" match)
#+end_src

*** Systematic Testing Approach
1. **Unit level**: Test individual functions with known inputs
2. **Integration level**: Test data flow between export phases
3. **End-to-end**: Test complete export workflow
4. **Edge cases**: Test with missing files, invalid paths, etc.

** File System Operations

*** Safety Measures
#+begin_src emacs-lisp
;; Always check file existence before processing
(when (file-exists-p text)
  ;; Create destination directory if needed
  (make-directory assets-folder t)
  ;; Avoid overwriting existing files
  (unless (file-exists-p dest-path)
    (copy-file expanded-path dest-path t)))
#+end_src

** Lessons Learned

*** 1. Org Export Architecture
- Export happens in distinct phases with potential data loss between phases
- Parse-tree filters run early and are good for data collection
- Final output filters are best for string-based transformations
- Global variables can bridge data persistence gaps

*** 2. Regex Development
- Start specific, then generalize if needed
- Test regex patterns with actual file paths from your use case
- Consider edge cases like paths with spaces or special characters

*** 3. Debugging Complex Systems
- Add debug messages at every phase boundary
- Use descriptive messages that show actual data values
- Remove debug messages once feature is stable

*** 4. User Experience Design
- Auto-save user selections to reduce friction
- Provide clear feedback about what files are being processed
- Handle missing dependencies gracefully

*** 5. Asset Management
- Use consistent naming conventions for imported variables
- Organize assets by content type (posts/, authors/, etc.)
- Leverage framework-specific optimizations (Astro's tilde alias)

** Future Enhancements

*** Potential Improvements
1. **Support for more image formats** (webp, avif, svg)
2. **Relative path handling** for more flexible workflows  
3. **Image optimization settings** (quality, formats, sizes)
4. **Batch processing** for multiple images in one line
5. **Smart alt text generation** from EXIF data or AI

*** Performance Considerations
- Consider lazy loading for documents with many images
- Implement caching for repeated exports of the same document
- Add progress indicators for large image processing operations

** Code Quality Improvements Made

*** Eliminated Duplicate Code
- Consolidated image processing logic into shared functions
- Unified import generation across different image sources

*** Error Handling
- Added file existence checks before processing
- Graceful fallbacks when image processing fails
- Clear error messages for debugging

*** Documentation
- Added comprehensive docstrings to all functions
- Included usage examples in comments
- Created this change log for future reference

** Summary

This feature successfully bridges the gap between Org mode's plain text nature and Astro's optimized image handling. The implementation demonstrates several important principles:

1. **Data persistence** across complex export pipelines
2. **Multi-phase processing** to handle various input formats
3. **User experience** optimization through automation
4. **Systematic debugging** for complex integrations

The solution transforms a simple raw image path into a fully optimized Astro image component with minimal user intervention, making the org-to-astro workflow significantly more powerful and user-friendly.